From eecfbdafdcdbb87fac1c4119fb1b1b7537c8ac03 Mon Sep 17 00:00:00 2001
From: rofl0r <rofl0r@users.noreply.github.com>
Date: Wed, 16 Mar 2022 18:34:21 +0000
Subject: [PATCH] add sdk headers

diff --git a/newlib/psp/include/arpa/inet.h b/newlib/psp/include/arpa/inet.h
new file mode 100644
index 0000000..f441b9c
--- /dev/null
+++ b/newlib/psp/include/arpa/inet.h
@@ -0,0 +1,26 @@
+/* arpa/inet.h - Functions for converting IP addresses between strings and numbers */
+
+#ifndef _ARPA_INET_H_
+#define _ARPA_INET_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <netinet/in.h>
+
+in_addr_t sceNetInetInetAddr(const char *ip);
+int sceNetInetInetAton(const char *ip, struct in_addr *in);
+const char* sceNetInetInetNtop(int af, const void *src, char *dst, socklen_t cnt);
+int sceNetInetInetPton(int af, const char *src, void *dst);
+
+char *inet_ntoa(struct in_addr in);
+#define inet_addr sceNetInetInetAddr
+#define inet_aton sceNetInetInetAton
+#define inet_ntop sceNetInetInetNtop
+#define inet_pton sceNetInetInetPton
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _ARPA_INET_H_ */
diff --git a/newlib/psp/include/as_reg_compat.h b/newlib/psp/include/as_reg_compat.h
new file mode 100644
index 0000000..346753c
--- /dev/null
+++ b/newlib/psp/include/as_reg_compat.h
@@ -0,0 +1,51 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * as_reg_compat.h - Register name mapping.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __AS_REG_COMPAT_H__
+#define __AS_REG_COMPAT_H__
+
+/* register defines for the GNU assembler */
+
+#define zero    0
+#define at      1
+#define v0      2
+#define v1      3
+#define a0      4
+#define a1      5
+#define a2      6
+#define a3      7
+#define t0      8
+#define t1      9
+#define t2      10
+#define t3      11
+#define t4      12
+#define t5      13
+#define t6      14
+#define t7      15
+#define s0      16
+#define s1      17
+#define s2      18
+#define s3      19
+#define s4      20
+#define s5      21
+#define s6      22
+#define s7      23
+#define t8      24
+#define t9      25
+#define k0      26
+#define k1      27
+#define gp      28
+#define sp      29
+#define fp      30
+#define ra      31
+
+#endif
diff --git a/newlib/psp/include/netdb.h b/newlib/psp/include/netdb.h
new file mode 100644
index 0000000..bb8cdb4
--- /dev/null
+++ b/newlib/psp/include/netdb.h
@@ -0,0 +1,36 @@
+/* Simple gethostbyname and gethostbyaddr replacements, note not thread safe */
+#ifndef __NETDB_H__
+#define __NETDB_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	NETDB_INTERNAL	-1	/* see errno */
+#define	NETDB_SUCCESS	0	/* no problem */
+#define	HOST_NOT_FOUND	1 /* Authoritative Answer Host not found */
+#define	TRY_AGAIN	2 /* Non-Authoritative Host not found, or SERVERFAIL */
+#define	NO_RECOVERY	3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
+#define	NO_DATA		4 /* Valid name, no data record of requested type */
+#define	NO_ADDRESS	NO_DATA		/* no address, look for MX record */
+
+extern int h_errno;
+
+struct hostent
+{
+	char *h_name;
+	char **h_aliases;
+	int  h_addrtype;
+	int  h_length;
+	char **h_addr_list;
+	char *h_addr;
+};
+
+struct hostent *gethostbyaddr(const void *addr, int len, int type);
+struct hostent *gethostbyname(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/netinet/in.h b/newlib/psp/include/netinet/in.h
new file mode 100644
index 0000000..86134a9
--- /dev/null
+++ b/newlib/psp/include/netinet/in.h
@@ -0,0 +1,280 @@
+/*	$NetBSD: in.h,v 1.71 2005/08/05 09:21:25 elad Exp $	*/
+
+/*
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)in.h	8.3 (Berkeley) 1/3/94
+ */
+
+/*
+ * Constants and structures defined by the internet system,
+ * Per RFC 790, September 1981, and numerous additions.
+ */
+
+#ifndef _NETINET_IN_H_
+#define	_NETINET_IN_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+typedef uint32_t in_addr_t;
+typedef uint16_t	in_port_t;
+
+/*
+ * Protocols
+ */
+#define	IPPROTO_IP		0		/* dummy for IP */
+#define	IPPROTO_HOPOPTS		0		/* IP6 hop-by-hop options */
+#define	IPPROTO_ICMP		1		/* control message protocol */
+#define	IPPROTO_IGMP		2		/* group mgmt protocol */
+#define	IPPROTO_GGP		3		/* gateway^2 (deprecated) */
+#define	IPPROTO_IPV4		4 		/* IP header */
+#define	IPPROTO_IPIP		4		/* IP inside IP */
+#define	IPPROTO_TCP		6		/* tcp */
+#define	IPPROTO_EGP		8		/* exterior gateway protocol */
+#define	IPPROTO_PUP		12		/* pup */
+#define	IPPROTO_UDP		17		/* user datagram protocol */
+#define	IPPROTO_IDP		22		/* xns idp */
+#define	IPPROTO_TP		29 		/* tp-4 w/ class negotiation */
+#define	IPPROTO_IPV6		41		/* IP6 header */
+#define	IPPROTO_ROUTING		43		/* IP6 routing header */
+#define	IPPROTO_FRAGMENT	44		/* IP6 fragmentation header */
+#define	IPPROTO_RSVP		46		/* resource reservation */
+#define	IPPROTO_GRE		47		/* GRE encaps RFC 1701 */
+#define	IPPROTO_ESP		50 		/* encap. security payload */
+#define	IPPROTO_AH		51 		/* authentication header */
+#define	IPPROTO_MOBILE		55		/* IP Mobility RFC 2004 */
+#define	IPPROTO_IPV6_ICMP	58		/* IPv6 ICMP */
+#define	IPPROTO_ICMPV6		58		/* ICMP6 */
+#define	IPPROTO_NONE		59		/* IP6 no next header */
+#define	IPPROTO_DSTOPTS		60		/* IP6 destination option */
+#define	IPPROTO_EON		80		/* ISO cnlp */
+#define	IPPROTO_ETHERIP		97		/* Ethernet-in-IP */
+#define	IPPROTO_ENCAP		98		/* encapsulation header */
+#define	IPPROTO_PIM		103		/* Protocol indep. multicast */
+#define	IPPROTO_IPCOMP		108		/* IP Payload Comp. Protocol */
+#define	IPPROTO_VRRP		112		/* VRRP RFC 2338 */
+
+#define	IPPROTO_RAW		255		/* raw IP packet */
+#define	IPPROTO_MAX		256
+
+/* last return value of *_input(), meaning "all job for this pkt is done".  */
+#define	IPPROTO_DONE		257
+
+/* sysctl placeholder for (FAST_)IPSEC */
+#define CTL_IPPROTO_IPSEC	258
+
+
+/*
+ * Local port number conventions:
+ *
+ * Ports < IPPORT_RESERVED are reserved for privileged processes (e.g. root),
+ * unless a kernel is compiled with IPNOPRIVPORTS defined.
+ *
+ * When a user does a bind(2) or connect(2) with a port number of zero,
+ * a non-conflicting local port address is chosen.
+ *
+ * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
+ * that is settable by sysctl(3); net.inet.ip.anonportmin and
+ * net.inet.ip.anonportmax respectively.
+ *
+ * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
+ * default assignment range.
+ *
+ * The value IP_PORTRANGE_DEFAULT causes the default behavior.
+ *
+ * The value IP_PORTRANGE_HIGH is the same as IP_PORTRANGE_DEFAULT,
+ * and exists only for FreeBSD compatibility purposes.
+ *
+ * The value IP_PORTRANGE_LOW changes the range to the "low" are
+ * that is (by convention) restricted to privileged processes.
+ * This convention is based on "vouchsafe" principles only.
+ * It is only secure if you trust the remote host to restrict these ports.
+ * The range is IPPORT_RESERVEDMIN to IPPORT_RESERVEDMAX.
+ */
+
+#define	IPPORT_RESERVED		1024
+#define	IPPORT_ANONMIN		49152
+#define	IPPORT_ANONMAX		65535
+#define	IPPORT_RESERVEDMIN	600
+#define	IPPORT_RESERVEDMAX	(IPPORT_RESERVED-1)
+
+/*
+ * Internet address (a structure for historical reasons)
+ */
+struct in_addr {
+	in_addr_t s_addr;
+} __attribute__((__packed__));
+
+#define	__IPADDR(x)	((uint32_t)(x))
+
+#define	IN_CLASSA(i)		(((uint32_t)(i) & __IPADDR(0x80000000)) == \
+				 __IPADDR(0x00000000))
+#define	IN_CLASSA_NET		__IPADDR(0xff000000)
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		__IPADDR(0x00ffffff)
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(i)		(((uint32_t)(i) & __IPADDR(0xc0000000)) == \
+				 __IPADDR(0x80000000))
+#define	IN_CLASSB_NET		__IPADDR(0xffff0000)
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		__IPADDR(0x0000ffff)
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(i)		(((uint32_t)(i) & __IPADDR(0xe0000000)) == \
+				 __IPADDR(0xc0000000))
+#define	IN_CLASSC_NET		__IPADDR(0xffffff00)
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		__IPADDR(0x000000ff)
+
+#define	IN_CLASSD(i)		(((uint32_t)(i) & __IPADDR(0xf0000000)) == \
+				 __IPADDR(0xe0000000))
+/* These ones aren't really net and host fields, but routing needn't know. */
+#define	IN_CLASSD_NET		__IPADDR(0xf0000000)
+#define	IN_CLASSD_NSHIFT	28
+#define	IN_CLASSD_HOST		__IPADDR(0x0fffffff)
+#define	IN_MULTICAST(i)		IN_CLASSD(i)
+
+#define	IN_EXPERIMENTAL(i)	(((uint32_t)(i) & __IPADDR(0xf0000000)) == \
+				 __IPADDR(0xf0000000))
+#define	IN_BADCLASS(i)		(((uint32_t)(i) & __IPADDR(0xf0000000)) == \
+				 __IPADDR(0xf0000000))
+
+#define	IN_LOCAL_GROUP(i)	(((uint32_t)(i) & __IPADDR(0xffffff00)) == \
+				 __IPADDR(0xe0000000))
+
+#define	INADDR_ANY		__IPADDR(0x00000000)
+#define	INADDR_LOOPBACK		__IPADDR(0x7f000001)
+#define	INADDR_BROADCAST	__IPADDR(0xffffffff)	/* must be masked */
+
+#define	INADDR_UNSPEC_GROUP	__IPADDR(0xe0000000)	/* 224.0.0.0 */
+#define	INADDR_ALLHOSTS_GROUP	__IPADDR(0xe0000001)	/* 224.0.0.1 */
+#define	INADDR_ALLRTRS_GROUP	__IPADDR(0xe0000002)	/* 224.0.0.2 */
+#define	INADDR_MAX_LOCAL_GROUP	__IPADDR(0xe00000ff)	/* 224.0.0.255 */
+
+#define	IN_LOOPBACKNET		127			/* official! */
+
+/*
+ * Socket address, internet style.
+ */
+struct sockaddr_in {
+	uint8_t		sin_len;
+	sa_family_t	sin_family;
+	in_port_t	sin_port;
+	struct in_addr	sin_addr;
+	int8_t	sin_zero[8];
+};
+
+#define	INET_ADDRSTRLEN                 16
+
+/*
+ * Structure used to describe IP options.
+ * Used to store options internally, to pass them to a process,
+ * or to restore options retrieved earlier.
+ * The ip_dst is used for the first-hop gateway when using a source route
+ * (this gets put into the header proper).
+ */
+struct ip_opts {
+	struct in_addr	ip_dst;		/* first hop, 0 w/o src rt */
+#if defined(__cplusplus)
+	int8_t	Ip_opts[40];	/* actually variable in size */
+#else
+	int8_t	ip_opts[40];	/* actually variable in size */
+#endif
+};
+
+/*
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ */
+#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
+#define	IP_HDRINCL		2    /* int; header is included with data */
+#define	IP_TOS			3    /* int; IP type of service and preced. */
+#define	IP_TTL			4    /* int; IP time to live */
+#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
+#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
+#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
+#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
+#define	IP_MULTICAST_IF		9    /* in_addr; set/get IP multicast i/f  */
+#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
+#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
+#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
+#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
+#define	IP_PORTRANGE		19   /* int; range to use for ephemeral port */
+#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
+#define	IP_ERRORMTU		21   /* int; get MTU of last xmit = EMSGSIZE */
+#if 1 /*IPSEC*/
+#define	IP_IPSEC_POLICY		22 /* struct; get/set security policy */
+#endif
+
+/*
+ * Defaults and limits for options
+ */
+#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
+#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
+#define	IP_MAX_MEMBERSHIPS	20	/* per socket; must fit in one mbuf */
+
+/*
+ * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
+ */
+struct ip_mreq {
+	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
+	struct	in_addr imr_interface;	/* local IP address of interface */
+};
+
+/*
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IP_PORTRANGE_DEFAULT	0	/* default range */
+#define	IP_PORTRANGE_HIGH	1	/* same as DEFAULT (FreeBSD compat) */
+#define	IP_PORTRANGE_LOW	2	/* use privileged range */
+
+
+#if 0
+// FIXME: These are optimized (one instruction), but currently not part of psp-gcc
+#define ntohs(x) __builtin_allegrex_wsbh(x)
+#define ntohl(x) __builtin_allegrex_wsbw(x)
+#define htons(x) __builtin_allegrex_wsbh(x)
+#define htonl(x) __builtin_allegrex_wsbw(x)
+#else
+#define ntohs(x) __builtin_bswap16(x)
+#define ntohl(x) __builtin_bswap32(x)
+#define htons(x) __builtin_bswap16(x)
+#define htonl(x) __builtin_bswap32(x)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_NETINET_IN_H_ */
diff --git a/newlib/psp/include/netinet/tcp.h b/newlib/psp/include/netinet/tcp.h
new file mode 100644
index 0000000..deda3f2
--- /dev/null
+++ b/newlib/psp/include/netinet/tcp.h
@@ -0,0 +1,12 @@
+#ifndef __NETINET_TCP_H__
+#define __NETINET_TCP_H__
+
+#include <netinet/in.h>
+
+#define SOL_TCP    IPPROTO_TCP
+
+/* Socket options */
+#define	TCP_NODELAY	0x01	/* don't delay send to coalesce packets */
+#define	TCP_MAXSEG	0x02	/* set maximum segment size */
+
+#endif
diff --git a/newlib/psp/include/pspatrac3.h b/newlib/psp/include/pspatrac3.h
new file mode 100644
index 0000000..5482743
--- /dev/null
+++ b/newlib/psp/include/pspatrac3.h
@@ -0,0 +1,213 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspatrac3.h - Prototypes for the sceAtrac3plus library
+ *
+ * Copyright (c) 2006 moonlight
+ *
+ */
+#ifndef __LIBATRAC3_H__
+#define __LIBATRAC3_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Error code definition */
+#define PSP_ATRAC_SUCCESS                       SCE_OK
+
+#define PSP_ATRAC_ERROR_PARAM_FAIL              (0x80630001)
+#define PSP_ATRAC_ERROR_API_FAIL                (0x80630002)
+#define PSP_ATRAC_ERROR_NO_ATRACID              (0x80630003)
+#define PSP_ATRAC_ERROR_BAD_CODECTYPE           (0x80630004)
+#define PSP_ATRAC_ERROR_BAD_ATRACID             (0x80630005)
+#define PSP_ATRAC_ERROR_UNKNOWN_FORMAT          (0x80630006)
+#define PSP_ATRAC_ERROR_UNMATCH_FORMAT          (0x80630007)
+#define PSP_ATRAC_ERROR_BAD_DATA                (0x80630008)
+#define PSP_ATRAC_ERROR_ALLDATA_IS_ONMEMORY     (0x80630009)
+#define PSP_ATRAC_ERROR_UNSET_DATA              (0x80630010)
+
+#define PSP_ATRAC_ERROR_READSIZE_IS_TOO_SMALL   (0x80630011)
+#define PSP_ATRAC_ERROR_NEED_SECOND_BUFFER      (0x80630012)
+#define PSP_ATRAC_ERROR_READSIZE_OVER_BUFFER    (0x80630013)
+#define PSP_ATRAC_ERROR_NOT_4BYTE_ALIGNMENT     (0x80630014)
+#define PSP_ATRAC_ERROR_BAD_SAMPLE              (0x80630015)
+#define PSP_ATRAC_ERROR_WRITEBYTE_FIRST_BUFFER  (0x80630016)
+#define PSP_ATRAC_ERROR_WRITEBYTE_SECOND_BUFFER (0x80630017)
+#define PSP_ATRAC_ERROR_ADD_DATA_IS_TOO_BIG     (0x80630018)
+
+#define PSP_ATRAC_ERROR_UNSET_PARAM             (0x80630021)
+#define PSP_ATRAC_ERROR_NONEED_SECOND_BUFFER    (0x80630022)
+#define PSP_ATRAC_ERROR_NODATA_IN_BUFFER        (0x80630023)
+#define PSP_ATRAC_ERROR_ALLDATA_WAS_DECODED     (0x80630024)
+
+/* Audio Codec ID */
+#define PSP_ATRAC_AT3PLUS        (0x00001000)
+#define PSP_ATRAC_AT3            (0x00001001)
+
+/* Remain Frame typical Status */
+#define PSP_ATRAC_ALLDATA_IS_ON_MEMORY             (-1)
+#define PSP_ATRAC_NONLOOP_STREAM_DATA_IS_ON_MEMORY (-2)
+#define PSP_ATRAC_LOOP_STREAM_DATA_IS_ON_MEMORY    (-3)
+
+typedef struct {
+	u8 *pucWritePositionFirstBuf;
+	u32 uiWritableByteFirstBuf;
+	u32 uiMinWriteByteFirstBuf;
+	u32 uiReadPositionFirstBuf;
+
+	u8 *pucWritePositionSecondBuf;
+	u32 uiWritableByteSecondBuf;
+	u32 uiMinWriteByteSecondBuf;
+	u32 uiReadPositionSecondBuf;
+} PspBufferInfo;
+
+int sceAtracGetAtracID(uint  uiCodecType);
+
+/**
+ * Creates a new Atrac ID from the specified data
+ *
+ * @param buf - the buffer holding the atrac3 data, including the RIFF/WAVE header.
+ * @param bufsize - the size of the buffer pointed by buf
+ *
+ * @return the new atrac ID, or < 0 on error 
+*/
+int sceAtracSetDataAndGetID(void *buf, SceSize bufsize);
+
+/**
+ * Decode a frame of data. 
+ *
+ * @param atracID - the atrac ID
+ * @param outSamples - pointer to a buffer that receives the decoded data of the current frame
+ * @param outN - pointer to a integer that receives the number of audio samples of the decoded frame
+ * @param outEnd - pointer to a integer that receives a boolean value indicating if the decoded frame is the last one
+ * @param outRemainFrame - pointer to a integer that receives either -1 if all at3 data is already on memory, 
+ *  or the remaining (not decoded yet) frames at memory if not all at3 data is on memory
+ *
+ * 
+ * @return < 0 on error, otherwise 0
+ *
+*/
+int sceAtracDecodeData(int atracID, u16 *outSamples, int *outN, int *outEnd, int *outRemainFrame);
+
+/**
+ * Gets the remaining (not decoded) number of frames
+ * 
+ * @param atracID - the atrac ID
+ * @param outRemainFrame - pointer to a integer that receives either -1 if all at3 data is already on memory, 
+ *  or the remaining (not decoded yet) frames at memory if not all at3 data is on memory 
+ *
+ * @return < 0 on error, otherwise 0
+ *
+*/
+int sceAtracGetRemainFrame(int atracID, int *outRemainFrame);
+
+/**
+ *
+ * @param atracID - the atrac ID
+ * @param writePointer - Pointer to where to read the atrac data
+ * @param availableBytes - Number of bytes available at the writePointer location
+ * @param readOffset - Offset where to seek into the atrac file before reading
+ *
+ * @return < 0 on error, otherwise 0
+ *
+*/
+
+int sceAtracGetStreamDataInfo(int atracID, u8** writePointer, u32* availableBytes, u32* readOffset);
+
+/**
+ *
+ * @param atracID - the atrac ID
+ * @param bytesToAdd - Number of bytes read into location given by sceAtracGetStreamDataInfo().
+ *
+ * @return < 0 on error, otherwise 0
+*/
+int sceAtracAddStreamData(int atracID, unsigned int bytesToAdd);
+
+/**
+ * Gets the bitrate.
+ *
+ * @param atracID - the atracID
+ * @param outBitrate - pointer to a integer that receives the bitrate in kbps
+ *
+ * @return < 0 on error, otherwise 0
+ *
+*/
+int sceAtracGetBitrate(int atracID, int *outBitrate);
+
+/**
+ * Sets the number of loops for this atrac ID
+ *
+ * @param atracID - the atracID
+ * @param nloops - the number of loops to set
+ *
+ * @return < 0 on error, otherwise 0
+ *
+*/
+int sceAtracSetLoopNum(int atracID, int nloops);
+
+/**
+ * It releases an atrac ID
+ *
+ * @param atracID - the atrac ID to release
+ *
+ * @return < 0 on error
+ *
+*/
+int sceAtracReleaseAtracID(int atracID);
+
+/**
+ * Gets the number of samples of the next frame to be decoded.
+ *
+ * @param atracID - the atrac ID
+ * @param outN - pointer to receives the number of samples of the next frame.
+ *
+ * @return < 0 on error, otherwise 0
+ *
+ */
+int sceAtracGetNextSample(int atracID, int *outN);
+
+/**
+ * Gets the maximum number of samples of the atrac3 stream.
+ *
+ * @param atracID - the atrac ID
+ * @param outMax  - pointer to a integer that receives the maximum number of samples.
+ *
+ * @return < 0 on error, otherwise 0
+ *
+ */
+int sceAtracGetMaxSample(int atracID, int *outMax); 
+
+int sceAtracGetBufferInfoForReseting(int atracID, u32 uiSample, PspBufferInfo *pBufferInfo);
+
+int sceAtracGetChannel(int atracID, u32 *puiChannel);
+
+int sceAtracGetInternalErrorInfo(int atracID, int *piResult);
+
+int sceAtracGetLoopStatus(int atracID, int *piLoopNum, u32 *puiLoopStatus);
+
+int sceAtracGetNextDecodePosition(int atracID, u32 *puiSamplePosition);
+
+int sceAtracGetSecondBufferInfo(int atracID, u32 *puiPosition, u32 *puiDataByte);
+
+int sceAtracGetSoundSample(int atracID, int *piEndSample, int *piLoopStartSample, int *piLoopEndSample);
+
+int sceAtracResetPlayPosition(int atracID, u32 uiSample, u32 uiWriteByteFirstBuf, u32 uiWriteByteSecondBuf);
+
+int sceAtracSetData(int atracID, u8 *pucBufferAddr, u32 uiBufferByte);
+
+int sceAtracSetHalfwayBuffer(int atracID, u8 *pucBufferAddr, u32 uiReadByte, u32 uiBufferByte);
+
+int sceAtracSetHalfwayBufferAndGetID(u8 *pucBufferAddr, u32 uiReadByte, u32 uiBufferByte);
+
+int sceAtracSetSecondBuffer(int atracID, u8 *pucSecondBufferAddr, u32 uiSecondBufferByte);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspaudio.h b/newlib/psp/include/pspaudio.h
new file mode 100644
index 0000000..4edd352
--- /dev/null
+++ b/newlib/psp/include/pspaudio.h
@@ -0,0 +1,367 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudio.h - Prototypes for the sceAudio library.
+ *
+ * Copyright (c) 2005 Adresd
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2007 cooleyes
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ * Copyright (c) 2008 David Perry <tias_dp@hotmail.com>
+ *
+ */
+#ifndef PSPAUDIO_H
+#define PSPAUDIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup Audio User Audio Library */
+
+/** @addtogroup Audio */
+
+/*@{*/
+
+/** The maximum output volume. */
+#define PSP_AUDIO_VOLUME_MAX    0x8000
+
+/** The maximum number of hardware channels. */
+#define PSP_AUDIO_CHANNEL_MAX   8
+
+/** Used to request the next available hardware channel. */
+#define PSP_AUDIO_NEXT_CHANNEL  (-1)
+  
+/** Error codes used as return values for the Audio Driver. */
+#define SCE_AUDIO_ERROR_NOT_INITIALIZED (0x80260001)
+#define SCE_AUDIO_ERROR_OUTPUT_BUSY (0x80260002)
+#define SCE_AUDIO_ERROR_INVALID_CH (0x80260003)
+#define SCE_AUDIO_ERROR_PRIV_REQUIRED (0x80260004)
+#define SCE_AUDIO_ERROR_NOT_FOUND (0x80260005)
+#define SCE_AUDIO_ERROR_INVALID_SIZE (0x80260006)
+#define SCE_AUDIO_ERROR_INVALID_FORMAT (0x80260007)
+#define SCE_AUDIO_ERROR_NOT_RESERVED (0x80260008)
+#define SCE_AUDIO_ERROR_NOT_OUTPUT (0x80260009)
+#define SCE_AUDIO_ERROR_INVALID_FREQUENCY (0x8026000A)
+#define SCE_AUDIO_ERROR_INVALID_VOLUME (0x8026000B)
+#define SCE_AUDIO_ERROR_INPUT_BUSY (0x80260010)
+
+enum PspAudioFormats
+{
+    /** Channel is set to stereo output. */
+    PSP_AUDIO_FORMAT_STEREO = 0,
+    /** Channel is set to mono output. */
+    PSP_AUDIO_FORMAT_MONO   = 0x10
+};
+
+typedef struct
+{
+	/** Unknown. Pass 0 */
+	int unknown1;
+	int gain;
+	/** Unknown. Pass 0 */
+	int unknown2;
+	/** Unknown. Pass 0 */
+	int unknown3;
+	/** Unknown. Pass 0 */
+	int unknown4;
+	/** Unknown. Pass 0 */
+	int unknown5;
+	
+} pspAudioInputParams;
+
+/** The minimum number of samples that can be allocated to a channel. */
+#define PSP_AUDIO_SAMPLE_MIN    64
+
+/** The maximum number of samples that can be allocated to a channel. */
+#define PSP_AUDIO_SAMPLE_MAX    65472
+
+/** Make the given sample count a multiple of 64. */
+#define PSP_AUDIO_SAMPLE_ALIGN(s) (((s) + 63) & ~63)
+ 
+/**
+  * Allocate and initialize a hardware output channel.
+  *
+  * @param channel - Use a value between 0 - 7 to reserve a specific channel.
+  *                   Pass PSP_AUDIO_NEXT_CHANNEL to get the first available channel.
+  * @param samplecount - The number of samples that can be output on the channel per
+  *                      output call.  It must be a value between ::PSP_AUDIO_SAMPLE_MIN
+  *                      and ::PSP_AUDIO_SAMPLE_MAX, and it must be aligned to 64 bytes
+  *                      (use the ::PSP_AUDIO_SAMPLE_ALIGN macro to align it).
+  * @param format - The output format to use for the channel.  One of ::PspAudioFormats.
+  *
+  * @return The channel number on success, an error code if less than 0.
+  */
+int sceAudioChReserve(int channel, int samplecount, int format);
+
+/**
+  * Release a hardware output channel.
+  *
+  * @param channel - The channel to release.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioChRelease(int channel);
+
+/**
+  * Output audio of the specified channel
+  *
+  * @param channel - The channel number.
+  *
+  * @param vol - The volume.
+  *
+  * @param buf - Pointer to the PCM data to output.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutput(int channel, int vol, void *buf);
+
+/**
+  * Output audio of the specified channel (blocking)
+  *
+  * @param channel - The channel number.
+  *
+  * @param vol - The volume.
+  *
+  * @param buf - Pointer to the PCM data to output.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutputBlocking(int channel, int vol, void *buf);
+
+/**
+  * Output panned audio of the specified channel
+  *
+  * @param channel - The channel number.
+  *
+  * @param leftvol - The left volume.
+  *
+  * @param rightvol - The right volume.
+  *
+  * @param buf - Pointer to the PCM data to output.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutputPanned(int channel, int leftvol, int rightvol, void *buf);
+
+/**
+  * Output panned audio of the specified channel (blocking)
+  *
+  * @param channel - The channel number.
+  *
+  * @param leftvol - The left volume.
+  *
+  * @param rightvol - The right volume.
+  *
+  * @param buf - Pointer to the PCM data to output.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutputPannedBlocking(int channel, int leftvol, int rightvol, void *buf);
+
+/**
+  * Get count of unplayed samples remaining
+  *
+  * @param channel - The channel number.
+  *
+  * @return Number of samples to be played, an error if less than 0.
+  */
+int sceAudioGetChannelRestLen(int channel);
+
+/**
+  * Get count of unplayed samples remaining
+  *
+  * @param channel - The channel number.
+  *
+  * @return Number of samples to be played, an error if less than 0.
+  */
+int sceAudioGetChannelRestLength(int channel);
+
+/**
+  * Change the output sample count, after it's already been reserved
+  *
+  * @param channel - The channel number.
+  * @param samplecount - The number of samples to output in one output call.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioSetChannelDataLen(int channel, int samplecount);
+
+/**
+  * Change the format of a channel
+  *
+  * @param channel - The channel number.
+  *
+  * @param format - One of ::PspAudioFormats
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioChangeChannelConfig(int channel, int format);
+
+/**
+  * Change the volume of a channel
+  *
+  * @param channel - The channel number.
+  *
+  * @param leftvol - The left volume.
+  *
+  * @param rightvol - The right volume.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioChangeChannelVolume(int channel, int leftvol, int rightvol);
+
+//sceAudioOneshotOutput ???
+
+/**
+  * Reserve the audio output and set the output sample count
+  *
+  * @param samplecount - The number of samples to output in one output call (min 17, max 4111).
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutput2Reserve(int samplecount);
+
+/**
+  * Release the audio output
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutput2Release(void);
+
+/**
+  * Change the output sample count, after it's already been reserved
+  *
+  * @param samplecount - The number of samples to output in one output call (min 17, max 4111).
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutput2ChangeLength(int samplecount);
+
+/**
+  * Output audio (blocking)
+  *
+  * @param vol - The volume.
+  *
+  * @param buf - Pointer to the PCM data.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioOutput2OutputBlocking(int vol, void *buf);
+
+/**
+  * Get count of unplayed samples remaining
+  *
+  * @return Number of samples to be played, an error if less than 0.
+  */
+int sceAudioOutput2GetRestSample(void);
+
+/**
+  * Reserve the audio output
+  *
+  * @param samplecount - The number of samples to output in one output call (min 17, max 4111).
+  *
+  * @param freq - The frequency. One of 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11050, 8000.
+  *
+  * @param channels - Number of channels. Pass 2 (stereo).
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioSRCChReserve(int samplecount, int freq, int channels);
+
+/**
+  * Release the audio output
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioSRCChRelease(void);
+
+/**
+  * Output audio
+  *
+  * @param vol - The volume.
+  *
+  * @param buf - Pointer to the PCM data to output.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioSRCOutputBlocking(int vol, void *buf);
+
+/**
+  * Init audio input
+  *
+  * @param unknown1 - Unknown. Pass 0.
+  *
+  * @param gain - Gain.
+  *
+  * @param unknown2 - Unknown. Pass 0.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioInputInit(int unknown1, int gain, int unknown2);
+
+/**
+  * Init audio input (with extra arguments)
+  *
+  * @param params - A pointer to a ::pspAudioInputParams struct.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioInputInitEx(pspAudioInputParams *params);
+
+/**
+  * Perform audio input (blocking)
+  *
+  * @param samplecount - Number of samples.
+  *
+  * @param freq - Either 44100, 22050 or 11025.
+  *
+  * @param buf - Pointer to where the audio data will be stored.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioInputBlocking(int samplecount, int freq, void *buf);
+
+/**
+  * Perform audio input
+  *
+  * @param samplecount - Number of samples.
+  *
+  * @param freq - Either 44100, 22050 or 11025.
+  *
+  * @param buf - Pointer to where the audio data will be stored.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioInput(int samplecount, int freq, void *buf);
+
+/**
+  * Get the number of samples that were acquired
+  *
+  * @return Number of samples acquired, an error if less than 0.
+  */
+int sceAudioGetInputLength(void);
+
+/**
+  * Wait for non-blocking audio input to complete
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioWaitInputEnd(void);
+
+/**
+  * Poll for non-blocking audio input status
+  *
+  * @return 0 if input has completed, 1 if not completed or an error if less than 0.
+  */
+int sceAudioPollInputEnd(void);
+
+/*@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPAUDIO_H */
diff --git a/newlib/psp/include/pspaudio_kernel.h b/newlib/psp/include/pspaudio_kernel.h
new file mode 100644
index 0000000..ffc27ff
--- /dev/null
+++ b/newlib/psp/include/pspaudio_kernel.h
@@ -0,0 +1,48 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudio.h - Prototypes for the sceAudio library.
+ *
+ * Copyright (c) 2005 Adresd
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2007 cooleyes
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+#ifndef PSPAUDIO_KERNEL_H
+#define PSPAUDIO_KERNEL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup Audio User Audio Library */
+
+/** @addtogroup Audio */
+
+/**@{*/
+
+enum PspAudioFrequencies {
+    /** Sampling frequency set to 44100Hz. */
+    PSP_AUDIO_FREQ_44K = 44100,
+    /** Sampling frequency set to 48000Hz. */
+    PSP_AUDIO_FREQ_48K = 48000
+};
+
+/**
+  * Set audio sampling frequency
+  *
+  * @param frequency - Sampling frequency to set audio output to - either 44100 or 48000.
+  *
+  * @return 0 on success, an error if less than 0.
+  */
+int sceAudioSetFrequency(int frequency);
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPAUDIO_KERNEL_H */
diff --git a/newlib/psp/include/pspaudiocodec.h b/newlib/psp/include/pspaudiocodec.h
new file mode 100644
index 0000000..f4ebe26
--- /dev/null
+++ b/newlib/psp/include/pspaudiocodec.h
@@ -0,0 +1,30 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudiocodec.h - Prototypes for the sceAudiocodec library.
+ *
+ * Copyright (c) 2006 hitchhikr
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_CODEC_AT3PLUS	(0x00001000)
+#define PSP_CODEC_AT3		(0x00001001)
+#define PSP_CODEC_MP3		(0x00001002)
+#define PSP_CODEC_AAC		(0x00001003)
+
+
+int sceAudiocodecCheckNeedMem(unsigned long *Buffer, int Type);
+int sceAudiocodecInit(unsigned long *Buffer, int Type);
+int sceAudiocodecDecode(unsigned long *Buffer, int Type);
+int sceAudiocodecGetEDRAM(unsigned long *Buffer, int Type);
+int sceAudiocodecReleaseEDRAM(unsigned long *Buffer);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/newlib/psp/include/pspaudiolib.h b/newlib/psp/include/pspaudiolib.h
new file mode 100644
index 0000000..e347221
--- /dev/null
+++ b/newlib/psp/include/pspaudiolib.h
@@ -0,0 +1,52 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudiolib.h - Audio library build on top of sceAudio, but to provide
+ *                 multiple thread usage and callbacks.
+ *
+ * Copyright (c) 2005 Adresd
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ *
+ */
+#ifndef __AUDIOLIB_H__
+#define __AUDIOLIB_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_NUM_AUDIO_CHANNELS 4
+/** This is the number of frames you can update per callback, a frame being
+ * 1 sample for mono, 2 samples for stereo etc. */
+#define PSP_NUM_AUDIO_SAMPLES 1024
+#define PSP_VOLUME_MAX 0x8000
+
+typedef void (* pspAudioCallback_t)(void *buf, unsigned int reqn, void *pdata);
+
+typedef struct {
+  int threadhandle;
+  int handle;
+  int volumeleft;
+  int volumeright;
+  pspAudioCallback_t callback;
+  void *pdata;
+} psp_audio_channelinfo;
+
+typedef int (* pspAudioThreadfunc_t)(int args, void *argp);
+
+int  pspAudioInit();
+void pspAudioEndPre();
+void pspAudioEnd();
+
+void pspAudioSetVolume(int channel, int left, int right);
+void pspAudioChannelThreadCallback(int channel, void *buf, unsigned int reqn);
+void pspAudioSetChannelCallback(int channel, pspAudioCallback_t callback, void *pdata);
+int  pspAudioOutBlocking(unsigned int channel, unsigned int vol1, unsigned int vol2, void *buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspaudiorouting.h b/newlib/psp/include/pspaudiorouting.h
new file mode 100644
index 0000000..16891bc
--- /dev/null
+++ b/newlib/psp/include/pspaudiorouting.h
@@ -0,0 +1,31 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudiorouting.h - Interface to sceAudioRouting.
+ *
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+#ifndef __PSPAUDIOROUTING_H__
+#define __PSPAUDIOROUTING_H__
+
+/**
+ * Set routing mode.
+ *
+ * @param mode The routing mode to set (0 or 1)
+ *
+ * @return the previous routing mode, or < 0 on error
+*/
+int sceAudioRoutingSetMode( int mode );
+
+/**
+ * Get routing mode.
+ *
+ * @return the current routing mode.
+*/
+int sceAudioRoutingGetMode();
+
+#endif
+
diff --git a/newlib/psp/include/pspchnnlsv.h b/newlib/psp/include/pspchnnlsv.h
new file mode 100644
index 0000000..848cec2
--- /dev/null
+++ b/newlib/psp/include/pspchnnlsv.h
@@ -0,0 +1,113 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  pspchnnlsv.h - Include for the pspChnnlsv library.
+ *
+ * Copyright (c) 2005 Jim Paris <jim@jtan.com>
+ * Copyright (c) 2005 psp123
+ *
+ */
+#ifndef __PSPCHNNLSV_H__
+#define __PSPCHNNLSV_H__
+
+/* The descriptions are mostly speculation. */
+
+/** @defgroup Chnnlsv Chnnlsv Library
+  * Library imports for the vsh chnnlsv library.
+  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/** @addtogroup Chnnlsv Chnnlsv Library */
+/**@{*/
+
+typedef struct _pspChnnlsvContext1 {
+	/** Cipher mode */
+	int	mode;
+
+	/** Context data */
+	char	buffer1[0x10];
+	char    buffer2[0x10];
+	int	unknown;
+} pspChnnlsvContext1;
+
+typedef struct _pspChnnlsvContext2 {
+	/** Context data */
+	char    unknown[0x100];
+} pspChnnlsvContext2;
+
+/**
+ * Initialize context
+ *
+ * @param ctx - Context
+ * @param mode - Cipher mode
+ * @return < 0 on error
+ */
+int sceChnnlsv_E7833020(pspChnnlsvContext1 *ctx, int mode);
+	
+/**
+ * Process data
+ *
+ * @param ctx - Context
+ * @param data - Data (aligned to 0x10)
+ * @param len - Length (aligned to 0x10)
+ * @return < 0 on error
+ */
+int sceChnnlsv_F21A1FCA(pspChnnlsvContext1 *ctx, unsigned char *data, int len);
+
+/**
+ * Finalize hash
+ *
+ * @param ctx - Context
+ * @param hash - Hash output (aligned to 0x10, 0x10 bytes long)
+ * @param cryptkey - Crypt key or NULL.
+ * @return < 0 on error
+ */
+int sceChnnlsv_C4C494F8(pspChnnlsvContext1 *ctx, 
+			unsigned char *hash, unsigned char *cryptkey);
+
+/**
+ * Prepare a key, and set up integrity check
+ *
+ * @param ctx - Context
+ * @param mode1 - Cipher mode
+ * @param mode2 - Encrypt mode (1 = encrypting, 2 = decrypting)
+ * @param hashkey - Key out
+ * @param cipherkey - Key in
+ * @return < 0 on error
+ */
+int sceChnnlsv_ABFDFC8B(pspChnnlsvContext2 *ctx, int mode1, int mode2,
+			unsigned char *hashkey, unsigned char *cipherkey);
+
+/**
+ * Process data for integrity check
+ *
+ * @param ctx - Context
+ * @param data - Data (aligned to 0x10)
+ * @param len - Length (aligned to 0x10)
+ * @return < 0 on error
+ */
+int sceChnnlsv_850A7FA1(pspChnnlsvContext2 *ctx, unsigned char *data, int len);
+
+/**
+ * Check integrity
+ *
+ * @param ctx - Context
+ * @return < 0 on error
+ */
+int sceChnnlsv_21BE78B4(pspChnnlsvContext2 *ctx);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/newlib/psp/include/pspctrl.h b/newlib/psp/include/pspctrl.h
new file mode 100644
index 0000000..d792618
--- /dev/null
+++ b/newlib/psp/include/pspctrl.h
@@ -0,0 +1,317 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspctrl.h - Prototypes for the sceCtrl library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef __CTRL_H__
+#define __CTRL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Ctrl Controller Kernel Library */
+/**@{*/
+
+/**
+ * Enumeration for the digital controller buttons.
+ *
+ * @note PSP_CTRL_HOME, PSP_CTRL_NOTE, PSP_CTRL_SCREEN, PSP_CTRL_VOLUP, PSP_CTRL_VOLDOWN, PSP_CTRL_DISC, PSP_CTRL_WLAN_UP, PSP_CTRL_REMOTE, PSP_CTRL_MS can only be read in kernel mode
+ */
+enum PspCtrlButtons
+{
+	/** Select button. */
+	PSP_CTRL_SELECT     = 0x000001,
+	/** Start button. */
+	PSP_CTRL_START      = 0x000008,
+	/** Up D-Pad button. */
+	PSP_CTRL_UP         = 0x000010,
+	/** Right D-Pad button. */
+	PSP_CTRL_RIGHT      = 0x000020,
+	/** Down D-Pad button. */
+	PSP_CTRL_DOWN      	= 0x000040,
+	/** Left D-Pad button. */
+	PSP_CTRL_LEFT      	= 0x000080,
+	/** Left trigger. */
+	PSP_CTRL_LTRIGGER   = 0x000100,
+	/** Right trigger. */
+	PSP_CTRL_RTRIGGER   = 0x000200,
+	/** Triangle button. */
+	PSP_CTRL_TRIANGLE   = 0x001000,
+	/** Circle button. */
+	PSP_CTRL_CIRCLE     = 0x002000,
+	/** Cross button. */
+	PSP_CTRL_CROSS      = 0x004000,
+	/** Square button. */
+	PSP_CTRL_SQUARE     = 0x008000,
+	/** Home button. In user mode this bit is set if the exit dialog is visible. */
+	PSP_CTRL_HOME       = 0x010000,
+	/** Hold button. */
+	PSP_CTRL_HOLD       = 0x020000,
+	/** Music Note button. */
+	PSP_CTRL_NOTE       = 0x800000,
+	/** Screen button. */
+	PSP_CTRL_SCREEN     = 0x400000,
+	/** Volume up button. */
+	PSP_CTRL_VOLUP      = 0x100000,
+	/** Volume down button. */
+	PSP_CTRL_VOLDOWN    = 0x200000,
+	/** Wlan switch up. */
+	PSP_CTRL_WLAN_UP    = 0x040000,
+	/** Remote hold position. */
+	PSP_CTRL_REMOTE     = 0x080000,	
+	/** Disc present. */
+	PSP_CTRL_DISC       = 0x1000000,
+	/** Memory stick present. */
+	PSP_CTRL_MS         = 0x2000000,
+};
+
+/** Controller mode. */
+enum PspCtrlMode
+{
+	/* Digital. */
+	PSP_CTRL_MODE_DIGITAL = 0,
+	/* Analog. */
+	PSP_CTRL_MODE_ANALOG
+};
+
+/** Returned controller data */
+typedef struct SceCtrlData {
+	/** The current read frame. */
+	unsigned int 	TimeStamp;
+	/** Bit mask containing zero or more of ::PspCtrlButtons. */
+	unsigned int 	Buttons;
+	/** Analogue stick, X axis. */
+	unsigned char 	Lx;
+	/** Analogue stick, Y axis. */
+	unsigned char 	Ly;
+	/** Reserved. */
+	unsigned char 	Rsrv[6];
+} SceCtrlData;
+
+/** 
+ * This structure represents controller button latch data.
+ * 
+ * With each sampling cycle, the controller service compares the new pressed & released button states
+ * with the previously collected pressed button states. This comparison will result in the following possible
+ * states for each button:
+ *
+ *    • [make]: The button has just been pressed with its prior state being the released state. Transition from
+ *      'released' state to 'pressed' state.\n 
+ *    • [press]: The button is currently in the 'pressed' state.\n 
+ *    • [break]: The button has just been released with its prior state being the 'pressed' state. Transition from
+ *      'pressed' state to 'release' state.\n 
+ *    • [release]: The button is currently in the 'released' state.
+ * 
+ * It is possible for a button to (briefly) be in two states at the same time. Valid combinations are as follows:
+ * 
+ *    • [make] & [press]\n 
+ *    • [break] & [release]
+ * 
+ * In other words, if a button is in the [make] state, then it is also in the [press] state. However, this is not the case
+ * for the inverse. A button in the [press] state does not need to be in the [make] state.
+ * 
+ * These comparison results are stored internally as latch data and can be retrieved using the APIs ::sceCtrlPeekLatch() and 
+ * ::sceCtrlReadLatch(). ::PspCtrlButtons can be used to find out the state of each button.
+ * 
+ * @remark The same can be accomplished by using the different sceCtrl[Read/Peek]Buffer[Positive/Negative]() APIs
+ * and comparing the currently collected button sampling data with the previously collected one.
+ * 
+ * @see ::sceCtrlPeekLatch()
+ * @see ::sceCtrlReadLatch()
+ */
+typedef struct SceCtrlLatch {
+	/** Button transitioned to pressed state. */
+	unsigned int 	uiMake;
+	/** Button transitioned to released state. */
+	unsigned int 	uiBreak;
+	/** Button is in the pressed state. */
+	unsigned int 	uiPress;
+	/** Button is in the released state. */
+	unsigned int 	uiRelease;
+} SceCtrlLatch;
+
+/**
+ * Set the controller cycle setting.
+ *
+ * @param cycle - Cycle.  Normally set to 0.
+ *
+ * @return The previous cycle setting.
+ */
+int sceCtrlSetSamplingCycle(int cycle);
+
+/**
+ * Get the controller current cycle setting.
+ *
+ * @param pcycle - Return value.
+ *
+ * @return 0.
+ */
+int sceCtrlGetSamplingCycle(int *pcycle);
+
+/**
+ * Set the controller mode.
+ *
+ * @param mode - One of ::PspCtrlMode. If this is PSP_CTRL_MODE_DIGITAL, no data about the analog stick 
+ * will be present in the SceCtrlData struct read by SceCtrlReadBuffer.
+ *
+ * @return The previous mode.
+ */
+int sceCtrlSetSamplingMode(int mode);
+
+/**
+ * Get the current controller mode.
+ *
+ * @param pmode - Return value.
+ *
+ * @return 0.
+ */
+int sceCtrlGetSamplingMode(int *pmode);
+
+int sceCtrlPeekBufferPositive(SceCtrlData *pad_data, int count);
+
+int sceCtrlPeekBufferNegative(SceCtrlData *pad_data, int count);
+
+/**
+ * Read buffer positive
+ *
+ * @par Example:
+ * @code
+ * SceCtrlData pad;
+
+ * sceCtrlSetSamplingCycle(0);
+ * sceCtrlSetSamplingMode(1);
+ * sceCtrlReadBufferPositive(&pad, 1);
+ * // Do something with the read controller data
+ * @endcode
+ *
+ * @param pad_data - Pointer to a ::SceCtrlData structure used hold the returned pad data.
+ * @param count - Number of ::SceCtrlData buffers to read.
+ */
+int sceCtrlReadBufferPositive(SceCtrlData *pad_data, int count);
+
+int sceCtrlReadBufferNegative(SceCtrlData *pad_data, int count);
+
+/**
+ * @brief Get the latch data.
+ *
+ * This function reads the latch data collected by the controller service. At each sampling
+ * interval, the controller service compares the new pressed/released button states with the previously sampled pressed
+ * button states and stores that comparison as latch data.
+ *
+ * Compared to ::sceCtrlReadLatch(), calling this API will not result in clearing the internal latch data. As such,
+ * the data returned is the accumulated latch data since the last time ::sceCtrlReadLatch() was called. Consequently,
+ * the returned data should not be relied on whether a button is currently in a pressed or released state.
+ *
+ * @param latch_data Pointer to a ::SceCtrlLatch variable which is to receive the accumulated button latch data.
+ *
+ * @return On success, the number of times the controller service performed sampling since the last time
+ * ::sceCtrlReadLatch() was called.
+ * @return < 0 on error.
+ * 
+ * @see ::SceCtrlLatch
+ * @see ::sceCtrlReadLatch()
+ */
+int sceCtrlPeekLatch(SceCtrlLatch *latch_data);
+
+/**
+ * @brief Get the latch data. 
+ * 
+ * This function reads the most recent latch data collected by the controller service. At each sampling
+ * interval, the controller service compares the new pressed/released button states with the previously sampled pressed
+ * button states and stores that comparison as latch data.
+ * 
+ * Compared to ::sceCtrlPeekLatch(), calling this API will result in clearing the internal latch data. As such,
+ * calling code might have to explicitly wait for the controller service to update its collected latch data.
+ * 
+ * @param latch_data Pointer to a ::SceCtrlLatch variable which is to receive the current button latch data.
+ * 
+ * @return On success, the number of times the controller service performed sampling since the last time
+ * ::sceCtrlReadLatch() was called.
+ * @return < 0 on error.
+ * 
+ * @par Example:
+ * @code
+ * SceCtrlLatch latchData;
+ * 
+ * while (1) {
+ *     // Obtain latch data
+ *     sceCtrlReadLatch(&latchData);
+ * 
+ *     if (latchData.buttonMake & PSP_CTRL_CROSS)
+ *     {
+ *         // The Cross button has just been pressed (transition from 'released' state to 'pressed' state)
+ *     }
+ * 
+ *     if (latchData.buttonPress & PSP_CTRL_SQUARE)
+ *     {
+ *         // The Square button is currently in the 'pressed' state
+ *     }
+ * 
+ *    if (latchData.buttonBreak & PSP_CTRL_TRIANGLE)
+ *    {
+ *        // The Triangle button has just been released (transition from 'pressed' state to 'released' state)
+ *    }
+ * 
+ *    if (latchData.buttonRelease & PSP_CTRL_CIRCLE)
+ *    {
+ *        // The Circle button is currently in the 'released' state
+ *    }
+ * 
+ *    // As we clear the internal latch data with the ReadLatch() call, we can explicitly wait for the VBLANK interval
+ *    // to give the controller service the time it needs to collect new latch data again. This guarantees the next call
+ *    // to sceCtrlReadLatch() will return collected data again.
+ *    //
+ *    // Note: The sceCtrlReadBuffer*() APIs are implicitly waiting for a VBLANK interval if necessary.
+ *    sceDisplayWaitVBlank();
+ * }
+ * @endcode
+ * 
+ * @see ::SceCtrlLatch
+ * @see ::sceCtrlPeekLatch()
+ */
+int sceCtrlReadLatch(SceCtrlLatch *latch_data);
+
+/**
+ * Set analog threshold relating to the idle timer.
+ *
+ * @param idlereset - Movement needed by the analog to reset the idle timer.
+ * @param idleback - Movement needed by the analog to bring the PSP back from an idle state.
+ *
+ * Set to -1 for analog to not cancel idle timer.
+ * Set to 0 for idle timer to be cancelled even if the analog is not moved.
+ * Set between 1 - 128 to specify the movement on either axis needed by the analog to fire the event.
+ *
+ * @return < 0 on error.
+ */
+int sceCtrlSetIdleCancelThreshold(int idlereset, int idleback);
+
+/**
+ * Get the idle threshold values.
+ *
+ * @param idlerest - Movement needed by the analog to reset the idle timer.
+ * @param idleback - Movement needed by the analog to bring the PSP back from an idle state.
+ *
+ * @return < 0 on error.
+ */
+int sceCtrlGetIdleCancelThreshold(int *idlerest, int *idleback);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspctrl_kernel.h b/newlib/psp/include/pspctrl_kernel.h
new file mode 100644
index 0000000..074b78b
--- /dev/null
+++ b/newlib/psp/include/pspctrl_kernel.h
@@ -0,0 +1,69 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspctrl_kernel.h - Prototypes for the sceCtrl_driver library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef __CTRL_KERNEL_H__
+#define __CTRL_KERNEL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Set the controller button masks
+ *
+ * @param mask - The bits to setup
+ * @param type - The type of operation (0 clear, 1 set mask, 2 set button)
+ *
+ * @par Example:
+ * @code
+ * sceCtrl_driver_7CA723DC(0xFFFF, 1);  // Mask lower 16bits
+ * sceCtrl_driver_7CA723DC(0x10000, 2); // Always return HOME key
+ * // Do something
+ * sceCtrl_driver_7CA723DC(0x10000, 0); // Unset HOME key
+ * sceCtrl_driver_7CA723DC(0xFFFF, 0);  // Unset mask
+ * @endcode
+ */
+void sceCtrl_driver_7CA723DC(unsigned int mask, unsigned type);
+
+/**
+ * Get button mask mode
+ *
+ * @param mask - The bitmask to check
+ *
+ * @return 0 no setting, 1 set in button mask, 2 set in button set
+ */
+int sceCtrl_driver_5E77BC8A(unsigned int mask);
+
+/**
+ * Setup a controller callback
+ *
+ * @param no - The number of the callback (0-3)
+ * @param mask - The bits to check for
+ * @param cb - The callback function (int curr_but, int last_but, void *arg)
+ * @param arg - User defined argument passed
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceCtrl_driver_5C56C779(int no, unsigned int mask, void (*cb)(int, int, void*), void *arg);
+
+/* Just define some random names for the functions to make them easier to use */
+#define sceCtrlSetButtonMasks sceCtrl_driver_7CA723DC
+#define sceCtrlGetButtonMask sceCtrl_driver_5E77BC8A
+#define sceCtrlRegisterButtonCallback sceCtrl_driver_5C56C779
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspdebug.h b/newlib/psp/include/pspdebug.h
new file mode 100644
index 0000000..9a01191
--- /dev/null
+++ b/newlib/psp/include/pspdebug.h
@@ -0,0 +1,442 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  pspdebug.h - Prototypes for the pspDebug library
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <psptypes.h>
+#include <pspmoduleinfo.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup Debug Debug Utility Library */
+
+/** @addtogroup Debug */
+/**@{*/
+
+/** 
+  * Initialise the debug screen
+  */
+void pspDebugScreenInit(void);
+
+/**
+ * Extended debug screen init
+ *
+ * @param vram_base - Base address of frame buffer, if NULL then sets a default
+ * @param mode - Colour mode
+ * @param setup - Setup the screen if 1
+ */
+void pspDebugScreenInitEx(void *vram_base, int mode, int setup);
+
+/**
+  * Do a printf to the debug screen.
+  *
+  * @param fmt - Format string to print
+  * @param ... - Arguments
+  */
+void pspDebugScreenPrintf(const char *fmt, ...) __attribute__((format(printf,1,2)));
+
+/**
+  * Do a printf to the debug screen.
+  * @note This is for kernel mode only as it uses a kernel function
+  * to perform the printf instead of using vsnprintf, use normal printf for
+  * user mode.
+  *
+  * @param format - Format string to print
+  * @param ... - Arguments
+  */
+void pspDebugScreenKprintf(const char *format, ...) __attribute__((format(printf,1,2)));
+
+/**
+ * Enable or disable background colour writing (defaults to enabled)
+ * 
+ * @param enable - Set 1 to to enable background color, 0 for disable
+ */
+void pspDebugScreenEnableBackColor(int enable);
+
+/** 
+  * Set the background color for the text
+  * @note To reset the entire screens bg colour you need to call pspDebugScreenClear
+  *
+  * @param color - A 32bit RGB colour
+  */
+void pspDebugScreenSetBackColor(u32 color);
+
+/**
+  * Set the text color 
+  *
+  * @param color - A 32 bit RGB color
+  */
+void pspDebugScreenSetTextColor(u32 color);
+
+/**
+ * Set the color mode (you must have switched the frame buffer appropriately)
+ *
+ * @param mode - Color mode
+ */
+void pspDebugScreenSetColorMode(int mode);
+
+/** 
+  * Draw a single character to the screen.
+  *
+  * @param x - The x co-ordinate to draw to (pixel units)
+  * @param y - The y co-ordinate to draw to (pixel units)
+  * @param color - The text color to draw
+  * @param ch - The character to draw
+  */
+void pspDebugScreenPutChar(int x, int y, u32 color, u8 ch);
+
+/**
+  * Set the current X and Y co-ordinate for the screen (in character units)
+  */
+void pspDebugScreenSetXY(int x, int y);
+
+/**
+  * Set the video ram offset used for the screen
+  *
+  * @param offset - Offset in bytes
+  */
+void pspDebugScreenSetOffset(int offset);
+
+/**
+ * Set the video ram base used for the screen
+ *
+ * @param base - Base address in bytes
+ */
+void pspDebugScreenSetBase(u32* base);
+
+/** 
+  * Get the current X co-ordinate (in character units)
+  *
+  * @return The X co-ordinate
+  */
+int pspDebugScreenGetX(void);
+
+/** 
+  * Get the current Y co-ordinate (in character units)
+  *
+  * @return The Y co-ordinate
+  */
+int pspDebugScreenGetY(void);
+
+/**
+  * Clear the debug screen.
+  */
+void pspDebugScreenClear(void);
+
+/**
+  * Print non-nul terminated strings.
+  * 
+  * @param buff - Buffer containing the text.
+  * @param size - Size of the data
+  *
+  * @return The number of characters written
+  */
+int pspDebugScreenPrintData(const char *buff, int size);
+
+/**
+ * Print a string
+ *
+ * @param str - String
+ *
+ * @return The number of characters written
+ */
+int pspDebugScreenPuts(const char *str);
+
+/**
+  * Get a MIPS stack trace (might work :P)
+  *
+  * @param results - List of points to store the results of the trace, (up to max)
+  * @param max - Maximum number of back traces
+  *
+  * @return The number of frames stored in results.
+*/
+int pspDebugGetStackTrace(unsigned int* results, int max);
+
+/**
+ * Enable the clear line function that allows debug to clear the screen
+*/
+void pspDebugScreenClearLineEnable(void);
+
+/**
+ * Disable the clear line function that causes flicker on constant refreshes
+*/
+void pspDebugScreenClearLineDisable(void);
+
+/** Structure to hold the register data associated with an exception */
+typedef struct _PspDebugRegBlock
+{
+	u32 frame[6];
+	/** Array of the 32 GPRs */
+	u32 r[32];
+	/** The status register */
+	u32 status;
+	/** lo */
+	u32 lo;
+	u32 hi;
+	u32 badvaddr;
+	u32 cause;
+	u32 epc;
+	float fpr[32];
+	u32 fsr;
+	u32 fir;
+	u32 frame_ptr;
+	u32 unused;
+	/* Unused on PSP */
+	u32 index;
+	u32 random;
+	u32 entrylo0;
+	u32 entrylo1;
+	u32 context;
+	u32 pagemask;
+	u32 wired;
+	u32 cop0_7;
+	u32 cop0_8;
+	u32 cop0_9;
+	u32 entryhi;
+	u32 cop0_11;
+	u32 cop0_12;
+	u32 cop0_13;
+	u32 cop0_14;
+	/* PRId should still be okay */
+	u32 prid;
+	u32 padding[100];
+} PspDebugRegBlock;
+
+/** Defines a debug error handler */
+typedef void (*PspDebugErrorHandler)(PspDebugRegBlock *regs);
+
+/** 
+  * Install an error handler to catch unhandled exceptions.
+  * 
+  * @param handler - Pointer to a handler function. If set to NULL it will default
+  * to resetting the screen and dumping the error.
+  * @return < 0 on error
+  */
+int pspDebugInstallErrorHandler(PspDebugErrorHandler handler);
+
+/**
+  * Dump an exception to screen using the pspDebugScreen functions.
+  * @note This function will not setup the screen for debug output, you should call sceDebugScreenInit
+  * before using it if it isn't already.
+  *
+  * @param regs - Pointer to a register block.
+  *
+  */
+void pspDebugDumpException(PspDebugRegBlock *regs);
+
+/** Type for Kprintf handler */
+typedef int (*PspDebugKprintfHandler)(const char *format, u32 *args);
+
+/** 
+  * Install a Kprintf handler into the system.
+  *
+  * @param handler - Function pointer to the handler.
+  * @return < 0 on error.
+  */
+int pspDebugInstallKprintfHandler(PspDebugKprintfHandler handler);
+
+/** Structure to hold a single stack trace entry */
+typedef struct _PspDebugStackTrace
+{
+	/** The address which called the function */
+	u32 call_addr;
+	/** The address of the function called */
+	u32 func_addr;
+} PspDebugStackTrace;
+
+/**
+  * Do a stack trace from the current exception. 
+  * @note This function really isn't too general purpose and it is more than likely to generate a few 
+  * false positives but I consider that better then missing out calls entirely. You have to use your
+  * discretion, your code and a objdump to work out if some calls are completely surprious or not ;)
+  *
+  * @param regs - Pointer to a register block from an exception.
+  * @param trace - Pointer to an array of PspDebugStackTrace structures.
+  * @param max - The maximum number of traces to make.
+  *
+  * @return The number of functions found.
+  */
+int pspDebugGetStackTrace2(PspDebugRegBlock *regs, PspDebugStackTrace *trace, int max);
+
+/** Structure to hold the psp profiler register values */
+typedef struct _PspDebugProfilerRegs
+{
+	volatile u32 enable;
+	volatile u32 systemck;
+	volatile u32 cpuck;
+	volatile u32 internal;
+	volatile u32 memory;
+	volatile u32 copz;
+	volatile u32 vfpu;
+	volatile u32 sleep;
+	volatile u32 bus_access;
+	volatile u32 uncached_load;
+	volatile u32 uncached_store;
+	volatile u32 cached_load;
+	volatile u32 cached_store;
+	volatile u32 i_miss;
+	volatile u32 d_miss;
+	volatile u32 d_writeback;
+	volatile u32 cop0_inst;
+	volatile u32 fpu_inst;
+	volatile u32 vfpu_inst;
+	volatile u32 local_bus;
+} PspDebugProfilerRegs;
+
+/** Enables the profiler hardware */
+void pspDebugProfilerEnable(void);
+
+/** Disables the profiler hardware */
+void pspDebugProfilerDisable(void);
+
+/** Clear the profiler registers */
+void pspDebugProfilerClear(void);
+
+/** Get the profiler register state
+  *
+  * @param regs - A pointer to a PspDebugProfilerRegs structure.
+  */
+void pspDebugProfilerGetRegs(PspDebugProfilerRegs *regs);
+
+/** Print the profiler registers to screen */
+void pspDebugProfilerPrint(void);
+
+/** Type for the debug print handlers */
+typedef int (*PspDebugPrintHandler)(const char *data, int len);
+
+/** Type for the debug input handler */
+typedef int (*PspDebugInputHandler)(char *data, int len);
+
+/**
+  * Install a handler for stdin (so you can use normal stdio functions)
+  *
+  * @param handler - A pointer to input handler, NULL to disable.
+  *
+  * @return < 0 on error, else 0.
+  */
+int pspDebugInstallStdinHandler(PspDebugInputHandler handler);
+
+/**
+  * Install a print handler for stdout (so you can use normal print functions)
+  *
+  * @param handler - A pointer to print handler, NULL to disable.
+  *
+  * @return < 0 on error, else 0.
+  */
+int pspDebugInstallStdoutHandler(PspDebugPrintHandler handler);
+
+/**
+  * Install a print handler for stderr (so you can use normal print functions)
+  *
+  * @param handler - A pointer to print handler, NULL to disable.
+  *
+  * @return < 0 on error, else 0.
+  */
+int pspDebugInstallStderrHandler(PspDebugPrintHandler handler);
+
+/**
+ * Put a character to the remote sio.
+ *
+ * @param ch - Character to write.
+ */
+void pspDebugSioPutchar(int ch);
+
+/**
+ * Get a character from the remote sio
+ *
+ * @return The character read or -1 if no characters available.
+ */
+int pspDebugSioGetchar(void);
+
+/**
+ * Write a string to the sio port.
+ *
+ * @param str - String to write.
+ */
+void pspDebugSioPuts(const char *str);
+
+/**
+ * Write a set of data to the sio port
+ *
+ * @param data - Pointer to the data to send.
+ * @param len - Length of the data.
+ *
+ * @return Number of characters written.
+ */
+int pspDebugSioPutData(const char *data, int len);
+
+/**
+ * Write a set of data to the sio port converting single
+ * line feeds to CRLF and single CR to CRLF
+ *
+ * @param data - Pointer to the data to send.
+ * @param len - Length of the data.
+ *
+ * @return Number of characters written.
+ */
+int pspDebugSioPutText(const char *data, int len);
+
+/**
+ * Initialise the remote SIO port (defaults to 4800 8N1).
+ * @note will delay 2 seconds to wait for the power to come up.
+ */
+void pspDebugSioInit(void);
+
+/**
+ * Set the baud rate of the SIO, e.g. 4800/9600..115200.
+ * @param baud - The baudrate to set.
+ */
+void pspDebugSioSetBaud(int baud);
+
+/**
+ * Enable debug character output. Needs to be called in order
+ * for the default Kprintf handler to work.
+ */
+void pspDebugEnablePutchar(void);
+
+/**
+ * Install a kprintf debug putchar handler. Implicitly calls ::pspDebugEnablePutchar
+ * so you do not need to call it explicitly. Sio must be initialised before calling
+ * this function however.
+ */
+void pspDebugSioInstallKprintf(void);
+
+/**
+  * Install the gdb stub handler.
+  */
+void pspDebugGdbStubInit(void);
+
+/** 
+  * Generate a breakpoint exception.
+  */
+void pspDebugBreakpoint(void);
+
+/**
+ * Enable the kprintf handler (once installed)
+ */
+void pspDebugSioEnableKprintf(void);
+
+/**
+ * Disable the kprintf handler (once installed)
+ */
+void pspDebugSioDisableKprintf(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspdebugkb.h b/newlib/psp/include/pspdebugkb.h
new file mode 100644
index 0000000..c74bfd9
--- /dev/null
+++ b/newlib/psp/include/pspdebugkb.h
@@ -0,0 +1,95 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  pspdebugkb.h - Simple screen debug keyboard
+ *
+ * Copyright (c) 2006 Mike Mallett <mike@nerdcore.net>
+ *
+ */
+
+#ifndef __PSPDEBUGKB_H
+#define __PSPDEBUGKB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum PspDebugKbSettings {
+  /** Maximum string length */
+  PSP_DEBUG_KB_MAXLEN = 40,
+  /** Place the box' upper-left corner at this location */
+  PSP_DEBUG_KB_BOX_X = 6,
+  PSP_DEBUG_KB_BOX_Y = 8,
+  /** FG and BG colour of unhighlighted characters */
+  PSP_DEBUG_KB_CHAR_COLOUR = 0xffffffff,
+  PSP_DEBUG_KB_BACK_COLOUR = 0xff000000,
+  /** FG and BG colour of highlighted character */
+  PSP_DEBUG_KB_CHAR_HIGHLIGHT = 0xff00ff00,
+  PSP_DEBUG_KB_BACK_HIGHLIGHT = 0xff101010,
+  /** Indent the printed characters by (X_OFFSET,Y_OFFSET) */
+  PSP_DEBUG_KB_OFFSET_X = 6,
+  PSP_DEBUG_KB_OFFSET_Y = 4,
+  /** Distance from one character to the next */
+  PSP_DEBUG_KB_SPACING_X = 3,
+  PSP_DEBUG_KB_SPACING_Y = 2,
+  /** Number of columns/rows (respectively) in charTable(s) */
+  PSP_DEBUG_KB_NUM_CHARS = 13,
+  PSP_DEBUG_KB_NUM_ROWS = 4,
+  /** Box width and height */
+  PSP_DEBUG_KB_BOX_WIDTH = (PSP_DEBUG_KB_NUM_CHARS * PSP_DEBUG_KB_SPACING_X) + (2 * PSP_DEBUG_KB_OFFSET_X),
+  PSP_DEBUG_KB_BOX_HEIGHT = ((PSP_DEBUG_KB_NUM_ROWS + 1) * PSP_DEBUG_KB_SPACING_Y) + PSP_DEBUG_KB_OFFSET_Y,
+  /** Array index of commandRow */
+  PSP_DEBUG_KB_COMMAND_ROW = 4,
+  /** Number of commands on bottom row */
+  PSP_DEBUG_KB_NUM_COMMANDS = 5
+};
+
+/**
+ * Switch charTable when SHIFT is pressed
+ *
+ * @param shiftState - Pointer to an int indicating Caps Lock
+ */
+void pspDebugKbShift(int *shiftState);
+
+/**
+ * Draw the specified key on the keyboard.
+ *
+ * @param row - The row of the character to print (in charTable)
+ * @param col - The column of the character to print (in charTable)
+ * @param highlight - 0 for plain; otherwise highlighted
+ */
+void pspDebugKbDrawKey(int row, int col, int highlight);
+
+/**
+ * Draw the string at the top of the box
+ *
+ * @param str - The string to print
+ */
+void pspDebugKbDrawString(char *str);
+
+/**
+ * Clear the area where the box resides.
+ * Called from pspDebugKbDrawBox and pspDebugKbInit (on exit).
+ */
+void pspDebugKbClearBox();
+
+/**
+ * Draw the entire box on the desbug screen.
+ * Called from shift() and doInputBox(char*)
+ */
+void pspDebugKbDrawBox();
+
+/**
+ * Make the text box happen
+ *
+ * @param str - The string to edit
+ */
+void pspDebugKbInit(char *str);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspdisplay.h b/newlib/psp/include/pspdisplay.h
new file mode 100644
index 0000000..c72ca31
--- /dev/null
+++ b/newlib/psp/include/pspdisplay.h
@@ -0,0 +1,153 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspdisplay.h - Prototypes for the sceDisplay library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+#ifndef __DISPLAY_H__
+#define __DISPLAY_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Framebuffer pixel formats. */
+enum PspDisplayPixelFormats {
+	/** 16-bit RGB 5:6:5. */
+	PSP_DISPLAY_PIXEL_FORMAT_565 = 0,
+	/** 16-bit RGBA 5:5:5:1. */
+	PSP_DISPLAY_PIXEL_FORMAT_5551,
+	/* 16-bit RGBA 4:4:4:4. */
+	PSP_DISPLAY_PIXEL_FORMAT_4444,
+	/* 32-bit RGBA 8:8:8:8. */
+	PSP_DISPLAY_PIXEL_FORMAT_8888
+};
+
+enum PspDisplaySetBufSync {
+	/** Buffer change effective immediately */
+	PSP_DISPLAY_SETBUF_IMMEDIATE = 0,
+	/** Buffer change effective next frame */
+	PSP_DISPLAY_SETBUF_NEXTFRAME = 1
+};
+
+
+enum PspDisplayErrorCodes
+{
+   SCE_DISPLAY_ERROR_OK    = 0,
+   SCE_DISPLAY_ERROR_POINTER    = 0x80000103,
+   SCE_DISPLAY_ERROR_ARGUMENT   = 0x80000107
+};
+
+
+/**
+ * Set display mode
+ *
+ * @par Example1:
+ * @code
+ * @endcode
+ *
+ * @param mode - Display mode, normally 0.
+ * @param width - Width of screen in pixels.
+ * @param height - Height of screen in pixels.
+ *
+ * @return ???
+ */
+int sceDisplaySetMode(int mode, int width, int height);
+
+/**
+ * Get display mode
+ *
+ * @param pmode - Pointer to an integer to receive the current mode.
+ * @param pwidth - Pointer to an integer to receive the current width.
+ * @param pheight - Pointer to an integer to receive the current height,
+ *
+ * @return 0 on success
+ */
+int sceDisplayGetMode(int *pmode, int *pwidth, int *pheight);
+
+/**
+ * Display set framebuf
+ *
+ * @param topaddr - address of start of framebuffer
+ * @param bufferwidth - buffer width (must be power of 2)
+ * @param pixelformat - One of ::PspDisplayPixelFormats.
+ * @param sync - One of ::PspDisplaySetBufSync
+ *
+ * @return 0 on success
+ */
+int sceDisplaySetFrameBuf(void *topaddr, int bufferwidth, int pixelformat, int sync);
+
+/**
+ * Get Display Framebuffer information
+ *
+ * @param topaddr - pointer to void* to receive address of start of framebuffer
+ * @param bufferwidth - pointer to int to receive buffer width (must be power of 2)
+ * @param pixelformat - pointer to int to receive one of ::PspDisplayPixelFormats.
+ * @param sync - One of ::PspDisplaySetBufSync
+ *
+ * @return 0 on success
+ */
+int sceDisplayGetFrameBuf(void **topaddr, int *bufferwidth, int *pixelformat, int sync);
+
+/**
+ * Number of vertical blank pulses up to now
+ */
+unsigned int sceDisplayGetVcount(void);
+
+/**
+ * Wait for vertical blank start
+ */
+int sceDisplayWaitVblankStart(void);
+
+/**
+ * Wait for vertical blank start with callback
+ */
+int sceDisplayWaitVblankStartCB(void);
+
+/**
+ * Wait for vertical blank
+ */
+int sceDisplayWaitVblank(void);
+
+/**
+ * Wait for vertical blank with callback
+ */
+int sceDisplayWaitVblankCB(void);
+
+/**
+ * Get accumlated HSYNC count
+ */
+int sceDisplayGetAccumulatedHcount(void);
+
+/**
+ * Get current HSYNC count
+ */
+int sceDisplayGetCurrentHcount(void);
+
+/**
+ * Get number of frames per second
+ */
+float sceDisplayGetFramePerSec(void);
+
+/**
+ * Get whether or not frame buffer is being displayed
+ */
+int sceDisplayIsForeground(void);
+
+/**
+ * Test whether VBLANK is active
+ */
+int sceDisplayIsVblank(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspdisplay_kernel.h b/newlib/psp/include/pspdisplay_kernel.h
new file mode 100644
index 0000000..b63fccd
--- /dev/null
+++ b/newlib/psp/include/pspdisplay_kernel.h
@@ -0,0 +1,71 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspdisplay_kernel.h - Prototypes for the sceDisplay_driver library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+#ifndef __DISPLAYKERNEL_H__
+#define __DISPLAYKERNEL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Display set framebuf
+ *
+ * @param pri - Priority
+ * @param topaddr - address of start of framebuffer
+ * @param bufferwidth - buffer width (must be power of 2)
+ * @param pixelformat - One of ::PspDisplayPixelFormats.
+ * @param sync - One of ::PspDisplaySetBufSync
+ *
+ * @return 0 on success
+ */
+int sceDisplay_driver_63E22A26(int pri, void *topaddr, int bufferwidth, int pixelformat, int sync);
+
+/**
+ * Get Display Framebuffer information
+ *
+ * @param pri - Priority
+ * @param topaddr - pointer to void* to receive address of start of framebuffer
+ * @param bufferwidth - pointer to int to receive buffer width (must be power of 2)
+ * @param pixelformat - pointer to int to receive one of ::PspDisplayPixelFormats.
+ * @param sync - One of ::PspDisplaySetBufSync
+ *
+ * @return 0 on success
+ */
+int sceDisplay_driver_5B5AEFAD(int pri, void **topaddr, int *bufferwidth, int *pixelformat, int sync);
+
+/* Define some names to make it nicer */
+#define sceDisplaySetFrameBufferInternal sceDisplay_driver_63E22A26
+#define sceDisplayGetFrameBufferInternal sceDisplay_driver_5B5AEFAD
+
+/**
+ * Set Display brightness to a particular level
+ *
+ * @param level - Level of the brightness. it goes from 0 (black screen) to 100 (max brightness)
+ * @param unk1 - Unknown can be 0 or 1 (pass 0)
+ */
+void sceDisplaySetBrightness(int level,int unk1);
+
+/**
+ * Get current display brightness
+ *
+ * @param level - Pointer to int to receive the current brightness level (0-100)
+ * @param unk1 - Pointer to int, receives unknown, it's 1 or 0
+ */
+void sceDisplayGetBrightness(int *level,int *unk1);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspdmac.h b/newlib/psp/include/pspdmac.h
new file mode 100644
index 0000000..f538e38
--- /dev/null
+++ b/newlib/psp/include/pspdmac.h
@@ -0,0 +1,24 @@
+/*
+ * PSP Software Development Kit - http://www.pspdev.org
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * dmac.c - A DMAC function
+ *
+ * Copyright (c) 2016 173210 <root.3.173210@live.com>
+ */
+
+#include <psptypes.h>
+
+/**
+ * Copy data in memory using DMAC
+ *
+ * @param dst - The pointer to the destination
+ * @param src - The pointer to the source
+ * @param n - The size of data
+ *
+ * @return 0 on success; otherwise an error code
+ */
+int sceDmacMemcpy(void *dst, const void *src, SceSize n);
+
+int sceDmacTryMemcpy(void *dst, const void *src, SceSize n);
diff --git a/newlib/psp/include/pspexception.h b/newlib/psp/include/pspexception.h
new file mode 100644
index 0000000..3779717
--- /dev/null
+++ b/newlib/psp/include/pspexception.h
@@ -0,0 +1,56 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspexception.h - Interface to the kernel side of ExceptionMan
+ *
+ * Copyright (c) 2006 James F.
+ *
+ */
+
+#ifndef PSPEXCEPTION_H
+#define PSPEXCEPTION_H
+
+#include <pspkerneltypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Register a default exception handler.
+ *
+ * @param func - Pointer to the exception handler function
+ * @note The exception handler function must start with a NOP
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelRegisterDefaultExceptionHandler(void *func);
+
+/**
+ * Register a exception handler
+ * 
+ * @param exno - The exception number
+ * @param func - Pointer to the exception handler function
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelRegisterExceptionHandler(int exno, void *func);
+
+/**
+ * Register a exception handler with a priority
+ * 
+ * @param exno - The exception number
+ * @param priority - The priority of the exception
+ * @param func - Pointer to the exception handler function
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelRegisterPriorityExceptionHandler(int exno, int priority, void *func);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPEXCEPTION_H */
diff --git a/newlib/psp/include/pspfpu.h b/newlib/psp/include/pspfpu.h
new file mode 100644
index 0000000..f5f4399
--- /dev/null
+++ b/newlib/psp/include/pspfpu.h
@@ -0,0 +1,410 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspfpu.h - Prototypes for the FPU library
+ *
+ * Copyright (c) 2009 JetCube
+ * Copyright (c) 2006 TyRaNiD (James F.)
+ *
+ */
+#ifndef __PSPFPU_H__
+#define __PSPFPU_H__
+
+#include <stdint.h>
+
+/* Note the bit settings in here come from an NEC MIPSv4 document,
+ * they seem sensible.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Enumeration for FPU rounding modes */
+enum PspFpuRoundMode
+{
+	/** Round to nearest representable value */
+	PSP_FPU_RN = 0,
+	/** Round towards zero */
+	PSP_FPU_RZ = 1,
+	/** Round towards plus infinity */
+	PSP_FPU_RP = 2,
+	/** Round towards minus infinity */
+	PSP_FPU_RM = 3,
+};
+
+/** Mask value for rounding mode */
+#define PSP_FPU_RM_MASK 0x03
+
+/** Enumeration for FPU exceptions */
+enum PspFpuExceptions
+{
+	/** Inexact operation exception */
+	PSP_FPU_EXCEPTION_INEXACT   = 0x01,
+	/** Underflow exception */
+	PSP_FPU_EXCEPTION_UNDERFLOW = 0x02,
+	/** Overflow exception */
+	PSP_FPU_EXCEPTION_OVERFLOW  = 0x04,
+	/** Division by zero exception */
+	PSP_FPU_EXCEPTION_DIVBYZERO = 0x08,
+	/** Invalid operation exception */
+	PSP_FPU_EXCEPTION_INVALIDOP = 0x10,
+	/** Unimplemented operation exception (only supported in the cause bits) */
+	PSP_FPU_EXCEPTION_UNIMPOP   = 0x20,
+	/** All exceptions */
+	PSP_FPU_EXCEPTION_ALL       = 0x3F
+};
+
+/** Bit position of the flag bits */
+#define PSP_FPU_FLAGS_POS   2
+/** Bit position of the enable bits */
+#define PSP_FPU_ENABLE_POS 7
+/** Bit position of the cause bits */
+#define PSP_FPU_CAUSE_POS  12
+/** Bit position of the cc0 bit */
+#define PSP_FPU_CC0_POS    23
+/** Bit position of the fs bit */
+#define PSP_FPU_FS_POS     24
+/** Bit position of the cc1->7 bits */
+#define PSP_FPU_CC17_POS   25
+
+#define PSP_FPU_FLAGS_MASK  (0x1F << PSP_FPU_FLAGS_POS)
+#define PSP_FPU_ENABLE_MASK (0x1F << PSP_FPU_ENABLE_POS)
+#define PSP_FPU_CAUSE_MASK  (0x3F << PSP_FPU_CAUSE_POS)
+#define PSP_FPU_CC0_MASK    (1 << PSP_FPU_CC0_POS)
+#define PSP_FPU_FS_MASK     (1 << PSP_FPU_FS_POS)
+#define PSP_FPU_CC17_MASK   (0x7F << PSP_FPU_CC17_POS)
+
+/**
+ * Get the current value of the control/status register
+ *
+ * @return The value of the control/status register
+ */
+uint32_t pspFpuGetFCR31(void);
+
+/**
+ * Set the current value of the control/status register
+ *
+ * @param var - The value to set.
+ */
+void pspFpuSetFCR31(uint32_t var);
+
+/**
+ * Set the current round mode
+ *
+ * @param mode - The rounding mode to set, one of ::PspFpuRoundMode
+ */
+void pspFpuSetRoundmode(enum PspFpuRoundMode mode);
+
+/**
+ * Get the current round mode
+ *
+ * @return The round mode, one of ::PspFpuRoundMode
+ */
+enum PspFpuRoundMode pspFpuGetRoundmode(void);
+
+/**
+ * Get the exception flags (set when an exception occurs but
+ * the actual exception bit is not enabled)
+ *
+ * @return Bitmask of the flags, zero or more of ::PspFpuExceptions
+ */
+uint32_t pspFpuGetFlags(void);
+
+/**
+ * Clear the flags bits
+ *
+ * @param clear - Bitmask of the bits to clear, one or more of ::PspFpuExceptions
+ */
+void pspFpuClearFlags(uint32_t clear);
+
+/**
+ * Get the exception enable flags
+ *
+ * @return Bitmask of the flags, zero or more of ::PspFpuExceptions
+ */
+uint32_t pspFpuGetEnable(void);
+
+/**
+ * Set the enable flags bits
+ *
+ * @param enable - Bitmask of exceptions to enable, zero or more of ::PspFpuExceptions
+ */
+void pspFpuSetEnable(uint32_t enable);
+
+/**
+ * Get the cause bits (only useful if you installed your own exception handler)
+ *
+ * @return Bitmask of flags, zero or more of ::PspFpuExceptions
+ */
+uint32_t pspFpuGetCause(void);
+
+/**
+ * Clear the cause bits
+ *
+ * @param clear - Bitmask of the bits to clear, one or more of ::PspFpuExceptions
+ *
+ */
+void pspFpuClearCause(uint32_t clear);
+
+/**
+ * Get the current value of the FS bit (if FS is 0 then an exception occurs with
+ * denormalized values, if 1 then they are rewritten as 0.
+ *
+ * @return The current state of the FS bit (0 or 1)
+ */
+uint32_t pspFpuGetFS(void);
+
+/**
+ * Set the FS bit
+ *
+ * @param fs - 0 or 1 to unset or set fs
+ */
+void pspFpuSetFS(uint32_t fs);
+
+/**
+ * Get the condition flags (8 bits)
+ *
+ * @return The current condition flags
+ */
+uint32_t pspFpuGetCondbits(void);
+
+/**
+ * Clear the condition bits
+ *
+ * @param clear - Bitmask of the bits to clear
+ */
+void pspFpuClearCondbits(uint32_t clear);
+
+/**
+ * returns absolute value
+ */
+float pspFpuAbs(float f);
+
+/**
+ * Round up
+ */
+int   pspFpuCeil(float f);
+
+/**
+ * Truncate
+ */
+int   pspFpuFloor(float f);
+
+/**
+ * select maximum value
+ */
+float pspFpuMax(float f1, float f2);
+
+/**
+ * select minimum value
+ */
+float pspFpuMin(float f1, float f2);
+
+/**
+ * Sign reversal
+ */
+float pspFpuNeg(float f);
+
+/**
+ * Round to nearest
+ */
+int pspFpuRound(float f);
+
+/*
+ * Reciprocal of square root
+ */
+float pspFpuRsqrt(float f);
+
+/**
+ * Square root
+ */
+float pspFpuSqrt(float f);
+
+/**
+ * Round towards zero
+ */
+int pspFpuTrunc(float f);
+
+/**
+ *
+ */
+float pspFpuFmod(float fs, float fd);
+
+/**
+ *
+ */
+float pspFpuFrac(float f);
+
+/**
+ *
+ */
+float pspFpuReinterpretFloat(uint32_t ui);
+
+/**
+ *
+ */
+uint32_t pspFpuReinterpretUint(float f);
+
+/**
+ *
+ */
+int pspFpuIsEqual(float f1, float f2);
+
+/**
+ *
+ */
+float pspFpuSignFloat(float f);
+
+/**
+ *
+ */
+int pspFpuSignInt(float f);
+
+/**
+ * Positive zero
+ */
+float pspFpuPositiveZero(void);
+
+/**
+ * Negative zero
+ */
+float pspFpuNegativeZero(void);
+
+/**
+ * Test for zero value
+ */
+int pspFpuIsZero(float f);
+
+/**
+ * Test for positive zero
+ */
+int pspFpuIsPositiveZero(float f);
+
+/**
+ * Test for negative zero
+ */
+int pspFpuIsNegativeZero(float f);
+
+/**
+ * Test for denormalized number
+ */
+int pspFpuIsDenormal(float f);
+
+/**
+ * Test for zero or denormalized number
+ */
+int pspFpuIsZeroOrDenormal(float f);
+
+/**
+ * Positive infinity
+ */
+float pspFpuPositiveInf(void);
+
+/**
+ * Negative infinity
+ */
+float pspFpuNegativeInf(void);
+
+/**
+ * Test for infinity
+ */
+int pspFpuIsInf(float f);
+
+/**
+ * NaN (positive SNaN)
+ */
+float pspFpuPositiveNaN(void);
+
+/**
+ * NaN (negative SNaN)
+ */
+float pspFpuNegativeNaN(void);
+
+/**
+ * Quiet NaN (positive QNaN)
+ */
+float pspFpuPositiveQNaN(void);
+
+/**
+ * Quiet NaN (positive QNaN)
+ */
+float pspFpuNegativeQNaN(void);
+
+/**
+ * Signaling NaN (positive SNaN)
+ */
+float pspFpuPositiveSNaN(unsigned int uiSignal);
+
+/**
+ * Signaling NaN (negative SNaN)
+ */
+float pspFpuNegativeSNaN(unsigned int uiSignal);
+
+/**
+ * Test for NaN
+ */
+int pspFpuIsNaN(float f);
+
+/**
+ * Test for infinity or NaN
+ */
+int pspFpuIsInfOrNaN(float f);
+
+/**
+ *
+ */
+float pspFpuNormalizePhase(float f);
+
+/**
+ * Sine
+ */
+float pspFpuSin(float x);
+
+/**
+ * Cosine
+ */
+float pspFpuCos(float x);
+
+/**
+ * Arc tangent
+ */
+float pspFpuAtan(float x);
+
+/**
+ * Natural Logarithm
+ */
+float pspFpuLog(float x);
+
+/**
+ * Exponential
+ */
+float pspFpuExp(float x);
+
+/**
+ * ArcSin
+ */
+float pspFpuAsin(float x);
+
+/**
+ * ArcCos
+ */
+float pspFpuAcos(float x);
+
+/**
+ * convert float to double
+ */
+double pspFpuFloatToDouble(float a);
+
+/**
+ * convert double to float
+ */
+float  pspFpuDoubleToFloat(double a);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __PSPFPU_H__ */
diff --git a/newlib/psp/include/pspge.h b/newlib/psp/include/pspge.h
new file mode 100644
index 0000000..2640171
--- /dev/null
+++ b/newlib/psp/include/pspge.h
@@ -0,0 +1,279 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspge.h - Prototypes for the sceGe library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __GE_H__
+#define __GE_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Stores the state of the GE. */
+typedef struct PspGeContext {
+	unsigned int context[512];
+} PspGeContext;
+
+/** Structure storing a stack (for CALL/RET) */
+typedef struct
+{
+	/** The stack buffer */
+	unsigned int stack[8];
+} SceGeStack;
+
+/** Typedef for a GE callback */
+typedef void (*PspGeCallback)(int id, void *arg);
+
+/** Structure to hold the callback data */
+typedef struct PspGeCallbackData
+{
+	/** GE callback for the signal interrupt */
+	PspGeCallback signal_func;
+	/** GE callback argument for signal interrupt */
+	void *signal_arg;
+	/** GE callback for the finish interrupt */
+	PspGeCallback finish_func;
+	/** GE callback argument for finish interrupt */
+	void *finish_arg;
+} PspGeCallbackData;
+
+typedef struct PspGeListArgs
+{
+	/** Size of the structure (16) */
+	unsigned int	size;
+	/** Pointer to a context */
+	PspGeContext*	context;
+	/** Number of stacks to use */
+	u32 numStacks;
+	/** Pointer to the stacks (unused) */
+	SceGeStack *stacks;
+} PspGeListArgs;
+
+/**
+ * Drawing queue interruption parameter
+ */
+typedef struct PspGeBreakParam {
+	unsigned int	buf[4];
+} PspGeBreakParam;
+
+/**
+ * Get the size of VRAM.
+ *
+ * @return The size of VRAM (in bytes).
+ */
+unsigned int sceGeEdramGetSize(void);
+
+/**
+  * Get the eDRAM address.
+  *
+  * @return A pointer to the base of the eDRAM.
+  */
+void * sceGeEdramGetAddr(void);
+
+/**
+ * Retrieve the current value of a GE command.
+ *
+ * @param cmd - The GE command register to retrieve (0 to 0xFF, both included).
+ *
+ * @return The value of the GE command, < 0 on error.
+ */
+unsigned int sceGeGetCmd(int cmd);
+
+/** GE matrix types. */
+typedef enum PspGeMatrixTypes {
+	/** Bone matrices. */
+	PSP_GE_MATRIX_BONE0 = 0,
+	PSP_GE_MATRIX_BONE1,
+	PSP_GE_MATRIX_BONE2,
+	PSP_GE_MATRIX_BONE3,
+	PSP_GE_MATRIX_BONE4,
+	PSP_GE_MATRIX_BONE5,
+	PSP_GE_MATRIX_BONE6,
+	PSP_GE_MATRIX_BONE7,
+	/** World matrix. */
+	PSP_GE_MATRIX_WORLD,
+	/** View matrix. */
+	PSP_GE_MATRIX_VIEW,
+	/** Projection matrix. */
+	PSP_GE_MATRIX_PROJECTION,
+	PSP_GE_MATRIX_TEXGEN
+} PspGeMatrixTypes;
+
+/**
+ * Retrieve a matrix of the given type.
+ *
+ * @param type - One of ::PspGeMatrixTypes.
+ * @param matrix - Pointer to a variable to store the matrix.
+ *
+ * @return < 0 on error.
+ */
+int sceGeGetMtx(int type, void *matrix);
+
+/** Structure storing a stack (for CALL/RET). */
+typedef struct
+{
+    /** The stack buffer. */
+    unsigned int stack[8];
+} PspGeStack;
+
+/**
+ * Retrieve the stack of the display list currently being executed.
+ *
+ * @param stackId - The ID of the stack to retrieve.
+ * @param stack - Pointer to a structure to store the stack, or NULL to not store it.
+ *
+ * @return The number of stacks of the current display list, < 0 on error.
+ */
+int sceGeGetStack(int stackId, PspGeStack *stack);
+
+/**
+ * Save the GE's current state.
+ *
+ * @param context - Pointer to a ::PspGeContext.
+ *
+ * @return < 0 on error.
+ */
+int sceGeSaveContext(PspGeContext *context);
+
+/**
+ * Restore a previously saved GE context.
+ *
+ * @param context - Pointer to a ::PspGeContext.
+ *
+ * @return < 0 on error.
+ */
+int sceGeRestoreContext(const PspGeContext *context);
+
+/**
+  * Enqueue a display list at the tail of the GE display list queue.
+  *
+  * @param list - The head of the list to queue.
+  * @param stall - The stall address.
+  * If NULL then no stall address is set and the list is transferred immediately.
+  * @param cbid - ID of the callback set by calling sceGeSetCallback
+  * @param arg - Structure containing GE context buffer address
+  *
+  * @return The ID of the queue, < 0 on error.
+  */
+int sceGeListEnQueue(const void *list, void *stall, int cbid, PspGeListArgs *arg);
+
+/**
+  * Enqueue a display list at the head of the GE display list queue.
+  *
+  * @param list - The head of the list to queue.
+  * @param stall - The stall address.
+  * If NULL then no stall address is set and the list is transferred immediately.
+  * @param cbid - ID of the callback set by calling sceGeSetCallback
+  * @param arg - Structure containing GE context buffer address
+  *
+  * @return The ID of the queue, < 0 on error.
+  */
+int sceGeListEnQueueHead(const void *list, void *stall, int cbid, PspGeListArgs *arg);
+
+/**
+ * Cancel a queued or running list.
+ *
+ * @param qid - The ID of the queue.
+ *
+ * @return < 0 on error.
+ */
+int sceGeListDeQueue(int qid);
+
+/**
+  * Update the stall address for the specified queue.
+  *
+  * @param qid - The ID of the queue.
+  * @param stall - The new stall address.
+  *
+  * @return < 0 on error
+  */
+int sceGeListUpdateStallAddr(int qid, void *stall);
+
+
+/** List status for ::sceGeListSync() and ::sceGeDrawSync(). */
+typedef enum PspGeListState {
+	PSP_GE_LIST_DONE = 0,
+	PSP_GE_LIST_QUEUED,
+	PSP_GE_LIST_DRAWING_DONE,
+	PSP_GE_LIST_STALL_REACHED,
+	PSP_GE_LIST_CANCEL_DONE
+} PspGeListState;
+
+/**
+  * Wait for syncronisation of a list.
+  *
+  * @param qid - The queue ID of the list to sync.
+  * @param syncType - 0 if you want to wait for the list to be completed, or 1 if you just want to peek the actual state.
+  *
+  * @return The specified queue status, one of ::PspGeListState.
+  */
+int sceGeListSync(int qid, int syncType);
+
+/**
+  * Wait for drawing to complete.
+  *
+  * @param syncType - 0 if you want to wait for the drawing to be completed, or 1 if you just want to peek the state of the display list currently being executed.
+  *
+  * @return The current queue status, one of ::PspGeListState.
+  */
+int sceGeDrawSync(int syncType);
+
+/**
+  * Register callback handlers for the the GE.
+  *
+  * @param cb - Configured callback data structure.
+  *
+  * @return The callback ID, < 0 on error.
+  */
+int sceGeSetCallback(PspGeCallbackData *cb);
+
+/**
+  * Unregister the callback handlers.
+  *
+  * @param cbid - The ID of the callbacks, returned by sceGeSetCallback().
+  *
+  * @return < 0 on error
+  */
+int sceGeUnsetCallback(int cbid);
+
+/**
+ * Interrupt drawing queue.
+ *
+ * @param mode - If set to 1, reset all the queues.
+ * @param pParam - Unused (just K1-checked).
+ *
+ * @return The stopped queue ID if mode isn't set to 0, otherwise 0, and < 0 on error.
+ */
+int sceGeBreak(int mode, PspGeBreakParam *pParam);
+
+/**
+ * Restart drawing queue.
+ *
+ * @return < 0 on error.
+ */
+int sceGeContinue(void);
+
+/**
+ * Set the eDRAM address translation mode.
+ *
+ * @param width - 0 to not set the translation width, otherwise 512, 1024, 2048 or 4096.
+ *
+ * @return The previous width if it was set, otherwise 0, < 0 on error.
+ */
+int sceGeEdramSetAddrTranslation(int width);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GE_H__ */
diff --git a/newlib/psp/include/pspgu.h b/newlib/psp/include/pspgu.h
new file mode 100644
index 0000000..22bf120
--- /dev/null
+++ b/newlib/psp/include/pspgu.h
@@ -0,0 +1,1487 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * Copyright (c) 2005 Jesper Svennevid
+ */
+      
+#ifndef __pspgu_h__
+#define __pspgu_h__
+
+#include <psptypes.h>
+#include <pspge.h>
+
+/** @defgroup GU Graphics Utility Library
+ *
+ */
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* PI, float-sized */
+#define GU_PI			(3.141593f)
+
+/* Boolean values for convenience */
+#define GU_FALSE		(0)
+#define GU_TRUE			(1)
+
+/* Primitive types */
+#define GU_POINTS		(0)
+#define GU_LINES		(1)
+#define GU_LINE_STRIP		(2)
+#define GU_TRIANGLES		(3)
+#define GU_TRIANGLE_STRIP	(4)
+#define GU_TRIANGLE_FAN		(5)
+#define GU_SPRITES		(6)
+
+/* States */
+#define GU_ALPHA_TEST		(0)
+#define GU_DEPTH_TEST		(1)
+#define GU_SCISSOR_TEST		(2)
+#define GU_STENCIL_TEST		(3)
+#define GU_BLEND		(4)
+#define GU_CULL_FACE		(5)
+#define GU_DITHER		(6)
+#define GU_FOG			(7)
+#define GU_CLIP_PLANES		(8)
+#define GU_TEXTURE_2D		(9)
+#define GU_LIGHTING		(10)
+#define GU_LIGHT0		(11)
+#define GU_LIGHT1		(12)
+#define GU_LIGHT2		(13)
+#define GU_LIGHT3		(14)
+#define GU_LINE_SMOOTH		(15)
+#define GU_PATCH_CULL_FACE	(16)
+#define GU_COLOR_TEST		(17)
+#define GU_COLOR_LOGIC_OP	(18)
+#define GU_FACE_NORMAL_REVERSE	(19)
+#define GU_PATCH_FACE		(20)
+#define GU_FRAGMENT_2X		(21)
+
+/* Matrix modes */
+#define GU_PROJECTION		(0)
+#define GU_VIEW			(1)
+#define GU_MODEL		(2)
+#define GU_TEXTURE		(3)
+
+/* Vertex Declarations Begin */
+#define GU_TEXTURE_SHIFT(n)	((n)<<0)
+#define GU_TEXTURE_8BIT		GU_TEXTURE_SHIFT(1)
+#define GU_TEXTURE_16BIT	GU_TEXTURE_SHIFT(2)
+#define GU_TEXTURE_32BITF	GU_TEXTURE_SHIFT(3)
+#define GU_TEXTURE_BITS		GU_TEXTURE_SHIFT(3)
+
+#define GU_COLOR_SHIFT(n)	((n)<<2)
+#define GU_COLOR_5650		GU_COLOR_SHIFT(4)
+#define GU_COLOR_5551		GU_COLOR_SHIFT(5)
+#define GU_COLOR_4444		GU_COLOR_SHIFT(6)
+#define GU_COLOR_8888		GU_COLOR_SHIFT(7)
+#define GU_COLOR_BITS		GU_COLOR_SHIFT(7)
+
+#define GU_NORMAL_SHIFT(n)	((n)<<5)
+#define GU_NORMAL_8BIT		GU_NORMAL_SHIFT(1)
+#define GU_NORMAL_16BIT		GU_NORMAL_SHIFT(2)
+#define GU_NORMAL_32BITF	GU_NORMAL_SHIFT(3)
+#define GU_NORMAL_BITS		GU_NORMAL_SHIFT(3)
+
+#define GU_VERTEX_SHIFT(n)	((n)<<7)
+#define GU_VERTEX_8BIT		GU_VERTEX_SHIFT(1)
+#define GU_VERTEX_16BIT		GU_VERTEX_SHIFT(2)
+#define GU_VERTEX_32BITF	GU_VERTEX_SHIFT(3)
+#define GU_VERTEX_BITS		GU_VERTEX_SHIFT(3)
+
+#define GU_WEIGHT_SHIFT(n)	((n)<<9)
+#define GU_WEIGHT_8BIT		GU_WEIGHT_SHIFT(1)
+#define GU_WEIGHT_16BIT		GU_WEIGHT_SHIFT(2)
+#define GU_WEIGHT_32BITF	GU_WEIGHT_SHIFT(3)
+#define GU_WEIGHT_BITS		GU_WEIGHT_SHIFT(3)
+
+#define GU_INDEX_SHIFT(n)	((n)<<11)
+#define GU_INDEX_8BIT		GU_INDEX_SHIFT(1)
+#define GU_INDEX_16BIT		GU_INDEX_SHIFT(2)
+#define GU_INDEX_BITS		GU_INDEX_SHIFT(3)
+
+#define GU_WEIGHTS(n)		((((n)-1)&7)<<14)
+#define GU_WEIGHTS_BITS		GU_WEIGHTS(8)
+#define GU_VERTICES(n)		((((n)-1)&7)<<18)
+#define GU_VERTICES_BITS	GU_VERTICES(8)
+
+#define GU_TRANSFORM_SHIFT(n)	((n)<<23)
+#define GU_TRANSFORM_3D		GU_TRANSFORM_SHIFT(0)
+#define GU_TRANSFORM_2D		GU_TRANSFORM_SHIFT(1)
+#define GU_TRANSFORM_BITS	GU_TRANSFORM_SHIFT(1)
+/* Vertex Declarations End */
+
+/* Pixel Formats */
+#define GU_PSM_5650		(0) /* Display, Texture, Palette */
+#define GU_PSM_5551		(1) /* Display, Texture, Palette */
+#define GU_PSM_4444		(2) /* Display, Texture, Palette */
+#define GU_PSM_8888		(3) /* Display, Texture, Palette */
+#define GU_PSM_T4		(4) /* Texture */
+#define GU_PSM_T8		(5) /* Texture */
+#define GU_PSM_T16		(6) /* Texture */
+#define GU_PSM_T32		(7) /* Texture */
+#define GU_PSM_DXT1		(8) /* Texture */
+#define GU_PSM_DXT3		(9) /* Texture */
+#define GU_PSM_DXT5		(10) /* Texture */
+
+/* Spline Mode */
+#define GU_FILL_FILL	(0)
+#define GU_OPEN_FILL	(1)
+#define GU_FILL_OPEN	(2)
+#define GU_OPEN_OPEN	(3)
+
+/* Shading Model */
+#define GU_FLAT			(0)
+#define GU_SMOOTH		(1)
+
+/* Logical operation */
+#define GU_CLEAR		(0)
+#define GU_AND			(1)
+#define GU_AND_REVERSE		(2)
+#define GU_COPY			(3)
+#define GU_AND_INVERTED		(4)
+#define GU_NOOP			(5)
+#define GU_XOR			(6)
+#define GU_OR			(7)
+#define GU_NOR			(8)
+#define GU_EQUIV		(9)
+#define GU_INVERTED		(10)
+#define GU_OR_REVERSE		(11)
+#define GU_COPY_INVERTED	(12)
+#define GU_OR_INVERTED		(13)
+#define GU_NAND			(14)
+#define GU_SET			(15)
+
+/* Texture Filter */
+#define GU_NEAREST		(0)
+#define GU_LINEAR		(1)
+#define GU_NEAREST_MIPMAP_NEAREST (4)
+#define GU_LINEAR_MIPMAP_NEAREST (5)
+#define GU_NEAREST_MIPMAP_LINEAR (6)
+#define GU_LINEAR_MIPMAP_LINEAR	(7)
+
+/* Texture Map Mode */
+#define GU_TEXTURE_COORDS	(0)
+#define GU_TEXTURE_MATRIX	(1)
+#define GU_ENVIRONMENT_MAP	(2)
+
+/* Texture Level Mode */
+#define GU_TEXTURE_AUTO		(0)
+#define GU_TEXTURE_CONST	(1)
+#define GU_TEXTURE_SLOPE	(2)
+
+/* Texture Projection Map Mode */
+#define GU_POSITION		(0)
+#define GU_UV			(1)
+#define GU_NORMALIZED_NORMAL	(2)
+#define GU_NORMAL		(3)
+
+/* Wrap Mode */
+#define GU_REPEAT		(0)
+#define GU_CLAMP		(1)
+
+/* Front Face Direction */
+#define GU_CW			(0)
+#define GU_CCW			(1)
+
+/* Test Function */
+#define GU_NEVER		(0)
+#define GU_ALWAYS		(1)
+#define GU_EQUAL		(2)
+#define GU_NOTEQUAL		(3)
+#define GU_LESS			(4)
+#define GU_LEQUAL		(5)
+#define GU_GREATER		(6)
+#define GU_GEQUAL		(7)
+
+/* Clear Buffer Mask */
+#define GU_COLOR_BUFFER_BIT	(1)
+#define GU_STENCIL_BUFFER_BIT	(2)
+#define GU_DEPTH_BUFFER_BIT	(4)
+#define GU_FAST_CLEAR_BIT	(16)
+
+/* Texture Effect */
+#define GU_TFX_MODULATE		(0)
+#define GU_TFX_DECAL		(1)
+#define GU_TFX_BLEND		(2)
+#define GU_TFX_REPLACE		(3)
+#define GU_TFX_ADD		(4)
+
+/* Texture Color Component */
+#define GU_TCC_RGB		(0)
+#define GU_TCC_RGBA		(1)
+
+/* Blending Op */
+#define GU_ADD			(0)
+#define GU_SUBTRACT		(1)
+#define GU_REVERSE_SUBTRACT	(2)
+#define GU_MIN			(3)
+#define GU_MAX			(4)
+#define GU_ABS			(5)
+
+/* Blending Factor */
+#define GU_SRC_COLOR		(0)
+#define GU_ONE_MINUS_SRC_COLOR	(1)
+#define GU_SRC_ALPHA		(2)
+#define GU_ONE_MINUS_SRC_ALPHA	(3)
+#define GU_DST_COLOR		(0)
+#define GU_ONE_MINUS_DST_COLOR	(1)
+#define GU_DST_ALPHA		(4)
+#define GU_ONE_MINUS_DST_ALPHA	(5)
+#define GU_FIX			(10)
+
+/* Stencil Operations */
+#define GU_KEEP			(0)
+#define GU_ZERO			(1)
+#define GU_REPLACE		(2)
+#define GU_INVERT		(3)
+#define GU_INCR			(4)
+#define GU_DECR			(5)
+
+/* Light Components */
+#define GU_AMBIENT		(1)
+#define GU_DIFFUSE		(2)
+#define GU_SPECULAR		(4)
+#define GU_AMBIENT_AND_DIFFUSE	(GU_AMBIENT|GU_DIFFUSE)
+#define GU_DIFFUSE_AND_SPECULAR	(GU_DIFFUSE|GU_SPECULAR)
+#define GU_UNKNOWN_LIGHT_COMPONENT (8)
+
+/* Light modes */
+#define GU_SINGLE_COLOR		(0)
+#define GU_SEPARATE_SPECULAR_COLOR (1)
+
+/* Light Type */
+#define GU_DIRECTIONAL		(0)
+#define GU_POINTLIGHT		(1)
+#define GU_SPOTLIGHT		(2)
+
+/* Contexts */
+#define GU_DIRECT		(0)
+#define GU_CALL			(1)
+#define GU_SEND			(2)
+
+/* List Queue */
+#define GU_TAIL			(0)
+#define GU_HEAD			(1)
+
+/* Sync behavior (mode) */
+#define GU_SYNC_FINISH	(0)
+#define GU_SYNC_SIGNAL	(1)
+#define GU_SYNC_DONE	(2)
+#define GU_SYNC_LIST	(3)
+#define GU_SYNC_SEND	(4)
+
+/* behavior (what) */
+#define GU_SYNC_WAIT	(0)
+#define GU_SYNC_NOWAIT	(1)
+
+/* Sync behavior (what) [see pspge.h] */
+#define GU_SYNC_WHAT_DONE (0)
+#define GU_SYNC_WHAT_QUEUED (1)
+#define GU_SYNC_WHAT_DRAW (2)
+#define GU_SYNC_WHAT_STALL (3)
+#define GU_SYNC_WHAT_CANCEL (4)
+
+/* Signals */
+#define GU_CALLBACK_SIGNAL	(1)
+#define GU_CALLBACK_FINISH	(4)
+
+/* Signal behavior */
+#define GU_BEHAVIOR_SUSPEND (1)
+#define GU_BEHAVIOR_CONTINUE (2)
+
+/* Color Macros, maps 8 bit unsigned channels into one 32-bit value */
+#define GU_ABGR(a,b,g,r)	(((a) << 24)|((b) << 16)|((g) << 8)|(r))
+#define GU_ARGB(a,r,g,b)	GU_ABGR((a),(b),(g),(r))
+#define GU_RGBA(r,g,b,a)	GU_ARGB((a),(r),(g),(b))
+
+/* Color Macro, maps floating point channels (0..1) into one 32-bit value */
+#define GU_COLOR(r,g,b,a)	GU_RGBA((u32)((r) * 255.0f),(u32)((g) * 255.0f),(u32)((b) * 255.0f),(u32)((a) * 255.0f))
+
+typedef void (*GuSwapBuffersCallback)(void** display,void** render);
+
+/** @addtogroup GU */
+/**@{*/
+
+/**
+  * Set depth buffer parameters
+  *
+  * @param zbp - VRAM pointer where the depthbuffer should start
+  * @param zbw - The width of the depth-buffer (block-aligned)
+  *
+**/
+void sceGuDepthBuffer(void* zbp, int zbw);
+
+/**
+  * Set display buffer parameters
+  *
+  * @par Example: Setup a standard 16-bit display buffer
+  * @code
+  * sceGuDispBuffer(480,272,(void*)512*272*2,512); // 480*272, skipping the draw buffer located at address 0
+  * @endcode
+  *
+  * @param width - Width of the display buffer in pixels
+  * @param height - Width of the display buffer in pixels
+  * @param dispbp - VRAM pointer to where the display-buffer starts
+  * @param dispbw - Display buffer width (block aligned)
+  *
+**/
+void sceGuDispBuffer(int width, int height, void* dispbp, int dispbw);
+
+/**
+  * Set draw buffer parameters (and store in context for buffer-swap)
+  *
+  * Available pixel formats are:
+  *   - GU_PSM_5650
+  *   - GU_PSM_5551
+  *   - GU_PSM_4444
+  *   - GU_PSM_8888
+  *
+  * @par Example: Setup a standard 16-bit draw buffer
+  * @code
+  * sceGuDrawBuffer(GU_PSM_5551,(void*)0,512);
+  * @endcode
+  *
+  * @param psm - Pixel format to use for rendering (and display)
+  * @param fbp - VRAM pointer to where the draw buffer starts
+  * @param fbw - Frame buffer width (block aligned)
+**/
+void sceGuDrawBuffer(int psm, void* fbp, int fbw);
+
+/**
+  * Set draw buffer directly, not storing parameters in the context
+  *
+  * @param psm - Pixel format to use for rendering
+  * @param fbp - VRAM pointer to where the draw buffer starts
+  * @param fbw - Frame buffer width (block aligned)
+**/
+void sceGuDrawBufferList(int psm, void* fbp, int fbw);
+
+/**
+  * Turn display on or off
+  *
+  * Available states are:
+  *   - GU_TRUE (1) - Turns display on
+  *   - GU_FALSE (0) - Turns display off
+  *
+  * @param state - Turn display on or off
+  * @return State of the display prior to this call
+**/
+int sceGuDisplay(int state);
+
+/**
+  * Select which depth-test function to use
+  *
+  * Valid choices for the depth-test are:
+  *   - GU_NEVER - No pixels pass the depth-test
+  *   - GU_ALWAYS - All pixels pass the depth-test
+  *   - GU_EQUAL - Pixels that match the depth-test pass
+  *   - GU_NOTEQUAL - Pixels that doesn't match the depth-test pass
+  *   - GU_LESS - Pixels that are less in depth passes
+  *   - GU_LEQUAL - Pixels that are less or equal in depth passes
+  *   - GU_GREATER - Pixels that are greater in depth passes
+  *   - GU_GEQUAL - Pixels that are greater or equal passes
+  *
+  * @param function - Depth test function to use
+**/
+void sceGuDepthFunc(int function);
+
+/**
+  * Mask depth buffer writes
+  *
+  * @param mask - GU_TRUE(1) to disable Z writes, GU_FALSE(0) to enable
+**/
+void sceGuDepthMask(int mask);
+
+void sceGuDepthOffset(unsigned int offset);
+
+/**
+  * Set which range to use for depth calculations.
+  *
+  * @note The depth buffer is inversed, and takes values from 65535 to 0.
+  *
+  * Example: Use the entire depth-range for calculations:
+  * @code
+  * sceGuDepthRange(65535,0);
+  * @endcode
+  *
+  * @param near - Value to use for the near plane
+  * @param far - Value to use for the far plane
+**/
+void sceGuDepthRange(int near, int far);
+
+void sceGuFog(float near, float far, unsigned int color);
+
+/**
+  * Initalize the GU system
+  *
+  * This function MUST be called as the first function, otherwise state is undetermined.
+**/
+void sceGuInit(void);
+
+/**
+  * Shutdown the GU system
+  *
+  * Called when GU is no longer needed
+**/
+void sceGuTerm(void);
+
+void sceGuBreak(int a0);
+void sceGuContinue(void);
+
+/**
+  * Setup signal handler
+  *
+  * Available signals are:
+  *   - GU_CALLBACK_SIGNAL - Called when sceGuSignal is used
+  *   - GU_CALLBACK_FINISH - Called when display list is finished
+  *
+  * @param signal - Signal index to install a handler for
+  * @param callback - Callback to call when signal index is triggered
+  * @return The old callback handler
+**/
+void* sceGuSetCallback(int signal, void (*callback)(int));
+
+/**
+  * Trigger signal to call code from the command stream
+  *
+  * Available behaviors are:
+  *   - GU_BEHAVIOR_SUSPEND - Stops display list execution until callback function finished
+  *   - GU_BEHAVIOR_CONTINUE - Do not stop display list execution during callback
+  *
+  * @param signal - Signal to trigger
+  * @param behavior - Behavior type
+**/
+void sceGuSignal(int signal, int behavior);
+
+/**
+  * Send raw float-command to the GE
+  *
+  * The argument is converted into a 24-bit float before transfer.
+  *
+  * @param cmd - Which command to send
+  * @param argument - Argument to pass along
+**/
+void sceGuSendCommandf(int cmd, float argument);
+
+/**
+  * Send raw command to the GE
+  *
+  * Only the 24 lower bits of the argument is passed along.
+  *
+  * @param cmd - Which command to send
+  * @param argument - Argument to pass along
+**/
+void sceGuSendCommandi(int cmd, int argument);
+
+/**
+  * Allocate memory on the current display list for temporary storage
+  *
+  * @note This function is NOT for permanent memory allocation, the
+  * memory will be invalid as soon as you start filling the same display
+  * list again.
+  *
+  * @param size - How much memory to allocate
+  * @return Memory-block ready for use
+**/
+void* sceGuGetMemory(int size);
+
+/**
+  * Start filling a new display-context
+  *
+  * Contexts available are:
+  *   - GU_DIRECT - Rendering is performed as list is filled
+  *   - GU_CALL - List is setup to be called from the main list
+  *   - GU_SEND - List is buffered for a later call to sceGuSendList()
+  *
+  * The previous context-type is stored so that it can be restored at sceGuFinish().
+  *
+  * @param cid - Context Type
+  * @param list - Pointer to display-list (16 byte aligned)
+**/
+void sceGuStart(int cid, void* list);
+
+/**
+  * Finish current display list and go back to the parent context
+  *
+  * If the context is GU_DIRECT, the stall-address is updated so that the entire list will
+  * execute. Otherwise, only the terminating action is written to the list, depending on
+  * context-type.
+  *
+  * The finish-callback will get a zero as argument when using this function.
+  *
+  * This also restores control back to whatever context that was active prior to this call.
+  *
+  * @return Size of finished display list
+**/
+int sceGuFinish(void);
+
+/**
+  * Finish current display list and go back to the parent context, sending argument id for
+  * the finish callback.
+  *
+  * If the context is GU_DIRECT, the stall-address is updated so that the entire list will
+  * execute. Otherwise, only the terminating action is written to the list, depending on
+  * context-type.
+  *
+  * @param id - Finish callback id (16-bit)
+  * @return Size of finished display list
+**/
+int sceGuFinishId(unsigned int id);
+
+/**
+  * Call previously generated display-list
+  *
+  * @param list - Display list to call
+**/
+void sceGuCallList(const void* list);
+
+/**
+  * Set wether to use stack-based calls or signals to handle execution of called lists.
+  *
+  * @param mode - GU_TRUE(1) to enable signals, GU_FALSE(0) to disable signals and use
+  * normal calls instead.
+**/
+void sceGuCallMode(int mode);
+
+/**
+  * Check how large the current display-list is
+  *
+  * @return The size of the current display list
+**/
+int sceGuCheckList(void);
+
+/**
+  * Send a list to the GE directly
+  *
+  * Available modes are:
+  *   - GU_TAIL - Place list last in the queue, so it executes in-order
+  *   - GU_HEAD - Place list first in queue so that it executes as soon as possible
+  *
+  * @param mode - Whether to place the list first or last in queue
+  * @param list - List to send
+  * @param context - Temporary storage for the GE context
+**/
+void sceGuSendList(int mode, const void* list, PspGeContext* context);
+
+/**
+  * Swap display and draw buffer
+  *
+  * @return Pointer to the new drawbuffer
+**/
+void* sceGuSwapBuffers(void);
+
+/**
+  * Wait until display list has finished executing
+  *
+  * @par Example: Wait for the currently executing display list
+  * @code
+  * sceGuSync(0,0);
+  * @endcode
+  *
+  * Available what are:
+  *   - GU_SYNC_WHAT_DONE
+  *   - GU_SYNC_WHAT_QUEUED
+  *   - GU_SYNC_WHAT_DRAW
+  *   - GU_SYNC_WHAT_STALL
+  *   - GU_SYNC_WHAT_CANCEL
+  *
+  * Available mode are:
+  *   - GU_SYNC_FINISH - Wait until the last sceGuFinish command is reached
+  *   - GU_SYNC_SIGNAL - Wait until the last (?) signal is executed
+  *   - GU_SYNC_DONE - Wait until all commands currently in list are executed
+  *   - GU_SYNC_LIST - Wait for the currently executed display list (GU_DIRECT)
+  *   - GU_SYNC_SEND - Wait for the last send list
+  *
+  * @param mode - What to wait for
+  * @param what - What to sync to
+  * @return Unknown at this time
+**/
+int sceGuSync(int mode, int what);
+
+/**
+  * Draw array of vertices forming primitives
+  *
+  * Available primitive-types are:
+  *   - GU_POINTS - Single pixel points (1 vertex per primitive)
+  *   - GU_LINES - Single pixel lines (2 vertices per primitive)
+  *   - GU_LINE_STRIP - Single pixel line-strip (2 vertices for the first primitive, 1 for every following)
+  *   - GU_TRIANGLES - Filled triangles (3 vertices per primitive)
+  *   - GU_TRIANGLE_STRIP - Filled triangles-strip (3 vertices for the first primitive, 1 for every following)
+  *   - GU_TRIANGLE_FAN - Filled triangle-fan (3 vertices for the first primitive, 1 for every following)
+  *   - GU_SPRITES - Filled blocks (2 vertices per primitive)
+  *
+  * The vertex-type decides how the vertices align and what kind of information they contain.
+  * The following flags are ORed together to compose the final vertex format:
+  *   - GU_TEXTURE_8BIT - 8-bit texture coordinates
+  *   - GU_TEXTURE_16BIT - 16-bit texture coordinates
+  *   - GU_TEXTURE_32BITF - 32-bit texture coordinates (float)
+  *
+  *   - GU_COLOR_5650 - 16-bit color (R5G6B5A0)
+  *   - GU_COLOR_5551 - 16-bit color (R5G5B5A1)
+  *   - GU_COLOR_4444 - 16-bit color (R4G4B4A4)
+  *   - GU_COLOR_8888 - 32-bit color (R8G8B8A8)
+  *
+  *   - GU_NORMAL_8BIT - 8-bit normals
+  *   - GU_NORMAL_16BIT - 16-bit normals
+  *   - GU_NORMAL_32BITF - 32-bit normals (float)
+  *
+  *   - GU_VERTEX_8BIT - 8-bit vertex position
+  *   - GU_VERTEX_16BIT - 16-bit vertex position
+  *   - GU_VERTEX_32BITF - 32-bit vertex position (float)
+  *
+  *   - GU_WEIGHT_8BIT - 8-bit weights
+  *   - GU_WEIGHT_16BIT - 16-bit weights
+  *   - GU_WEIGHT_32BITF - 32-bit weights (float)
+  *
+  *   - GU_INDEX_8BIT - 8-bit vertex index
+  *   - GU_INDEX_16BIT - 16-bit vertex index
+  *
+  *   - GU_WEIGHTS(n) - Number of weights (1-8)
+  *   - GU_VERTICES(n) - Number of vertices (1-8)
+  *
+  *   - GU_TRANSFORM_2D - Coordinate is passed directly to the rasterizer
+  *   - GU_TRANSFORM_3D - Coordinate is transformed before passed to rasterizer
+  *
+  * @note Every vertex must align to 32 bits, which means that you HAVE to pad if it does not add up!
+  *
+  * Vertex order:
+  * [for vertices(1-8)]
+  * [weights (0-8)]
+  * [texture uv]
+  * [color]
+  * [normal]
+  * [vertex]
+  * [/for]
+  *
+  * @par Example: Render 400 triangles, with floating-point texture coordinates, and floating-point position, no indices
+  * @code
+  * sceGuDrawArray(GU_TRIANGLES,GU_TEXTURE_32BITF|GU_VERTEX_32BITF,400*3,0,vertices);
+  * @endcode
+  *
+  * @param prim - What kind of primitives to render
+  * @param vtype - Vertex type to process
+  * @param count - How many vertices to process
+  * @param indices - Optional pointer to an index-list
+  * @param vertices - Pointer to a vertex-list
+**/
+void sceGuDrawArray(int prim, int vtype, int count, const void* indices, const void* vertices);
+
+/**
+  * Begin conditional rendering of object
+  *
+  * If no vertices passed into this function are inside the scissor region, it will skip rendering
+  * the object. There can be up to 32 levels of conditional testing, and all levels HAVE to
+  * be terminated by sceGuEndObject().
+  *
+  * @par Example: test a boundingbox against the frustum, and if visible, render object
+  * @code
+  * sceGuBeginObject(GU_VERTEX_32BITF,8,0,boundingBox);
+  *   sceGuDrawArray(GU_TRIANGLES,GU_TEXTURE_32BITF|GU_VERTEX_32BITF,vertexCount,0,vertices);
+  * sceGuEndObject();
+  * @endcode
+  *
+  * @param vtype - Vertex type to process
+  * @param count - Number of vertices to test
+  * @param indices - Optional list to an index-list
+  * @param vertices - Pointer to a vertex-list
+**/
+void sceGuBeginObject(int vtype, int count, const void* indices, const void* vertices);
+
+/**
+  * End conditional rendering of object
+**/
+void sceGuEndObject(void);
+
+/**
+  * Enable or disable GE state
+  *
+  * Look at sceGuEnable() for a list of states
+  *
+  * @param state - Which state to change
+  * @param status - Wether to enable or disable the state
+**/
+void sceGuSetStatus(int state, int status);
+
+/**
+  * Get if state is currently enabled or disabled
+  *
+  * Look at sceGuEnable() for a list of states
+  *
+  * @param state - Which state to query about
+  * @return Wether state is enabled or not
+**/
+int sceGuGetStatus(int state);
+
+/**
+  * Set the status on all 22 available states
+  *
+  * Look at sceGuEnable() for a list of states
+  *
+  * @param status - Bit-mask (0-21) containing the status of all 22 states
+**/
+void sceGuSetAllStatus(int status);
+
+/**
+  * Query status on all 22 available states
+  *
+  * Look at sceGuEnable() for a list of states
+  *
+  * @return Status of all 22 states as a bitmask (0-21)
+**/
+int sceGuGetAllStatus(void);
+
+/**
+  * Enable GE state
+  *
+  * The currently available states are:
+  *   - GU_ALPHA_TEST
+  *   - GU_DEPTH_TEST
+  *   - GU_SCISSOR_TEST
+  *   - GU_BLEND
+  *   - GU_CULL_FACE
+  *   - GU_DITHER
+  *   - GU_CLIP_PLANES
+  *   - GU_TEXTURE_2D
+  *   - GU_LIGHTING
+  *   - GU_LIGHT0
+  *   - GU_LIGHT1
+  *   - GU_LIGHT2
+  *   - GU_LIGHT3
+  *   - GU_COLOR_LOGIC_OP
+  *
+  * @param state - Which state to enable
+**/
+void sceGuEnable(int state);
+
+/**
+  * Disable GE state
+  *
+  * Look at sceGuEnable() for a list of states
+  *
+  * @param state - Which state to disable
+**/
+void sceGuDisable(int state);
+
+/**
+  * Set light parameters
+  *
+  * Available light types are:
+  *   - GU_DIRECTIONAL - Directional light
+  *   - GU_POINTLIGHT - Single point of light
+  *   - GU_SPOTLIGHT - Point-light with a cone
+  *
+  * Available light components are:
+  *   - GU_AMBIENT_AND_DIFFUSE
+  *   - GU_DIFFUSE_AND_SPECULAR
+  *   - GU_UNKNOWN_LIGHT_COMPONENT
+  *
+  * @param light - Light index
+  * @param type - Light type
+  * @param components - Light components
+  * @param position - Light position
+**/
+void sceGuLight(int light, int type, int components, const ScePspFVector3* position);
+
+/**
+  * Set light attenuation
+  *
+  * @param light - Light index
+  * @param atten0 - Constant attenuation factor
+  * @param atten1 - Linear attenuation factor
+  * @param atten2 - Quadratic attenuation factor
+**/
+void sceGuLightAtt(int light, float atten0, float atten1, float atten2);
+
+/**
+  * Set light color
+  *
+  * Available light components are:
+  *   - GU_AMBIENT
+  *   - GU_DIFFUSE
+  *   - GU_SPECULAR
+  *   - GU_AMBIENT_AND_DIFFUSE
+  *   - GU_DIFFUSE_AND_SPECULAR
+  *
+  * @param light - Light index
+  * @param component - Which component to set
+  * @param color - Which color to use
+**/
+void sceGuLightColor(int light, int component, unsigned int color);
+
+/**
+  * Set light mode
+  *
+  * Available light modes are:
+  *   - GU_SINGLE_COLOR
+  *   - GU_SEPARATE_SPECULAR_COLOR
+  *
+  * Separate specular colors are used to interpolate the specular component
+  * independently, so that it can be added to the fragment after the texture color.
+  *
+  * @param mode - Light mode to use
+**/
+void sceGuLightMode(int mode);
+
+/**
+  * Set spotlight parameters
+  *
+  * @param light - Light index
+  * @param direction - Spotlight direction
+  * @param exponent - Spotlight exponent
+  * @param cutoff - Spotlight cutoff angle (in radians)
+**/
+void sceGuLightSpot(int light, const ScePspFVector3* direction, float exponent, float cutoff);
+
+/**
+  * Clear current drawbuffer
+  *
+  * Available clear-flags are (OR them together to get final clear-mode):
+  *   - GU_COLOR_BUFFER_BIT - Clears the color-buffer
+  *   - GU_STENCIL_BUFFER_BIT - Clears the stencil-buffer
+  *   - GU_DEPTH_BUFFER_BIT - Clears the depth-buffer
+  *
+  * @param flags - Which part of the buffer to clear
+**/
+void sceGuClear(int flags);
+
+/**
+  * Set the current clear-color
+  *
+  * @param color - Color to clear with
+**/
+void sceGuClearColor(unsigned int color);
+
+/**
+  * Set the current clear-depth
+  *
+  * @param depth - Set which depth to clear with (0x0000-0xffff)
+**/
+void sceGuClearDepth(unsigned int depth);
+
+/**
+  * Set the current stencil clear value
+  *
+  * @param stencil - Set which stencil value to clear with (0-255)
+  *
+**/
+void sceGuClearStencil(unsigned int stencil);
+
+/**
+  * Set mask for which bits of the pixels to write
+  *
+  * @param mask - Which bits to filter against writes
+  *
+**/
+void sceGuPixelMask(unsigned int mask);
+
+/**
+  * Set current primitive color
+  *
+  * @param color - Which color to use (overriden by vertex-colors)
+**/
+void sceGuColor(unsigned int color);
+
+/**
+  * Set the color test function
+  *
+  * The color test is only performed while GU_COLOR_TEST is enabled.
+  *
+  * Available functions are:
+  *   - GU_NEVER
+  *   - GU_ALWAYS
+  *   - GU_EQUAL
+  *   - GU_NOTEQUAL
+  *
+  * @par Example: Reject any pixel that does not have 0 as the blue channel
+  * @code
+  * sceGuColorFunc(GU_EQUAL,0,0xff0000);
+  * @endcode
+  *
+  * @param func - Color test function
+  * @param color - Color to test against
+  * @param mask - Mask ANDed against both source and destination when testing
+**/
+void sceGuColorFunc(int func, unsigned int color, unsigned int mask);
+
+/**
+  * Set which color components that the material will receive
+  *
+  * The components are ORed together from the following values:
+  *   - GU_AMBIENT
+  *   - GU_DIFFUSE
+  *   - GU_SPECULAR
+  *
+  * @param components - Which components to receive
+**/
+void sceGuColorMaterial(int components);
+
+/**
+  * Set the alpha test parameters
+  * 
+  * Available comparison functions are:
+  *   - GU_NEVER
+  *   - GU_ALWAYS
+  *   - GU_EQUAL
+  *   - GU_NOTEQUAL
+  *   - GU_LESS
+  *   - GU_LEQUAL
+  *   - GU_GREATER
+  *   - GU_GEQUAL
+  *
+  * @param func - Specifies the alpha comparison function.
+  * @param value - Specifies the reference value that incoming alpha values are compared to.
+  * @param mask - Specifies the mask that both values are ANDed with before comparison.
+**/
+void sceGuAlphaFunc(int func, int value, int mask);
+
+void sceGuAmbient(unsigned int color);
+void sceGuAmbientColor(unsigned int color);
+
+/**
+  * Set the blending-mode
+  *
+  * Keys for the blending operations:
+  *   - Cs - Source color
+  *   - Cd - Destination color
+  *   - Bs - Blend function for source fragment
+  *   - Bd - Blend function for destination fragment
+  *
+  * Available blending-operations are:
+  *   - GU_ADD - (Cs*Bs) + (Cd*Bd)
+  *   - GU_SUBTRACT - (Cs*Bs) - (Cd*Bd)
+  *   - GU_REVERSE_SUBTRACT - (Cd*Bd) - (Cs*Bs)
+  *   - GU_MIN - Cs < Cd ? Cs : Cd
+  *   - GU_MAX - Cs < Cd ? Cd : Cs
+  *   - GU_ABS - |Cs-Cd|
+  *
+  * Available blending-functions are:
+  *   - GU_SRC_COLOR
+  *   - GU_ONE_MINUS_SRC_COLOR
+  *   - GU_SRC_ALPHA
+  *   - GU_ONE_MINUS_SRC_ALPHA
+  *   - GU_DST_ALPHA
+  *   - GU_ONE_MINUS_DST_ALPHA
+  *   - GU_DST_COLOR
+  *   - GU_ONE_MINUS_DST_COLOR
+  *   - GU_FIX
+  *
+  * @param op - Blending Operation
+  * @param src - Blending function for source operand
+  * @param dest - Blending function for dest operand
+  * @param srcfix - Fix value for GU_FIX (source operand)
+  * @param destfix - Fix value for GU_FIX (dest operand)
+**/
+void sceGuBlendFunc(int op, int src, int dest, unsigned int srcfix, unsigned int destfix);
+
+void sceGuMaterial(int mode, int color);
+
+/**
+  *
+**/
+void sceGuModelColor(unsigned int emissive, unsigned int ambient, unsigned int diffuse, unsigned int specular);
+
+/**
+  * Set stencil function and reference value for stencil testing
+  *
+  * Available functions are:
+  *   - GU_NEVER
+  *   - GU_ALWAYS
+  *   - GU_EQUAL
+  *   - GU_NOTEQUAL
+  *   - GU_LESS
+  *   - GU_LEQUAL
+  *   - GU_GREATER
+  *   - GU_GEQUAL
+  *
+  * @param func - Test function
+  * @param ref - The reference value for the stencil test
+  * @param mask - Mask that is ANDed with both the reference value and stored stencil value when the test is done
+**/
+void sceGuStencilFunc(int func, int ref, int mask);
+
+/**
+  * Set the stencil test actions
+  *
+  * Available actions are:
+  *   - GU_KEEP - Keeps the current value
+  *   - GU_ZERO - Sets the stencil buffer value to zero
+  *   - GU_REPLACE - Sets the stencil buffer value to ref, as specified by sceGuStencilFunc()
+  *   - GU_INCR - Increments the current stencil buffer value
+  *   - GU_DECR - Decrease the current stencil buffer value
+  *   - GU_INVERT - Bitwise invert the current stencil buffer value
+  *
+  * As stencil buffer shares memory with framebuffer alpha, resolution of the buffer
+  * is directly in relation.
+  *
+  * @param fail - The action to take when the stencil test fails
+  * @param zfail - The action to take when stencil test passes, but the depth test fails
+  * @param zpass - The action to take when both stencil test and depth test passes
+**/
+void sceGuStencilOp(int fail, int zfail, int zpass);
+
+/**
+  * Set the specular power for the material
+  *
+  * @param power - Specular power
+  *
+**/
+void sceGuSpecular(float power);
+
+/**
+  * Set the current face-order (for culling)
+  *
+  * This only has effect when culling is enabled (GU_CULL_FACE)
+  *
+  * Culling order can be:
+  *   - GU_CW - Clockwise primitives are not culled
+  *   - GU_CCW - Counter-clockwise are not culled
+  *
+  * @param order - Which order to use
+**/
+void sceGuFrontFace(int order);
+
+/**
+  * Set color logical operation
+  *
+  * Available operations are:
+  *   - GU_CLEAR
+  *   - GU_AND
+  *   - GU_AND_REVERSE 
+  *   - GU_COPY
+  *   - GU_AND_INVERTED
+  *   - GU_NOOP
+  *   - GU_XOR
+  *   - GU_OR
+  *   - GU_NOR
+  *   - GU_EQUIV
+  *   - GU_INVERTED
+  *   - GU_OR_REVERSE
+  *   - GU_COPY_INVERTED
+  *   - GU_OR_INVERTED
+  *   - GU_NAND
+  *   - GU_SET
+  *
+  * This operation only has effect if GU_COLOR_LOGIC_OP is enabled.
+  *
+  * @param op - Operation to execute
+**/
+void sceGuLogicalOp(int op);
+
+/**
+  * Set ordered pixel dither matrix
+  *
+  * This dither matrix is only applied if GU_DITHER is enabled.
+  *
+  * @param matrix - Dither matrix
+**/
+void sceGuSetDither(const ScePspIMatrix4* matrix);
+
+/**
+  * Set how primitives are shaded
+  *
+  * The available shading-methods are:
+  *   - GU_FLAT - Primitives are flatshaded, the last vertex-color takes effet
+  *   - GU_SMOOTH - Primtives are gouraud-shaded, all vertex-colors take effect
+  *
+  * @param mode - Which mode to use
+**/
+void sceGuShadeModel(int mode);
+
+/**
+  * Image transfer using the GE
+  *
+  * @note Data must be aligned to 1 quad word (16 bytes)
+  *
+  * @par Example: Copy a fullscreen 32-bit image from RAM to VRAM
+  * @code
+  * sceGuCopyImage(GU_PSM_8888,0,0,480,272,512,pixels,0,0,512,(void*)(((unsigned int)framebuffer)+0x4000000));
+  * @endcode
+  *
+  * @param psm - Pixel format for buffer
+  * @param sx - Source X
+  * @param sy - Source Y
+  * @param width - Image width
+  * @param height - Image height
+  * @param srcw - Source buffer width (block aligned)
+  * @param src - Source pointer
+  * @param dx - Destination X
+  * @param dy - Destination Y
+  * @param destw - Destination buffer width (block aligned)
+  * @param dest - Destination pointer
+**/
+void sceGuCopyImage(int psm, int sx, int sy, int width, int height, int srcw, void* src, int dx, int dy, int destw, void* dest);
+
+/**
+  * Specify the texture environment color
+  *
+  * This is used in the texture function when a constant color is needed.
+  *
+  * See sceGuTexFunc() for more information.
+  *
+  * @param color - Constant color (0x00BBGGRR)
+**/
+void sceGuTexEnvColor(unsigned int color);
+
+/**
+  * Set how the texture is filtered
+  *
+  * Available filters are:
+  *   - GU_NEAREST
+  *   - GU_LINEAR
+  *   - GU_NEAREST_MIPMAP_NEAREST
+  *   - GU_LINEAR_MIPMAP_NEAREST
+  *   - GU_NEAREST_MIPMAP_LINEAR
+  *   - GU_LINEAR_MIPMAP_LINEAR
+  *
+  * @param min - Minimizing filter
+  * @param mag - Magnifying filter
+**/
+void sceGuTexFilter(int min, int mag);
+
+/**
+  * Flush texture page-cache
+  *
+  * Do this if you have copied/rendered into an area currently in the texture-cache
+  *
+**/
+void sceGuTexFlush(void);
+
+/**
+  * Set how textures are applied
+  *
+  * Key for the apply-modes:
+  *   - Cv - Color value result
+  *   - Ct - Texture color
+  *   - Cf - Fragment color
+  *   - Cc - Constant color (specified by sceGuTexEnvColor())
+  *
+  * Available apply-modes are: (TFX)
+  *   - GU_TFX_MODULATE - Cv=Ct*Cf TCC_RGB: Av=Af TCC_RGBA: Av=At*Af
+  *   - GU_TFX_DECAL - TCC_RGB: Cv=Ct,Av=Af TCC_RGBA: Cv=Cf*(1-At)+Ct*At Av=Af
+  *   - GU_TFX_BLEND - Cv=(Cf*(1-Ct))+(Cc*Ct) TCC_RGB: Av=Af TCC_RGBA: Av=At*Af
+  *   - GU_TFX_REPLACE - Cv=Ct TCC_RGB: Av=Af TCC_RGBA: Av=At
+  *   - GU_TFX_ADD - Cv=Cf+Ct TCC_RGB: Av=Af TCC_RGBA: Av=At*Af
+  *
+  * The fields TCC_RGB and TCC_RGBA specify components that differ between
+  * the two different component modes.
+  *
+  *   - GU_TFX_MODULATE - The texture is multiplied with the current diffuse fragment
+  *   - GU_TFX_REPLACE - The texture replaces the fragment
+  *   - GU_TFX_ADD - The texture is added on-top of the diffuse fragment
+  *   
+  * Available component-modes are: (TCC)
+  *   - GU_TCC_RGB - The texture alpha does not have any effect
+  *   - GU_TCC_RGBA - The texture alpha is taken into account
+  *
+  * @param tfx - Which apply-mode to use
+  * @param tcc - Which component-mode to use
+**/
+void sceGuTexFunc(int tfx, int tcc);
+
+/**
+  * Set current texturemap
+  *
+  * Textures may reside in main RAM, but it has a huge speed-penalty. Swizzle textures
+  * to get maximum speed.
+  *
+  * @note Data must be aligned to 1 quad word (16 bytes)
+  *
+  * @param mipmap - Mipmap level
+  * @param width - Width of texture (must be a power of 2)
+  * @param height - Height of texture (must be a power of 2)
+  * @param tbw - Texture Buffer Width (block-aligned)
+  * @param tbp - Texture buffer pointer (16 byte aligned)
+**/
+void sceGuTexImage(int mipmap, int width, int height, int tbw, const void* tbp);
+
+/**
+  * Set texture-level mode (mipmapping)
+  *
+  * Available modes are:
+  *   - GU_TEXTURE_AUTO
+  *   - GU_TEXTURE_CONST
+  *   - GU_TEXTURE_SLOPE
+  *
+  * @param mode - Which mode to use
+  * @param bias - Which mipmap bias to use
+**/
+void sceGuTexLevelMode(unsigned int mode, float bias);
+
+/**
+  * Set the texture-mapping mode
+  *
+  * Available modes are:
+  *   - GU_TEXTURE_COORDS
+  *   - GU_TEXTURE_MATRIX
+  *   - GU_ENVIRONMENT_MAP
+  *
+  * @param mode - Which mode to use
+  * @param a1 - Unknown
+  * @param a2 - Unknown
+**/
+void sceGuTexMapMode(int mode, unsigned int a1, unsigned int a2);
+
+/**
+  * Set texture-mode parameters
+  *
+  * Available texture-formats are:
+  *   - GU_PSM_5650 - Hicolor, 16-bit
+  *   - GU_PSM_5551 - Hicolor, 16-bit
+  *   - GU_PSM_4444 - Hicolor, 16-bit
+  *   - GU_PSM_8888 - Truecolor, 32-bit
+  *   - GU_PSM_T4 - Indexed, 4-bit (2 pixels per byte)
+  *   - GU_PSM_T8 - Indexed, 8-bit
+  *
+  * @param tpsm - Which texture format to use
+  * @param maxmips - Number of mipmaps to use (0-8)
+  * @param a2 - Unknown, set to 0
+  * @param swizzle - GU_TRUE(1) to swizzle texture-reads
+**/
+void sceGuTexMode(int tpsm, int maxmips, int a2, int swizzle);
+
+/**
+  * Set texture offset
+  *
+  * @note Only used by the 3D T&L pipe, renders done with GU_TRANSFORM_2D are
+  * not affected by this.
+  *
+  * @param u - Offset to add to the U coordinate
+  * @param v - Offset to add to the V coordinate
+**/
+void sceGuTexOffset(float u, float v);
+
+/**
+  * Set texture projection-map mode
+  *
+  * Available modes are:
+  *   - GU_POSITION
+  *   - GU_UV
+  *   - GU_NORMALIZED_NORMAL
+  *   - GU_NORMAL
+  *
+  * @param mode - Which mode to use
+**/
+void sceGuTexProjMapMode(int mode);
+
+/**
+  * Set texture scale
+  *
+  * @note Only used by the 3D T&L pipe, renders ton with GU_TRANSFORM_2D are
+  * not affected by this.
+  *
+  * @param u - Scalar to multiply U coordinate with
+  * @param v - Scalar to multiply V coordinate with
+**/
+void sceGuTexScale(float u, float v);
+void sceGuTexSlope(float slope);
+
+/**
+  * Synchronize rendering pipeline with image upload.
+  *
+  * This will stall the rendering pipeline until the current image upload initiated by
+  * sceGuCopyImage() has completed.
+**/
+void sceGuTexSync();
+
+/**
+  * Set if the texture should repeat or clamp
+  *
+  * Available modes are:
+  *   - GU_REPEAT - The texture repeats after crossing the border
+  *   - GU_CLAMP - Texture clamps at the border
+  *
+  * @param u - Wrap-mode for the U direction
+  * @param v - Wrap-mode for the V direction
+**/
+void sceGuTexWrap(int u, int v);
+
+/**
+  * Upload CLUT (Color Lookup Table)
+  *
+  * @note Data must be aligned to 1 quad word (16 bytes)
+  *
+  * @param num_blocks - How many blocks of 8 entries to upload (32*8 is 256 colors)
+  * @param cbp - Pointer to palette (16 byte aligned)
+**/
+void sceGuClutLoad(int num_blocks, const void* cbp);
+
+/**
+  * Set current CLUT mode
+  *
+  * Available pixel formats for palettes are:
+  *   - GU_PSM_5650
+  *   - GU_PSM_5551
+  *   - GU_PSM_4444
+  *   - GU_PSM_8888
+  *
+  * @param cpsm - Which pixel format to use for the palette
+  * @param shift - Shifts color index by that many bits to the right
+  * @param mask - Masks the color index with this bitmask after the shift (0-0xFF)
+  * @param a3 - Unknown, set to 0
+**/
+void sceGuClutMode(unsigned int cpsm, unsigned int shift, unsigned int mask, unsigned int a3);
+
+/**
+  * Set virtual coordinate offset
+  *
+  * The PSP has a virtual coordinate-space of 4096x4096, this controls where rendering is performed
+  * 
+  * @par Example: Center the virtual coordinate range
+  * @code
+  * sceGuOffset(2048-(480/2),2048-(480/2));
+  * @endcode
+  *
+  * @param x - Offset (0-4095)
+  * @param y - Offset (0-4095)
+**/
+void sceGuOffset(unsigned int x, unsigned int y);
+
+/**
+  * Set what to scissor within the current viewport
+  *
+  * Note that scissoring is only performed if the custom scissoring is enabled (GU_SCISSOR_TEST)
+  *
+  * @param x - Left of scissor region
+  * @param y - Top of scissor region
+  * @param w - Width of scissor region
+  * @param h - Height of scissor region
+**/
+void sceGuScissor(int x, int y, int w, int h);
+
+/**
+  * Set current viewport
+  *
+  * @par Example: Setup a viewport of size (480,272) with origo at (2048,2048)
+  * @code
+  * sceGuViewport(2048,2048,480,272);
+  * @endcode
+  *
+  * @param cx - Center for horizontal viewport
+  * @param cy - Center for vertical viewport
+  * @param width - Width of viewport
+  * @param height - Height of viewport
+**/
+void sceGuViewport(int cx, int cy, int width, int height);
+
+/**
+  * Draw bezier surface
+  *
+  * @param vtype - Vertex type, look at sceGuDrawArray() for vertex definition
+  * @param ucount - Number of vertices used in the U direction
+  * @param vcount - Number of vertices used in the V direction
+  * @param indices - Pointer to index buffer
+  * @param vertices - Pointer to vertex buffer
+**/
+void sceGuDrawBezier(int vtype, int ucount, int vcount, const void* indices, const void* vertices);
+
+/**
+  * Set dividing for patches (beziers and splines)
+  *
+  * @param ulevel - Number of division on u direction
+  * @param vlevel - Number of division on v direction
+**/
+void sceGuPatchDivide(unsigned int ulevel, unsigned int vlevel);
+
+void sceGuPatchFrontFace(unsigned int a0);
+
+/**
+  * Set primitive for patches (beziers and splines)
+  *
+  * @param prim - Desired primitive type (GU_POINTS | GU_LINE_STRIP | GU_TRIANGLE_STRIP)
+**/
+void sceGuPatchPrim(int prim);
+
+void sceGuDrawSpline(int vtype, int ucount, int vcount, int uedge, int vedge, const void* indices, const void* vertices);
+
+/**
+  * Set transform matrices
+  *
+  * Available matrices are:
+  *   - GU_PROJECTION - View->Projection matrix
+  *   - GU_VIEW - World->View matrix
+  *   - GU_MODEL - Model->World matrix
+  *   - GU_TEXTURE - Texture matrix
+  *
+  * @param type - Which matrix-type to set
+  * @param matrix - Matrix to load
+**/
+void sceGuSetMatrix(int type, const ScePspFMatrix4* matrix);
+
+/**
+  * Specify skinning matrix entry
+  *
+  * To enable vertex skinning, pass GU_WEIGHTS(n), where n is between
+  * 1-8, and pass available GU_WEIGHT_??? declaration. This will change
+  * the amount of weights passed in the vertex araay, and by setting the skinning,
+  * matrices, you will multiply each vertex every weight and vertex passed.
+  *
+  * Please see sceGuDrawArray() for vertex format information.
+  *
+  * @param index - Skinning matrix index (0-7)
+  * @param matrix - Matrix to set
+**/
+void sceGuBoneMatrix(unsigned int index, const ScePspFMatrix4* matrix);
+
+/**
+  * Specify morph weight entry
+  *
+  * To enable vertex morphing, pass GU_VERTICES(n), where n is between
+  * 1-8. This will change the amount of vertices passed in the vertex array,
+  * and by setting the morph weights for every vertex entry in the array,
+  * you can blend between them.
+  *
+  * Please see sceGuDrawArray() for vertex format information.
+  *
+  * @param index - Morph weight index (0-7)
+  * @param weight - Weight to set
+**/
+void sceGuMorphWeight(int index, float weight);
+
+void sceGuDrawArrayN(int primitive_type, int vertex_type, int count, int a3, const void* indices, const void* vertices);
+
+/**
+  * Set how the display should be set
+  *
+  * Available behaviours are:
+  *   - PSP_DISPLAY_SETBUF_IMMEDIATE - Display is swapped immediately
+  *   - PSP_DISPLAY_SETBUF_NEXTFRAME - Display is swapped on the next frame
+  *
+  * Do remember that this swaps the pointers internally, regardless of setting, so be careful to wait until the next
+  * vertical blank or use another buffering algorithm (see guSwapBuffersCallback()).
+**/
+void guSwapBuffersBehaviour(int behaviour);
+
+/**
+  * Set a buffer swap callback to allow for more advanced buffer methods without hacking the library.
+  *
+  * The GuSwapBuffersCallback is defined like this:
+  * @code
+  * void swapBuffersCallback(void** display, void** render);
+  * @endcode
+  * and on entry they contain the variables that are to be set. To change the pointers that will be used, just
+  * write the new pointers. Example of a triple-buffering algorithm:
+  * @code
+  * void* doneBuffer;
+  * void swapBuffersCallback(void** display, void** render)
+  * {
+  *  void* active = doneBuffer;
+  *  doneBuffer = *display;
+     *display = active;
+  * }
+  * @endcode
+  *
+  * @param callback - Callback to access when buffers are swapped. Pass 0 to disable.
+**/
+void guSwapBuffersCallback(GuSwapBuffersCallback callback);
+
+/**@}*/
+
+#if defined(__cplusplus)
+};
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspgum.h b/newlib/psp/include/pspgum.h
new file mode 100644
index 0000000..0baf46a
--- /dev/null
+++ b/newlib/psp/include/pspgum.h
@@ -0,0 +1,236 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * Copyright (c) 2005 Jesper Svennevid
+ */
+
+#ifndef __pspgum_h__
+#define __pspgum_h__
+
+#include <psptypes.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// stack functions
+
+void sceGumDrawArray(int prim, int vtype, int count, const void* indices, const void* vertices);
+void sceGumDrawArrayN(int prim, int vtype, int count, int a3, const void* indices, const void* vertices);
+void sceGumDrawBezier(int vtype, int ucount, int vcount, const void* indices, const void* vertices);
+void sceGumDrawSpline(int vtype, int ucount, int vcount, int uedge, int vedge, const void* indices, const void* vertices);
+
+/**
+  * Load identity matrix
+  *
+  * [1 0 0 0]
+  * [0 1 0 0]
+  * [0 0 1 0]
+  * [0 0 0 1]
+**/
+void sceGumLoadIdentity(void);
+
+/**
+  * Load matrix
+  *
+  * @param m - Matrix to load into stack
+**/
+void sceGumLoadMatrix(const ScePspFMatrix4* m);
+
+void sceGumLookAt(ScePspFVector3* eye, ScePspFVector3* center, ScePspFVector3* up);
+
+/**
+  * Select which matrix stack to operate on
+  *
+  * Available matrix modes are:
+  *   - GU_PROJECTION
+  *   - GU_VIEW
+  *   - GU_MODEL
+  *   - GU_TEXTURE
+  *
+  * @param mode - Matrix mode to use
+**/
+void sceGumMatrixMode(int mode);
+
+/**
+  * Multiply current matrix with input
+  *
+  * @param m - Matrix to multiply stack with
+**/
+void sceGumMultMatrix(const ScePspFMatrix4* m);
+
+/**
+  * Apply ortho projection matrix
+  *
+  * @note The matrix loses its orthonogal status after executing this function.
+**/
+void sceGumOrtho(float left, float right, float bottom, float top, float near, float far);
+
+/**
+  * Apply perspective projection matrix
+  *
+  * @note The matrix loses its orthonogal status after executing this function.
+**/
+void sceGumPerspective(float fovy, float aspect, float near, float far);
+
+/**
+  * Pop matrix from stack
+**/
+void sceGumPopMatrix(void);
+
+/**
+  * Push current matrix onto stack
+**/
+void sceGumPushMatrix(void);
+
+/**
+  * Rotate around the X axis
+  *
+  * @param angle - Angle in radians
+**/
+void sceGumRotateX(float angle);
+
+/**
+  * Rotate around the Y axis
+  *
+  * @param angle - Angle in radians
+**/
+void sceGumRotateY(float angle);
+
+/**
+  * Rotate around the Z axis
+  *
+  * @param angle - Angle in radians
+**/
+void sceGumRotateZ(float angle);
+
+/**
+  * Rotate around all 3 axis in order X, Y, Z
+  *
+  * @param v - Pointer to vector containing angles
+**/
+void sceGumRotateXYZ(const ScePspFVector3* v);
+
+/**
+  * Rotate around all 3 axis in order Z, Y, X
+  *
+  * @param v - Pointer to vector containing angles
+**/
+void sceGumRotateZYX(const ScePspFVector3* v);
+
+/**
+  * Scale matrix
+  *
+  * @note The matrix loses its orthonogal status after executing this function.
+**/
+void sceGumScale(const ScePspFVector3* v);
+
+/**
+  * Store current matrix in the stack
+  *
+  * @param m - Matrix to write result to
+**/
+void sceGumStoreMatrix(ScePspFMatrix4* m);
+
+/**
+  * Translate coordinate system
+  *
+  * @param v - Translation coordinates
+**/
+void sceGumTranslate(const ScePspFVector3* v);
+
+/**
+  * Explicitly flush dirty matrices to the hardware
+**/
+void sceGumUpdateMatrix(void);
+
+/**
+  * Invert 4x4 matrix
+  *
+  * This invert algorithm can operate on matrices that are not orthongal (See sceGumFastInverse())
+**/
+void sceGumFullInverse();
+
+/**
+  * Invert orthonogal 4x4 matrix
+  *
+  * Note that the matrix in the stack has to be orthonogal (that is, all rotational axises must be unit length & orthonogal against the others),
+  * otherwise the result of the function cannot be depended on. If you need to invert a matrix that is not orthonogal, use sceGumFullInverse().
+**/
+void sceGumFastInverse();
+
+/**
+  * Stack-aware version of sceGuBeginObject() (look in pspgu.h for description)
+  *
+  * @note NOT YET IMPLEMENTED
+  *
+  * @param vtype - Vertex type to process
+  * @param count - Number of vertices to test
+  * @param indices - Optional index-list
+  * @param vertices - Vertex-list
+**/
+void sceGumBeginObject(int vtype, int count, const void* indices, const void* vertices);
+
+/**
+  * Stack-aware version of sceGuEndObject()
+  *
+  * @note NOT YET IMPLEMENTED
+**/
+void sceGumEndObject();
+
+// unimplemented functions
+
+//sceGumLoadContext
+//sceGumSetCurMatrix
+//sceGumSetMatrixStack
+//sceGumStoreContext
+
+// standalone functions
+
+void gumInit(void);
+
+/**
+  * Load matrix with identity
+  *
+  * @param m - Matrix to load with identity
+**/
+void gumLoadIdentity(ScePspFMatrix4* m);
+
+void gumLoadMatrix(ScePspFMatrix4* r, const ScePspFMatrix4* a);
+void gumLookAt(ScePspFMatrix4* m, ScePspFVector3* eye, ScePspFVector3* center, ScePspFVector3* up);
+void gumMultMatrix(ScePspFMatrix4* result, const ScePspFMatrix4* a, const ScePspFMatrix4* b);
+void gumOrtho(ScePspFMatrix4* m, float left, float right, float bottom, float top, float near, float far);
+void gumPerspective(ScePspFMatrix4* m, float fovy, float aspect, float near, float far);
+void gumRotateX(ScePspFMatrix4* m, float angle);
+void gumRotateXYZ(ScePspFMatrix4* m, const ScePspFVector3* v);
+void gumRotateY(ScePspFMatrix4* m, float angle);
+void gumRotateZ(ScePspFMatrix4* m, float angle);
+void gumRotateZYX(ScePspFMatrix4* m, const ScePspFVector3* v);
+void gumScale(ScePspFMatrix4* m, const ScePspFVector3* v);
+void gumTranslate(ScePspFMatrix4* m, const ScePspFVector3* v);
+void gumFullInverse(ScePspFMatrix4* r, const ScePspFMatrix4* a);
+
+/**
+  * Invert orthonogal 4x4 matrix
+  *
+  * Note that the matrix in the stack has to be orthonogal (that is, all rotational axises must be unit length & orthonogal against the others),
+  * otherwise the result of the function cannot be depended on. If you need to invert a matrix that is not orthonogal, use gumFullInverse().
+  *
+  * @param r - Matrix receiving result
+  * @param a - Orthonogal matrix that is to be inverted
+**/
+void gumFastInverse(ScePspFMatrix4* r, const ScePspFMatrix4* a);
+
+// vector functions
+
+void gumCrossProduct(ScePspFVector3* r, const ScePspFVector3* a, const ScePspFVector3* b);
+float gumDotProduct(const ScePspFVector3* a, const ScePspFVector3* b);
+void gumNormalize(ScePspFVector3* v);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psphprm.h b/newlib/psp/include/psphprm.h
new file mode 100644
index 0000000..ac0a930
--- /dev/null
+++ b/newlib/psp/include/psphprm.h
@@ -0,0 +1,94 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspaudio.h - Prototypes for the sceHprm library.
+ *
+ * Copyright (c) 2005 Adresd
+ *
+ */
+#ifndef __HPRM_H__
+#define __HPRM_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup Hprm Hprm Remote */
+
+/** @addtogroup Hprm */
+
+/**@{*/
+
+/** Enumeration of the remote keys */
+enum PspHprmKeys
+{
+	PSP_HPRM_PLAYPAUSE  = 0x1,
+	PSP_HPRM_FORWARD    = 0x4,
+	PSP_HPRM_BACK       = 0x8,
+	PSP_HPRM_VOL_UP		= 0x10,
+	PSP_HPRM_VOL_DOWN   = 0x20,
+	PSP_HPRM_HOLD       = 0x80
+};
+
+/** 
+  * Peek at the current being pressed on the remote.
+  * 
+  * @param key - Pointer to the u32 to receive the key bitmap, should be one or
+  * more of ::PspHprmKeys
+  *
+  * @return < 0 on error
+  */
+int sceHprmPeekCurrentKey(u32 *key);
+
+/**
+  * Peek at the current latch data.
+  *
+  * @param latch - Pointer a to a 4 dword array to contain the latch data.
+  *
+  * @return < 0 on error.
+  */
+int sceHprmPeekLatch(u32 *latch);
+
+/**
+  * Read the current latch data.
+  *
+  * @param latch - Pointer a to a 4 dword array to contain the latch data.
+  *
+  * @return < 0 on error.
+  */
+int sceHprmReadLatch(u32 *latch);
+
+/**
+  * Determines whether the headphones are plugged in.
+  *
+  * @return 1 if the headphones are plugged in, else 0.
+  */
+int sceHprmIsHeadphoneExist(void);
+
+/** 
+  * Determines whether the remote is plugged in.
+  *
+  * @return 1 if the remote is plugged in, else 0.
+  */
+int sceHprmIsRemoteExist(void);
+
+/** 
+  * Determines whether the microphone is plugged in.
+  *
+  * @return 1 if the microphone is plugged in, else 0.
+  */
+int sceHprmIsMicrophoneExist(void);
+
+
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psphttp.h b/newlib/psp/include/psphttp.h
new file mode 100644
index 0000000..9667afe
--- /dev/null
+++ b/newlib/psp/include/psphttp.h
@@ -0,0 +1,393 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psphttp.h - Interface to the http library.
+ *
+ * Copyright (c) 2008 David Perry (InsertWittyName)
+ * Copyright (c) 2008 moonlight
+ *
+ */
+ 
+#ifndef __PSPHTTP_H__
+#define __PSPHTTP_H__
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef enum
+{
+	PSP_HTTP_VERSION_1_0,
+	PSP_HTTP_VERSION_1_1
+} PspHttpHttpVersion;
+
+typedef enum
+{
+	PSP_HTTP_METHOD_GET,
+	PSP_HTTP_METHOD_POST,
+	PSP_HTTP_METHOD_HEAD
+	
+} PspHttpMethod;
+
+typedef enum
+{
+	PSP_HTTP_AUTH_BASIC,
+	PSP_HTTP_AUTH_DIGEST
+} PspHttpAuthType;
+
+
+typedef enum
+{
+	PSP_HTTP_PROXY_AUTO,
+	PSP_HTTP_PROXY_MANUAL
+} PspHttpProxyMode;
+
+typedef enum
+{
+	PSP_HTTP_HEADER_OVERWRITE,
+	PSP_HTTP_HEADER_ADD
+} PspHttpAddHeaderMode;
+
+/* Memory function types */
+typedef void *(*PspHttpMallocFunction)(SceSize size);
+typedef void *(*PspHttpReallocFunction)(void *p, SceSize size);
+typedef void (*PspHttpFreeFunction)(void *p);
+
+typedef int (*PspHttpPasswordCB)(
+	int request,
+	PspHttpAuthType auth_type,
+	const unsigned char *realm,
+	unsigned char *username,
+	unsigned char *password,
+	SceBool need_entity,
+	unsigned char **entity_body,
+	SceSize *entity_size,
+	SceBool *save);
+
+/**
+ * Init the http library.
+ *
+ * @param unknown1 - Memory pool size? Pass 20000
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpInit(unsigned int unknown1);
+
+/**
+ * Terminate the http library.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpEnd(void);
+
+/**
+ * Create a http template.
+ *
+ * @param agent - User agent
+ * @param unknown1 - Pass 1
+ * @param unknown2 - Pass 0
+ * @return A template ID on success, < 0 on error.
+ */
+int sceHttpCreateTemplate(char *agent, int unknown1, int unknown2);
+
+/**
+ * Delete a http template.
+ *
+ * @param templateid - ID of the template created by sceHttpCreateTemplate
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDeleteTemplate(int templateid);
+
+/**
+ * Create a http connection.
+ *
+ * @param templateid - ID of the template created by sceHttpCreateTemplate
+ * @param host - Host to connect to
+ * @param unknown1 - Pass "http"
+ * @param port - Port to connect on
+ * @param unknown2 - Pass 0
+ * @return A connection ID on success, < 0 on error.
+ */
+int sceHttpCreateConnection(int templateid, char *host, char *unknown1, unsigned short port, int unknown2);
+
+/**
+ * Create a http connection to a url.
+ *
+ * @param templateid - ID of the template created by sceHttpCreateTemplate
+ * @param url - url to connect to
+ * @param unknown1 - Pass 0
+ * @return A connection ID on success, < 0 on error.
+ */
+int sceHttpCreateConnectionWithURL(int templateid, const char *url, int unknown1);
+
+/**
+ * Delete a http connection.
+ *
+ * @param connectionid - ID of the connection created by sceHttpCreateConnection or sceHttpCreateConnectionWithURL
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDeleteConnection(int connectionid);
+
+/**
+ * Create a http request.
+ *
+ * @param connectionid - ID of the connection created by sceHttpCreateConnection or sceHttpCreateConnectionWithURL
+ * @param method - One of ::PspHttpMethod
+ * @param path - Path to access
+ * @param contentlength - Length of the content (POST method only)
+ * @return A request ID on success, < 0 on error.
+ */
+int sceHttpCreateRequest(int connectionid, PspHttpMethod method, char *path, SceULong64 contentlength);
+
+/**
+ * Create a http request with url.
+ *
+ * @param connectionid - ID of the connection created by sceHttpCreateConnection or sceHttpCreateConnectionWithURL
+ * @param method - One of ::PspHttpMethod
+ * @param url - url to access
+ * @param contentlength - Length of the content (POST method only)
+ * @return A request ID on success, < 0 on error.
+ */
+int sceHttpCreateRequestWithURL(int connectionid, PspHttpMethod method, char *url, SceULong64 contentlength);
+
+/**
+ * Delete a http request.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDeleteRequest(int requestid);
+
+/**
+ * Send a http request.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @param data - For POST methods specify a pointer to the post data, otherwise pass NULL
+ * @param datasize - For POST methods specify the size of the post data, otherwise pass 0
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSendRequest(int requestid, void *data, unsigned int datasize);
+
+/**
+ * Abort a http request.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpAbortRequest(int requestid);
+
+/**
+ * Read a http request response.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @param data - Buffer for the response data to be stored
+ * @param datasize - Size of the buffer 
+ * @return The size read into the data buffer, 0 if there is no more data, < 0 on error.
+ */
+int sceHttpReadData(int requestid, void *data, unsigned int datasize);
+
+/**
+ * Get http request response length.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @param contentlength - The size of the content
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpGetContentLength(int requestid, SceULong64 *contentlength);
+
+/**
+ * Get http request status code.
+ *
+ * @param requestid - ID of the request created by sceHttpCreateRequest or sceHttpCreateRequestWithURL
+ * @param statuscode - The status code from the host (200 is ok, 404 is not found etc)
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpGetStatusCode(int requestid, int *statuscode);
+
+/**
+ * Set resolver timeout
+ *
+ * @param id - ID of the template or connection 
+ * @param timeout - Timeout value in microseconds
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSetResolveTimeOut(int id, unsigned int timeout);
+
+/**
+ * Set resolver retry
+ *
+ * @param id - ID of the template or connection 
+ * @param count - Number of retries
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSetResolveRetry(int id, int count);
+
+/**
+ * Set connect timeout
+ *
+ * @param id - ID of the template, connection or request 
+ * @param timeout - Timeout value in microseconds
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSetConnectTimeOut(int id, unsigned int timeout);
+
+/**
+ * Set send timeout
+ *
+ * @param id - ID of the template, connection or request 
+ * @param timeout - Timeout value in microseconds
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSetSendTimeOut(int id, unsigned int timeout);
+
+/**
+ * Set receive timeout
+ *
+ * @param id - ID of the template or connection 
+ * @param timeout - Timeout value in microseconds
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSetRecvTimeOut(int id, unsigned int timeout);
+
+/**
+ * Enable keep alive
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpEnableKeepAlive(int id);
+
+/**
+ * Disable keep alive
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDisableKeepAlive(int id);
+
+/**
+ * Enable redirect
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpEnableRedirect(int id);
+
+/**
+ * Disable redirect
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDisableRedirect(int id);
+
+/**
+ * Enable cookie
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpEnableCookie(int id);
+
+/**
+ * Disable cookie
+ *
+ * @param id - ID of the template or connection 
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDisableCookie(int id);
+
+/**
+ * Save cookie
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpSaveSystemCookie(void);
+
+/**
+ * Load cookie
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpLoadSystemCookie(void);
+
+/**
+ * Add content header
+ *
+ * @param id - ID of the template, connection or request 
+ * @param name - Name of the content
+ * @param value - Value of the content
+ * @param unknown1 - Pass 0
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpAddExtraHeader(int id, char *name, char *value, int unknown1);
+
+/**
+ * Delete content header
+ *
+ * @param id - ID of the template, connection or request 
+ * @param name - Name of the content
+ * @return 0 on success, < 0 on error.
+ */
+int sceHttpDeleteHeader(int id, const char *name);
+
+/**
+ * Init the https library.
+ *
+ * @param unknown1 - Pass 0
+ * @param unknown2 - Pass 0
+ * @param unknown3 - Pass 0
+ * @param unknown4 - Pass 0
+ *
+ * @return 0 on success, < 0 on error.
+*/
+int sceHttpsInit(int unknown1, int unknown2, int unknown3, int unknown4);
+
+/**
+ * Terminate the https library
+ *
+ * @return 0 on success, < 0 on error.
+*/
+int sceHttpsEnd(void);
+
+/**
+ * Load default certificate
+ *
+ * @param unknown1 - Pass 0
+ * @param unknown2 - Pass 0
+ * @return 0 on success, < 0 on error.
+*/
+int sceHttpsLoadDefaultCert(int unknown1, int unknown2);
+
+int sceHttpDisableAuth(int id);
+
+int sceHttpDisableCache(int id);
+
+int sceHttpEnableAuth(int id);
+
+int sceHttpEnableCache(int id);
+
+int sceHttpEndCache(void);
+
+int sceHttpGetAllHeader(int request, unsigned char **header, unsigned int *header_size);
+
+int sceHttpGetNetworkErrno(int request, int *err_num);
+
+int sceHttpGetProxy(int id, int *activate_flag, int *mode, unsigned char *proxy_host, SceSize len, unsigned short *proxy_port);
+
+int sceHttpInitCache(SceSize max_size);
+
+int sceHttpSetAuthInfoCB(int id, PspHttpPasswordCB cbfunc);
+
+int sceHttpSetProxy(int id, int activate_flag, int mode, const unsigned char *new_proxy_host, unsigned short new_proxy_port);
+
+int sceHttpSetResHeaderMaxSize(int id, unsigned int header_size);
+
+int sceHttpSetMallocFunction(PspHttpMallocFunction malloc_func, PspHttpFreeFunction free_func, PspHttpReallocFunction realloc_func);
+
+#if defined(__cplusplus)
+};
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspidstorage.h b/newlib/psp/include/pspidstorage.h
new file mode 100644
index 0000000..fe2be01
--- /dev/null
+++ b/newlib/psp/include/pspidstorage.h
@@ -0,0 +1,59 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspidstorage.h - Interface to sceIdstorage_driver.
+ *
+ * Copyright (c) 2006 Harley G. <harleyg@0x89.org>
+ *
+ */
+
+#ifndef PSPIDSTORAGE_H
+#define PSPIDSTORAGE_H
+
+#include <psptypes.h>
+
+/** @defgroup IdStorage Interface to the sceIdStorage_driver library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup IdStorage Interface to the sceIdStorage_driver library.*/
+/**@{*/
+
+/**Retrieves the value associated with a key
+ * @param key    - idstorage key
+ * @param offset - offset within the 512 byte leaf
+ * @param buf    - buffer with enough storage
+ * @param len    - amount of data to retrieve (offset + len must be <= 512 bytes)
+ */
+int sceIdStorageLookup(u16 key, u32 offset, void *buf, u32 len);
+
+/** Retrieves the whole 512 byte container for the key
+ * @param key - idstorage key
+ * @param buf - buffer with at last 512 bytes of storage
+ */
+int sceIdStorageReadLeaf(u16 key, void *buf);
+
+/** sceIdStorageWriteLeaf() - Writes 512-bytes to idstorage key
+ * @param key - idstorage key
+ * @param buf - buffer with 512-btes of data
+ */
+int sceIdStorageWriteLeaf(u16 key, void *buf);
+
+/** sceIdStorageIsReadOnly() - Checks idstorage for readonly status */
+int sceIdStorageIsReadOnly(void);
+
+/** sceIdStorageFlush() - Finalizes a write */
+int sceIdStorageFlush(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspimport.s b/newlib/psp/include/pspimport.s
new file mode 100644
index 0000000..6dffc4b
--- /dev/null
+++ b/newlib/psp/include/pspimport.s
@@ -0,0 +1,68 @@
+
+.macro IMPORT_START module, flags_ver
+
+	.set push
+	.section .rodata.sceResident, "a"
+	.word   0
+__stub_modulestr_\module:
+	.asciz  "\module"
+	.align  2
+
+	.section .lib.stub, "a", @progbits
+	.global __stub_module_\module
+__stub_module_\module:
+	.word   __stub_modulestr_\module
+	.word   \flags_ver
+	.word   0x5
+	.word   __executable_start
+	.word   __executable_start
+
+	.set pop
+.endm
+
+.macro IMPORT_FUNC module, funcid, funcname
+
+	.set push
+	.set noreorder
+
+	.extern __stub_module_\module
+	.section .sceStub.text, "ax", @progbits
+	.globl  \funcname
+	.type   \funcname, @function
+	.ent    \funcname, 0
+\funcname:
+	.word   __stub_module_\module
+	.word   \funcid
+	.end    \funcname
+	.size   \funcname, .-\funcname
+
+	.section .rodata.sceNid, "a"
+	.word   \funcid
+
+	.set pop
+.endm
+
+.macro IMPORT_FUNC_WITH_ALIAS module, funcid, funcname, alias
+
+	.set push
+	.set noreorder
+
+	.extern __stub_module_\module
+	.section .sceStub.text, "ax", @progbits
+	.globl  \alias
+	.type   \alias, @function
+\alias:
+	.globl  \funcname
+	.type   \funcname, @function
+	.ent    \funcname, 0
+\funcname:
+	.word   __stub_module_\module
+	.word   \funcid
+	.end    \funcname
+	.size   \funcname, .-\funcname
+
+	.section .rodata.sceNid, "a"
+	.word   \funcid
+
+	.set pop
+.endm
diff --git a/newlib/psp/include/pspimpose_driver.h b/newlib/psp/include/pspimpose_driver.h
new file mode 100644
index 0000000..08c8cad
--- /dev/null
+++ b/newlib/psp/include/pspimpose_driver.h
@@ -0,0 +1,141 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspimpose_driver.h - Prototypes for the sceImpose_driver library.
+ *
+ * Copyright (c) 2007 Iaroslav Gaponenko <adrahil@gmail.com>
+ *
+ */
+
+#ifndef __IMPOSE_DRIVER_H__
+#define __IMPOSE_DRIVER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int SceImposeParam;
+
+/**
+ * These values have been found in the 3.52 kernel. 
+ * Therefore, they might not be supported by previous ones.
+ */
+
+#define PSP_IMPOSE_MAIN_VOLUME			0x1
+#define PSP_IMPOSE_BACKLIGHT_BRIGHTNESS		0x2
+#define PSP_IMPOSE_EQUALIZER_MODE		0x4
+#define PSP_IMPOSE_MUTE				0x8
+#define PSP_IMPOSE_AVLS				0x10
+#define PSP_IMPOSE_TIME_FORMAT			0x20
+#define PSP_IMPOSE_DATE_FORMAT			0x40
+#define PSP_IMPOSE_LANGUAGE			0x80
+#define PSP_IMPOSE_BACKLIGHT_OFF_INTERVAL	0x200
+#define PSP_IMPOSE_SOUND_REDUCTION		0x400
+
+#define PSP_IMPOSE_UMD_POPUP_ENABLED 1
+#define PSP_IMPOSE_UMD_POPUP_DISABLED 0
+
+/**
+ * Fetch the value of an Impose parameter.
+ *
+ * @return value of the parameter on success, < 0 on error
+ */
+int sceImposeGetParam(SceImposeParam param);
+
+/**
+ * Change the value of an Impose parameter.
+ *
+ * @param param - The parameter to change.
+ * @param value - The value to set the parameter to.
+ * @return < 0 on error
+ *
+ */
+int sceImposeSetParam(SceImposeParam param, int value);
+
+/**
+ * Get the value of the backlight timer.
+ *
+ * @return backlight timer in seconds or < 0 on error
+ *
+ */
+int sceImposeGetBacklightOffTime(void); 
+
+/**
+ * Set the value of the backlight timer.
+ *
+ * @param value - The backlight timer. (30 to a lot of seconds)
+ * @return < 0 on error
+ *
+ */
+int sceImposeSetBacklightOffTime(int value); 
+
+/**
+ * Get the language and button assignment parameters
+ *
+ * @return < 0 on error
+ *
+ */
+int sceImposeGetLanguageMode(int* lang, int* button); 
+
+/**
+ * Set the language and button assignment parameters
+ *
+ * /!\ parameter values not known.
+ *
+ * @param lang - Language
+ * @param button - Button assignment
+ * @return < 0 on error
+ *
+ */
+int sceImposeSetLanguageMode(int lang, int button); 
+
+/**
+ * Get the value of the UMD popup. 
+ *
+ * @return umd popup state or < 0 on error
+ *
+ */
+int sceImposeGetUMDPopup(void); 
+
+/**
+ * Set the value of the UMD popup. 
+ *
+ * @param value - The popup mode.
+ * @return < 0 on error
+ *
+ */
+int sceImposeSetUMDPopup(int value); 
+
+/**
+ * Get the value of the Home popup. 
+ *
+ * @return home popup state or < 0 on error
+ *
+ */
+int sceImposeGetHomePopup(void); 
+
+/**
+ * Set the value of the Home popup. 
+ *
+ * @param value - The popup mode.
+ * @return < 0 on error
+ *
+ */
+int sceImposeSetHomePopup(int value); 
+
+/**
+ * Check the video out. (for psp slim?)
+ *
+ * @param value - video out mode/status(?)
+ * @return < 0 on error
+ *
+ */
+int sceImposeCheckVideoOut(int* value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspinit.h b/newlib/psp/include/pspinit.h
new file mode 100644
index 0000000..d0715c6
--- /dev/null
+++ b/newlib/psp/include/pspinit.h
@@ -0,0 +1,73 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspinit.h - Interface to InitForKernel.
+ *
+ * Copyright (c) 2007 moonlight
+ *
+ */
+#ifndef __PSPINIT_H__
+#define __PSPINIT_H__
+
+enum PSPBootFrom
+{
+	PSP_BOOT_FLASH = 0, /* ? */
+	PSP_BOOT_DISC = 0x20,
+	PSP_BOOT_MS = 0x40,
+};
+
+enum PSPInitApitype
+{
+	PSP_INIT_APITYPE_DISC = 0x120,
+	PSP_INIT_APITYPE_DISC_UPDATER = 0x121,
+	PSP_INIT_APITYPE_MS1 = 0x140,
+	PSP_INIT_APITYPE_MS2 = 0x141,
+	PSP_INIT_APITYPE_MS3 = 0x142,
+	PSP_INIT_APITYPE_MS4 = 0x143,
+	PSP_INIT_APITYPE_MS5 = 0x144,
+	PSP_INIT_APITYPE_VSH1 = 0x210, /* ExitGame */
+	PSP_INIT_APITYPE_VSH2 = 0x220, /* ExitVSH */
+};
+
+enum PSPKeyConfig
+{
+	PSP_INIT_KEYCONFIG_VSH = 0x100,
+	PSP_INIT_KEYCONFIG_GAME = 0x200,
+	PSP_INIT_KEYCONFIG_POPS = 0x300,
+};
+
+/**
+ * Gets the api type 
+ *
+ * @return the api type in which the system has booted
+*/
+int sceKernelInitApitype();
+
+/**
+ * Gets the filename of the executable to be launched after all modules of the api.
+ *
+ * @return filename of executable or NULL if no executable found.
+*/
+char *sceKernelInitFileName();
+
+/**
+ *
+ * Gets the device in which the application was launched.
+ *
+ * @return the device code, one of PSPBootFrom values.
+*/
+int sceKernelBootFrom();
+
+/**
+ * Get the key configuration in which the system has booted.
+ *
+ * @return the key configuration code, one of PSPKeyConfig values 
+*/
+int InitForKernel_7233B5BC();
+
+#define sceKernelInitKeyConfig InitForKernel_7233B5BC
+
+#endif
+
diff --git a/newlib/psp/include/pspintrman.h b/newlib/psp/include/pspintrman.h
new file mode 100644
index 0000000..de7179a
--- /dev/null
+++ b/newlib/psp/include/pspintrman.h
@@ -0,0 +1,177 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspintrman.h - Interface to the system interrupt manager.
+ *
+ * Copyright (c) 2005 James F. (tyranid@gmail.com)
+ * Copyright (c) 2005 Florin Sasu (...)
+ *
+ */
+
+#ifndef PSPINTRMAN_H
+#define PSPINTRMAN_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup IntrMan Interrupt Manager
+  * This module contains routines to manage interrupts.
+  */
+
+/** @addtogroup IntrMan Interrupt Manager */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern const char* PspInterruptNames[67];
+
+enum PspInterrupts
+{
+	PSP_GPIO_INT = 4,
+	PSP_ATA_INT  = 5,
+	PSP_UMD_INT  = 6,
+	PSP_MSCM0_INT = 7,
+	PSP_WLAN_INT  = 8,
+	PSP_AUDIO_INT = 10,
+	PSP_I2C_INT   = 12,
+	PSP_SIRCS_INT = 14,
+	PSP_SYSTIMER0_INT = 15,
+	PSP_SYSTIMER1_INT = 16,
+	PSP_SYSTIMER2_INT = 17,
+	PSP_SYSTIMER3_INT = 18,
+	PSP_THREAD0_INT   = 19,
+	PSP_NAND_INT      = 20,
+	PSP_DMACPLUS_INT  = 21,
+	PSP_DMA0_INT      = 22,
+	PSP_DMA1_INT      = 23,
+	PSP_MEMLMD_INT    = 24,
+	PSP_GE_INT        = 25,
+	PSP_VBLANK_INT = 30,
+	PSP_MECODEC_INT  = 31,
+	PSP_HPREMOTE_INT = 36,
+	PSP_MSCM1_INT    = 60,
+	PSP_MSCM2_INT    = 61,
+	PSP_THREAD1_INT  = 65,
+	PSP_INTERRUPT_INT = 66
+};
+
+enum PspSubInterrupts
+{
+	PSP_GPIO_SUBINT = PSP_GPIO_INT,
+	PSP_ATA_SUBINT  = PSP_ATA_INT,
+	PSP_UMD_SUBINT  = PSP_UMD_INT,
+	PSP_DMACPLUS_SUBINT = PSP_DMACPLUS_INT,
+	PSP_GE_SUBINT = PSP_GE_INT,
+	PSP_DISPLAY_SUBINT = PSP_VBLANK_INT
+};
+
+/**
+ * Suspend all interrupts.
+ *
+ * @return The current state of the interrupt controller, to be used with ::sceKernelCpuResumeIntr().
+ */
+unsigned int sceKernelCpuSuspendIntr(void);
+
+/**
+ * Resume all interrupts.
+ *
+ * @param flags - The value returned from ::sceKernelCpuSuspendIntr().
+ */
+void sceKernelCpuResumeIntr(unsigned int flags);
+
+/**
+ * Resume all interrupts (using sync instructions).
+ *
+ * @param flags - The value returned from ::sceKernelCpuSuspendIntr()
+ */
+void sceKernelCpuResumeIntrWithSync(unsigned int flags);
+
+/**
+ * Determine if interrupts are suspended or active, based on the given flags.
+ *
+ * @param flags - The value returned from ::sceKernelCpuSuspendIntr().
+ *
+ * @return 1 if flags indicate that interrupts were not suspended, 0 otherwise.
+ */
+int sceKernelIsCpuIntrSuspended(unsigned int flags);
+
+/**
+ * Determine if interrupts are enabled or disabled.
+ *
+ * @return 1 if interrupts are currently enabled.
+ */
+int sceKernelIsCpuIntrEnable(void);
+
+/** 
+  * Register a sub interrupt handler.
+  * 
+  * @param intno - The interrupt number to register.
+  * @param no - The sub interrupt handler number (user controlled)
+  * @param handler - The interrupt handler
+  * @param arg - An argument passed to the interrupt handler
+  *
+  * @return < 0 on error.
+  */
+int sceKernelRegisterSubIntrHandler(int intno, int no, void *handler, void *arg);
+
+/**
+  * Release a sub interrupt handler.
+  * 
+  * @param intno - The interrupt number to register.
+  * @param no - The sub interrupt handler number
+  *
+  * @return < 0 on error.
+  */
+int sceKernelReleaseSubIntrHandler(int intno, int no);
+
+/**
+  * Enable a sub interrupt.
+  * 
+  * @param intno - The sub interrupt to enable.
+  * @param no - The sub interrupt handler number
+  * 
+  * @return < 0 on error.
+  */
+int sceKernelEnableSubIntr(int intno, int no);
+
+/**
+  * Disable a sub interrupt handler.
+  *
+  * @param intno - The sub interrupt to disable.
+  * @param no - The sub interrupt handler number
+  * 
+  * @return < 0 on error.
+  */
+int sceKernelDisableSubIntr(int intno, int no);
+
+typedef struct tag_IntrHandlerOptionParam{
+	int size;				//+00
+	u32	entry;				//+04
+	u32	common;				//+08
+	u32	gp;					//+0C
+	u16	intr_code;			//+10
+	u16	sub_count;			//+12
+	u16	intr_level;			//+14
+	u16	enabled;			//+16
+	u32	calls;				//+18
+	u32	field_1C;			//+1C
+	u32	total_clock_lo;		//+20
+	u32	total_clock_hi;		//+24
+	u32	min_clock_lo;		//+28
+	u32	min_clock_hi;		//+2C
+	u32	max_clock_lo;		//+30
+	u32	max_clock_hi;		//+34
+} PspIntrHandlerOptionParam;	//=38
+
+int QueryIntrHandlerInfo(SceUID intr_code, SceUID sub_intr_code, PspIntrHandlerOptionParam *data);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* PSPINTRMAN_H */
diff --git a/newlib/psp/include/pspintrman_kernel.h b/newlib/psp/include/pspintrman_kernel.h
new file mode 100644
index 0000000..5eacc32
--- /dev/null
+++ b/newlib/psp/include/pspintrman_kernel.h
@@ -0,0 +1,81 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspintrman_kernel.h - Interface to the system interrupt manager.
+ *
+ * Copyright (c) 2005 James F. (tyranid@gmail.com)
+ *
+ */
+
+#ifndef PSPINTRMAN_KERNEL_H
+#define PSPINTRMAN_KERNEL_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup IntrManKern Interrupt Manager Kernel
+  * This module contains routines to manage interrupts.
+  */
+
+/** @addtogroup IntrManKern Interrupt Manager Kernel */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  * Register an interrupt handler.
+  * 
+  * @param intno - The interrupt number to register.
+  * @param no    - The queue number.
+  * @param handler - Pointer to the handler.
+  * @param arg1    - Unknown (probably a set of flags)
+  * @param arg2    - Unknown (probably a common pointer)
+  *
+  * @return 0 on success.
+  */
+int sceKernelRegisterIntrHandler(int intno, int no, void *handler, void *arg1, void *arg2);
+
+/**
+ * Release an interrupt handler
+ *
+ * @param intno - The interrupt number to release
+ *
+ * @return 0 on success
+ */
+int sceKernelReleaseIntrHandler(int intno);
+
+/**
+  * Enable an interrupt.
+  * 
+  * @param intno - Interrupt to enable.
+  *
+  * @return 0 on success.
+  */
+int sceKernelEnableIntr(int intno);
+
+/**
+  * Disable an interrupt.
+  * 
+  * @param intno - Interrupt to disable.
+  *
+  * @return 0 on success.
+  */
+int sceKernelDisableIntr(int intno);
+
+/**
+ * Check if we are in an interrupt context or not
+ *
+ * @return 1 if we are in an interrupt context, else 0
+ */
+int sceKernelIsIntrContext(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* PSPINTRMAN_KERNEL_H */
diff --git a/newlib/psp/include/pspiofilemgr.h b/newlib/psp/include/pspiofilemgr.h
new file mode 100644
index 0000000..95b1a37
--- /dev/null
+++ b/newlib/psp/include/pspiofilemgr.h
@@ -0,0 +1,476 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspiofilemgr.h - Prototypes for the sceIo library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __FILEIO_H__
+#define __FILEIO_H__
+
+#include <pspkerneltypes.h>
+#include <pspiofilemgr_fcntl.h>
+#include <pspiofilemgr_stat.h>
+#include <pspiofilemgr_dirent.h>
+
+/** @defgroup FileIO File IO Library 
+ *  This module contains the imports for the kernel's IO routines.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup FileIO File IO Library */
+/**@{*/
+
+/** Permission value for the sceIoAssign function */
+enum IoAssignPerms
+{
+	/** Assign the device read/write */
+	IOASSIGN_RDWR = 0,
+	/** Assign the device read only */
+	IOASSIGN_RDONLY = 1
+};
+
+/**
+ * Open or create a file for reading or writing
+ *
+ * @par Example1: Open a file for reading
+ * @code
+ * if(!(fd = sceIoOpen("device:/path/to/file", O_RDONLY, 0777)) {
+ *	// error
+ * }
+ * @endcode
+ * @par Example2: Open a file for writing, creating it if it doesnt exist
+ * @code
+ * if(!(fd = sceIoOpen("device:/path/to/file", O_WRONLY|O_CREAT, 0777)) {
+ *	// error
+ * }
+ * @endcode
+ *
+ * @param file - Pointer to a string holding the name of the file to open
+ * @param flags - Libc styled flags that are or'ed together
+ * @param mode - File access mode.
+ * @return A non-negative integer is a valid fd, anything else an error
+ */
+SceUID sceIoOpen(const char *file, int flags, SceMode mode);
+
+/**
+ * Open or create a file for reading or writing (asynchronous)
+ *
+ * @param file - Pointer to a string holding the name of the file to open
+ * @param flags - Libc styled flags that are or'ed together
+ * @param mode - File access mode.
+ * @return A non-negative integer is a valid fd, anything else an error
+ */
+SceUID sceIoOpenAsync(const char *file, int flags, SceMode mode);
+
+/**
+ * Delete a descriptor
+ *
+ * @code
+ * sceIoClose(fd);
+ * @endcode
+ *
+ * @param fd - File descriptor to close
+ * @return < 0 on error
+ */
+int sceIoClose(SceUID fd);
+
+/**
+ * Delete a descriptor (asynchronous)
+ *
+ * @param fd - File descriptor to close
+ * @return < 0 on error
+ */
+int sceIoCloseAsync(SceUID fd);
+
+/**
+ * Read input
+ *
+ * @par Example:
+ * @code
+ * bytes_read = sceIoRead(fd, data, 100);
+ * @endcode
+ *
+ * @param fd - Opened file descriptor to read from
+ * @param data - Pointer to the buffer where the read data will be placed
+ * @param size - Size of the read in bytes
+ * 
+ * @return The number of bytes read
+ */
+int sceIoRead(SceUID fd, void *data, SceSize size);
+
+/**
+ * Read input (asynchronous)
+ *
+ * @par Example:
+ * @code
+ * bytes_read = sceIoRead(fd, data, 100);
+ * @endcode
+ *
+ * @param fd - Opened file descriptor to read from
+ * @param data - Pointer to the buffer where the read data will be placed
+ * @param size - Size of the read in bytes
+ * 
+ * @return < 0 on error.
+ */
+int sceIoReadAsync(SceUID fd, void *data, SceSize size);
+
+/**
+ * Write output
+ *
+ * @par Example:
+ * @code
+ * bytes_written = sceIoWrite(fd, data, 100);
+ * @endcode
+ *
+ * @param fd - Opened file descriptor to write to
+ * @param data - Pointer to the data to write
+ * @param size - Size of data to write
+ *
+ * @return The number of bytes written
+ */
+int sceIoWrite(SceUID fd, const void *data, SceSize size);
+
+/**
+ * Write output (asynchronous)
+ *
+ * @param fd - Opened file descriptor to write to
+ * @param data - Pointer to the data to write
+ * @param size - Size of data to write
+ *
+ * @return < 0 on error.
+ */
+int sceIoWriteAsync(SceUID fd, const void *data, SceSize size);
+
+/**
+ * Reposition read/write file descriptor offset
+ *
+ * @par Example:
+ * @code
+ * pos = sceIoLseek(fd, -10, SEEK_END);
+ * @endcode
+ *
+ * @param fd - Opened file descriptor with which to seek
+ * @param offset - Relative offset from the start position given by whence
+ * @param whence - Set to SEEK_SET to seek from the start of the file, SEEK_CUR
+ * seek from the current position and SEEK_END to seek from the end.
+ *
+ * @return The position in the file after the seek. 
+ */
+SceOff sceIoLseek(SceUID fd, SceOff offset, int whence);
+
+/**
+ * Reposition read/write file descriptor offset (asynchronous)
+ *
+ * @param fd - Opened file descriptor with which to seek
+ * @param offset - Relative offset from the start position given by whence
+ * @param whence - Set to SEEK_SET to seek from the start of the file, SEEK_CUR
+ * seek from the current position and SEEK_END to seek from the end.
+ *
+ * @return < 0 on error. Actual value should be passed returned by the ::sceIoWaitAsync call.
+ */
+int sceIoLseekAsync(SceUID fd, SceOff offset, int whence);
+
+/**
+ * Reposition read/write file descriptor offset (32bit mode)
+ *
+ * @par Example:
+ * @code
+ * pos = sceIoLseek32(fd, -10, SEEK_END);
+ * @endcode
+ *
+ * @param fd - Opened file descriptor with which to seek
+ * @param offset - Relative offset from the start position given by whence
+ * @param whence - Set to SEEK_SET to seek from the start of the file, SEEK_CUR
+ * seek from the current position and SEEK_END to seek from the end.
+ *
+ * @return The position in the file after the seek. 
+ */
+int sceIoLseek32(SceUID fd, int offset, int whence);
+
+/**
+ * Reposition read/write file descriptor offset (32bit mode, asynchronous)
+ *
+ * @param fd - Opened file descriptor with which to seek
+ * @param offset - Relative offset from the start position given by whence
+ * @param whence - Set to SEEK_SET to seek from the start of the file, SEEK_CUR
+ * seek from the current position and SEEK_END to seek from the end.
+ *
+ * @return < 0 on error.
+ */
+int sceIoLseek32Async(SceUID fd, int offset, int whence);
+
+/**
+ * Remove directory entry
+ *
+ * @param file - Path to the file to remove
+ * @return < 0 on error
+ */
+int sceIoRemove(const char *file);
+
+/**
+ * Make a directory file
+ *
+ * @param dir
+ * @param mode - Access mode.
+ * @return Returns the value 0 if its succesful otherwise -1
+ */
+int sceIoMkdir(const char *dir, SceMode mode);
+
+/**
+ * Remove a directory file
+ *
+ * @param path - Removes a directory file pointed by the string path
+ * @return Returns the value 0 if its succesful otherwise -1
+ */
+int sceIoRmdir(const char *path);
+
+/**
+  * Change the current directory.
+  *
+  * @param path - The path to change to.
+  * @return < 0 on error.
+  */
+int sceIoChdir(const char *path);
+
+/**
+ * Change the name of a file
+ *
+ * @param oldname - The old filename
+ * @param newname - The new filename
+ * @return < 0 on error.
+ */
+int sceIoRename(const char *oldname, const char *newname);
+
+/**
+  * Open a directory
+  * 
+  * @par Example:
+  * @code
+  * int dfd;
+  * dfd = sceIoDopen("device:/");
+  * if(dfd >= 0)
+  * { Do something with the file descriptor }
+  * @endcode
+  * @param dirname - The directory to open for reading.
+  * @return If >= 0 then a valid file descriptor, otherwise a Sony error code.
+  */
+SceUID sceIoDopen(const char *dirname);
+
+/** 
+  * Reads an entry from an opened file descriptor.
+  *
+  * @param fd - Already opened file descriptor (using sceIoDopen)
+  * @param dir - Pointer to an io_dirent_t structure to hold the file information
+  *
+  * @return Read status
+  * -   0 - No more directory entries left
+  * - > 0 - More directory entired to go
+  * - < 0 - Error
+  */
+int sceIoDread(SceUID fd, SceIoDirent *dir);
+
+/**
+  * Close an opened directory file descriptor
+  *
+  * @param fd - Already opened file descriptor (using sceIoDopen)
+  * @return < 0 on error
+  */
+int sceIoDclose(SceUID fd);
+
+/** 
+  * Send a devctl command to a device.
+  *
+  * @par Example: Sending a simple command to a device (not a real devctl)
+  * @code
+  * sceIoDevctl("ms0:", 0x200000, indata, 4, NULL, NULL); 
+  * @endcode
+  *
+  * @param dev - String for the device to send the devctl to (e.g. "ms0:")
+  * @param cmd - The command to send to the device
+  * @param indata - A data block to send to the device, if NULL sends no data
+  * @param inlen - Length of indata, if 0 sends no data
+  * @param outdata - A data block to receive the result of a command, if NULL receives no data
+  * @param outlen - Length of outdata, if 0 receives no data
+  * @return 0 on success, < 0 on error
+  */
+int sceIoDevctl(const char *dev, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen);
+
+/** 
+  * Assigns one IO device to another (I guess)
+  * @param dev1 - The device name to assign.
+  * @param dev2 - The block device to assign from.
+  * @param dev3 - The filesystem device to mape the block device to dev1
+  * @param mode - Read/Write mode. One of IoAssignPerms.
+  * @param unk1 - Unknown, set to NULL.
+  * @param unk2 - Unknown, set to 0.
+  * @return < 0 on error.
+  *
+  * @par Example: Reassign flash0 in read/write mode.
+  * @code 
+  *	sceIoUnassign("flash0");
+  * sceIoAssign("flash0", "lflash0:0,0", "flashfat0:", IOASSIGN_RDWR, NULL, 0);
+  * @endcode
+  * 
+  */
+int sceIoAssign(const char *dev1, const char *dev2, const char *dev3, int mode, void* unk1, long unk2);
+
+/** 
+  * Unassign an IO device.
+  * @param dev - The device to unassign.
+  * @return < 0 on error
+  *
+  * @par Example: See ::sceIoAssign
+  */
+int sceIoUnassign(const char *dev);
+
+/** 
+  * Get the status of a file.
+  * 
+  * @param file - The path to the file.
+  * @param stat - A pointer to an io_stat_t structure.
+  * 
+  * @return < 0 on error.
+  */
+int sceIoGetstat(const char *file, SceIoStat *stat);
+
+/** 
+  * Change the status of a file.
+  *
+  * @param file - The path to the file.
+  * @param stat - A pointer to an io_stat_t structure.
+  * @param bits - Bitmask defining which bits to change.
+  *
+  * @return < 0 on error.
+  */
+int sceIoChstat(const char *file, SceIoStat *stat, int bits);
+
+/**
+  * Perform an ioctl on a device.
+  *
+  * @param fd - Opened file descriptor to ioctl to
+  * @param cmd - The command to send to the device
+  * @param indata - A data block to send to the device, if NULL sends no data
+  * @param inlen - Length of indata, if 0 sends no data
+  * @param outdata - A data block to receive the result of a command, if NULL receives no data
+  * @param outlen - Length of outdata, if 0 receives no data
+  * @return 0 on success, < 0 on error
+  */
+int sceIoIoctl(SceUID fd, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen);
+
+/**
+  * Perform an ioctl on a device. (asynchronous)
+  *
+  * @param fd - Opened file descriptor to ioctl to
+  * @param cmd - The command to send to the device
+  * @param indata - A data block to send to the device, if NULL sends no data
+  * @param inlen - Length of indata, if 0 sends no data
+  * @param outdata - A data block to receive the result of a command, if NULL receives no data
+  * @param outlen - Length of outdata, if 0 receives no data
+  * @return 0 on success, < 0 on error
+  */
+int sceIoIoctlAsync(SceUID fd, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen);
+
+/**
+  * Synchronise the file data on the device.
+  *
+  * @param device - The device to synchronise (e.g. msfat0:)
+  * @param unk - Unknown
+  */
+int sceIoSync(const char *device, unsigned int unk);
+
+/**
+  * Wait for asyncronous completion.
+  * 
+  * @param fd - The file descriptor which is current performing an asynchronous action.
+  * @param res - The result of the async action.
+  *
+  * @return < 0 on error.
+  */
+int sceIoWaitAsync(SceUID fd, SceInt64 *res);
+
+/**
+  * Wait for asyncronous completion (with callbacks).
+  * 
+  * @param fd - The file descriptor which is current performing an asynchronous action.
+  * @param res - The result of the async action.
+  *
+  * @return < 0 on error.
+  */
+int sceIoWaitAsyncCB(SceUID fd, SceInt64 *res);
+
+/**
+  * Poll for asyncronous completion.
+  * 
+  * @param fd - The file descriptor which is current performing an asynchronous action.
+  * @param res - The result of the async action.
+  *
+  * @return < 0 on error.
+  */
+int sceIoPollAsync(SceUID fd, SceInt64 *res);
+
+/**
+  * Get the asyncronous completion status.
+  * 
+  * @param fd - The file descriptor which is current performing an asynchronous action.
+  * @param poll - If 0 then waits for the status, otherwise it polls the fd.
+  * @param res - The result of the async action.
+  *
+  * @return < 0 on error.
+  */
+int sceIoGetAsyncStat(SceUID fd, int poll, SceInt64 *res);
+
+/**
+  * Cancel an asynchronous operation on a file descriptor.
+  *
+  * @param fd - The file descriptor to perform cancel on.
+  *
+  * @return < 0 on error.
+  */
+int sceIoCancel(SceUID fd);
+
+/**
+  * Get the device type of the currently opened file descriptor.
+  *
+  * @param fd - The opened file descriptor.
+  *
+  * @return < 0 on error. Otherwise the device type?
+  */
+int sceIoGetDevType(SceUID fd);
+
+/**
+  * Change the priority of the asynchronous thread.
+  *
+  * @param fd - The opened fd on which the priority should be changed.
+  * @param pri - The priority of the thread.
+  *
+  * @return < 0 on error.
+  */
+int sceIoChangeAsyncPriority(SceUID fd, int pri);
+
+/**
+  * Sets a callback for the asynchronous action.
+  *
+  * @param fd - The filedescriptor currently performing an asynchronous action.
+  * @param cb - The UID of the callback created with ::sceKernelCreateCallback
+  * @param argp - Pointer to an argument to pass to the callback.
+  *
+  * @return < 0 on error.
+  */
+int sceIoSetAsyncCallback(SceUID fd, SceUID cb, void *argp);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspiofilemgr_dirent.h b/newlib/psp/include/pspiofilemgr_dirent.h
new file mode 100644
index 0000000..f1f9339
--- /dev/null
+++ b/newlib/psp/include/pspiofilemgr_dirent.h
@@ -0,0 +1,34 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspiofilemgr_dirent.h - File attributes and directory entries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef PSPIOFILEMGR_DIRENT_H
+#define PSPIOFILEMGR_DIRENT_H
+
+#include <pspiofilemgr_stat.h>
+
+/** Describes a single directory entry */
+typedef struct SceIoDirent {
+	/** File status. */
+	SceIoStat 	d_stat;
+	/** File name. */
+	char 		d_name[256];
+	/** Device-specific data. */
+	void * 		d_private;
+	int 		dummy;
+} SceIoDirent;
+
+#endif /* PSPIOFILEMGR_DIRENT_H */
diff --git a/newlib/psp/include/pspiofilemgr_fcntl.h b/newlib/psp/include/pspiofilemgr_fcntl.h
new file mode 100644
index 0000000..f729f37
--- /dev/null
+++ b/newlib/psp/include/pspiofilemgr_fcntl.h
@@ -0,0 +1,33 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspiofilemgr_fcntl.h - File control definitions.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef PSPIOFILEMGR_FCNTL_H
+#define PSPIOFILEMGR_FCNTL_H
+
+/* Note: Not all of these sceIoOpen() flags are not compatible with the
+   open() flags found in sys/unistd.h. */
+#define PSP_O_RDONLY	0x0001
+#define PSP_O_WRONLY	0x0002
+#define PSP_O_RDWR	(PSP_O_RDONLY | PSP_O_WRONLY)
+#define PSP_O_NBLOCK	0x0004
+#define PSP_O_DIR 	0x0008
+#define PSP_O_APPEND	0x0100
+#define PSP_O_CREAT	0x0200
+#define PSP_O_TRUNC	0x0400
+#define	PSP_O_EXCL	0x0800
+#define PSP_O_NOWAIT	0x8000
+
+#define PSP_SEEK_SET	0
+#define PSP_SEEK_CUR	1
+#define PSP_SEEK_END	2
+
+#endif /* PSPIOFILEMGR_FCNTL_H */
diff --git a/newlib/psp/include/pspiofilemgr_kernel.h b/newlib/psp/include/pspiofilemgr_kernel.h
new file mode 100644
index 0000000..f7e564c
--- /dev/null
+++ b/newlib/psp/include/pspiofilemgr_kernel.h
@@ -0,0 +1,165 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspiofilemgr_kernel.h - Interface to the kernel mode library for IoFileMgr.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPIOFILEMGR_KERNEL_H
+#define PSPIOFILEMGR_KERNEL_H
+
+#include <psptypes.h>
+#include <pspkerneltypes.h>
+#include <pspiofilemgr.h>
+
+/** @defgroup IoFileMgr_Kernel Driver interface to IoFileMgr
+ *  This module contains the imports for the kernel's IO routines.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup IoFileMgr_Kernel Driver interface to IoFileMgr */
+/**@{*/
+
+struct PspIoDrv;
+
+/** Structure passed to the init and exit functions of the io driver system */
+typedef struct PspIoDrvArg
+{
+	/** Pointer to the original driver which was added */
+	struct PspIoDrv *drv;
+	/** Pointer to a user defined argument (if written by the driver will preseve across calls */
+	void *arg;
+} PspIoDrvArg;
+
+/** Structure passed to the file functions of the io driver system */
+typedef struct PspIoDrvFileArg
+{
+	/** Unknown */
+	u32 unk1;
+	/** The file system number, e.g. if a file is opened as host5:/myfile.txt this field will be 5 */
+	u32 fs_num;
+	/** Pointer to the driver structure */
+	PspIoDrvArg *drv;
+	/** Unknown, again */
+	u32 unk2;
+	/** Pointer to a user defined argument, this is preserved on a per file basis */
+	void *arg;
+} PspIoDrvFileArg;
+
+/** Structure to maintain the file driver pointers */
+typedef struct PspIoDrvFuncs
+{
+	int (*IoInit)(PspIoDrvArg* arg);
+	int (*IoExit)(PspIoDrvArg* arg); 
+	int (*IoOpen)(PspIoDrvFileArg *arg, char *file, int flags, SceMode mode); 
+	int (*IoClose)(PspIoDrvFileArg *arg); 
+	int (*IoRead)(PspIoDrvFileArg *arg, char *data, int len); 
+	int (*IoWrite)(PspIoDrvFileArg *arg, const char *data, int len); 
+	SceOff (*IoLseek)(PspIoDrvFileArg *arg, SceOff ofs, int whence); 
+	int (*IoIoctl)(PspIoDrvFileArg *arg, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen);
+	int (*IoRemove)(PspIoDrvFileArg *arg, const char *name); 
+	int (*IoMkdir)(PspIoDrvFileArg *arg, const char *name, SceMode mode); 
+	int (*IoRmdir)(PspIoDrvFileArg *arg, const char *name);
+	int (*IoDopen)(PspIoDrvFileArg *arg, const char *dirname); 
+	int (*IoDclose)(PspIoDrvFileArg *arg);
+	int (*IoDread)(PspIoDrvFileArg *arg, SceIoDirent *dir);
+	int (*IoGetstat)(PspIoDrvFileArg *arg, const char *file, SceIoStat *stat);
+	int (*IoChstat)(PspIoDrvFileArg *arg, const char *file, SceIoStat *stat, int bits);
+	int (*IoRename)(PspIoDrvFileArg *arg, const char *oldname, const char *newname); 
+	int (*IoChdir)(PspIoDrvFileArg *arg, const char *dir); 
+	int (*IoMount)(PspIoDrvFileArg *arg); 
+	int (*IoUmount)(PspIoDrvFileArg *arg); 
+	int (*IoDevctl)(PspIoDrvFileArg *arg, const char *devname, unsigned int cmd, void *indata, int inlen, void *outdata, int outlen); 
+	int (*IoUnk21)(PspIoDrvFileArg *arg); 
+} PspIoDrvFuncs;
+
+typedef struct PspIoDrv
+{
+	/** The name of the device to add */
+	const char *name;
+	/** Device type, this 0x10 is for a filesystem driver */
+	u32 dev_type;
+	/** Unknown, set to 0x800 */
+	u32 unk2;
+	/** This seems to be the same as name but capitalised :/ */
+	const char *name2;
+	/** Pointer to a filled out functions table */
+	PspIoDrvFuncs *funcs;
+} PspIoDrv;
+
+/** 
+  * Adds a new IO driver to the system.
+  * @note This is only exported in the kernel version of IoFileMgr
+  * 
+  * @param drv - Pointer to a filled out driver structure
+  * @return < 0 on error.
+  *
+  * @par Example:
+  * @code
+  * PspIoDrvFuncs host_funcs = { ... };
+  * PspIoDrv host_driver = { "host", 0x10, 0x800, "HOST", &host_funcs };
+  * sceIoDelDrv("host");
+  * sceIoAddDrv(&host_driver);
+  * @endcode
+  */
+int sceIoAddDrv(PspIoDrv *drv);
+
+/**
+  * Deletes a IO driver from the system.
+  * @note This is only exported in the kernel version of IoFileMgr
+  *
+  * @param drv_name - Name of the driver to delete.
+  * @return < 0 on error
+  */
+int sceIoDelDrv(const char *drv_name);
+
+/**
+  * Reopens an existing file descriptor.
+  *
+  * @param file - The new file to open.
+  * @param flags - The open flags.
+  * @param mode - The open mode.
+  * @param fd - The old filedescriptor to reopen
+  *
+  * @return < 0 on error, otherwise the reopened fd.
+  */
+int sceIoReopen(const char *file, int flags, SceMode mode, SceUID fd);
+
+/**
+ * Get the current working directory for a thread.
+ *
+ * @param uid - The UID of the thread
+ * @param dir - A character buffer in which to store the cwd
+ * @param len - The length of the buffer
+ *
+ * @return Number of characters written to buf, if no cwd then 0 is 
+ * returned.
+ */
+int sceIoGetThreadCwd(SceUID uid, char *dir, int len);
+
+/**
+ * Set the current working directory for a thread
+ *
+ * @param uid - The UID of the thread
+ * @param dir - The directory to set
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceIoChangeThreadCwd(SceUID uid, char *dir);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPIOFILEMGR_KERNEL_H */
diff --git a/newlib/psp/include/pspiofilemgr_stat.h b/newlib/psp/include/pspiofilemgr_stat.h
new file mode 100644
index 0000000..738917a
--- /dev/null
+++ b/newlib/psp/include/pspiofilemgr_stat.h
@@ -0,0 +1,117 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspiofilemgr_dirent.h - File attributes and directory entries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef PSPIOFILEMGR_STAT_H
+#define PSPIOFILEMGR_STAT_H
+
+#include <psptypes.h>
+#include <pspkerneltypes.h>
+
+/** Access modes for st_mode in SceIoStat (confirm?). */
+enum IOAccessModes
+{
+	/** Format bits mask */
+	FIO_S_IFMT		= 0xF000,
+	/** Symbolic link */
+	FIO_S_IFLNK		= 0x4000,
+	/** Directory */
+	FIO_S_IFDIR		= 0x1000,
+	/** Regular file */
+	FIO_S_IFREG		= 0x2000,
+
+	/** Set UID */
+	FIO_S_ISUID		= 0x0800,
+	/** Set GID */
+	FIO_S_ISGID		= 0x0400,
+	/** Sticky */
+	FIO_S_ISVTX		= 0x0200,
+
+	/** User access rights mask */
+	FIO_S_IRWXU		= 0x01C0,	
+	/** Read user permission */
+	FIO_S_IRUSR		= 0x0100,
+	/** Write user permission */
+	FIO_S_IWUSR		= 0x0080,
+	/** Execute user permission */
+	FIO_S_IXUSR		= 0x0040,	
+
+	/** Group access rights mask */
+	FIO_S_IRWXG		= 0x0038,	
+	/** Group read permission */
+	FIO_S_IRGRP		= 0x0020,
+	/** Group write permission */
+	FIO_S_IWGRP		= 0x0010,
+	/** Group execute permission */
+	FIO_S_IXGRP		= 0x0008,
+
+	/** Others access rights mask */
+	FIO_S_IRWXO		= 0x0007,	
+	/** Others read permission */
+	FIO_S_IROTH		= 0x0004,	
+	/** Others write permission */
+	FIO_S_IWOTH		= 0x0002,	
+	/** Others execute permission */
+	FIO_S_IXOTH		= 0x0001,	
+};
+
+// File mode checking macros
+#define FIO_S_ISLNK(m)	(((m) & FIO_S_IFMT) == FIO_S_IFLNK)
+#define FIO_S_ISREG(m)	(((m) & FIO_S_IFMT) == FIO_S_IFREG)
+#define FIO_S_ISDIR(m)	(((m) & FIO_S_IFMT) == FIO_S_IFDIR)
+
+/** File modes, used for the st_attr parameter in SceIoStat (confirm?). */
+enum IOFileModes
+{
+	/** Format mask */
+	FIO_SO_IFMT			= 0x0038,		// Format mask
+	/** Symlink */
+	FIO_SO_IFLNK		= 0x0008,		// Symbolic link
+	/** Directory */
+	FIO_SO_IFDIR		= 0x0010,		// Directory
+	/** Regular file */
+	FIO_SO_IFREG		= 0x0020,		// Regular file
+
+	/** Hidden read permission */
+	FIO_SO_IROTH		= 0x0004,		// read
+	/** Hidden write permission */
+	FIO_SO_IWOTH		= 0x0002,		// write
+	/** Hidden execute permission */
+	FIO_SO_IXOTH		= 0x0001,		// execute
+};
+
+// File mode checking macros
+#define FIO_SO_ISLNK(m)	(((m) & FIO_SO_IFMT) == FIO_SO_IFLNK)
+#define FIO_SO_ISREG(m)	(((m) & FIO_SO_IFMT) == FIO_SO_IFREG)
+#define FIO_SO_ISDIR(m)	(((m) & FIO_SO_IFMT) == FIO_SO_IFDIR)
+
+/** Structure to hold the status information about a file */
+typedef struct SceIoStat {
+	SceMode 		st_mode;
+	unsigned int 	st_attr;
+	/** Size of the file in bytes. */
+	SceOff 			st_size;
+	/** Creation time. */
+	ScePspDateTime 	sce_st_ctime;
+	/** Access time. */
+	ScePspDateTime 	sce_st_atime;
+	/** Modification time. */
+	ScePspDateTime 	sce_st_mtime;
+	/** Device-specific data. */
+	unsigned int 	st_private[6];
+} SceIoStat;
+
+#endif /* PSPIOFILEMGR_STAT_H */
diff --git a/newlib/psp/include/pspjpeg.h b/newlib/psp/include/pspjpeg.h
new file mode 100644
index 0000000..614add4
--- /dev/null
+++ b/newlib/psp/include/pspjpeg.h
@@ -0,0 +1,68 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspjpeg.h - Prototypes for the sceJpeg library
+ *
+ * Copyright (c) 2007 dot_blank
+ *
+ */
+#ifndef __PSPJPEG_H__
+#define __PSPJPEG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/**
+ * Inits the MJpeg library 
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceJpegInitMJpeg(void);
+
+/**
+ * Finishes the MJpeg library
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceJpegFinishMJpeg(void);
+
+/**
+ * Creates the decoder context.
+ *
+ * @param width - The width of the frame
+ * @param height - The height of the frame
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceJpegCreateMJpeg(int width, int height);
+
+/**
+ * Deletes the current decoder context.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceJpegDeleteMJpeg(void);
+
+/**
+ * Decodes a mjpeg frame.
+ *
+ * @param jpegbuf - the buffer with the mjpeg frame
+ * @param size - size of the buffer pointed by jpegbuf
+ * @param rgba - buffer where the decoded data in RGBA format will be stored.
+ *				       It should have a size of (width * height * 4).
+ * @param unk - Unknown, pass 0
+ *
+ * @return (width * 65536) + height on success, < 0 on error 
+*/
+int sceJpegDecodeMJpeg(u8 *jpegbuf,	SceSize size, void *rgba, u32 unk);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspkdebug.h b/newlib/psp/include/pspkdebug.h
new file mode 100644
index 0000000..af97e03
--- /dev/null
+++ b/newlib/psp/include/pspkdebug.h
@@ -0,0 +1,58 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspkdebug.h - Interface to KDebugForKernel.
+ *
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ *
+ */
+
+#ifndef PSPKDEBUG_H
+#define PSPKDEBUG_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup Kdebug Interface to the KDebugForKernel library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Kdebug Interface to the KDebugForKernel library. */
+/**@{*/
+
+/** Typedef for the debug putcharacter handler */
+typedef void (*PspDebugPutChar)(unsigned short* args, unsigned int ch);
+
+/**
+ * Register a debug put character handler
+ *
+ * @param func - The put character function to register.
+ */
+void sceKernelRegisterDebugPutchar(PspDebugPutChar func);
+
+/**
+ * Get the debug put character handler
+ *
+ * @return The current debug putchar handler
+ */
+PspDebugPutChar sceKernelGetDebugPutchar(void);
+
+/**
+ * Kernel printf function.
+ *
+ * @param format - The format string.
+ * @param ... - Arguments for the format string.
+ */
+void Kprintf(const char *format, ...) __attribute__((format(printf, 1, 2)));
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspkernel.h b/newlib/psp/include/pspkernel.h
new file mode 100644
index 0000000..3db1c54
--- /dev/null
+++ b/newlib/psp/include/pspkernel.h
@@ -0,0 +1,71 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspkernel.h - Main include file that includes all major kernel headers.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPKERNEL_H
+#define PSPKERNEL_H
+
+#include <pspuser.h>
+#include <pspiofilemgr_kernel.h>
+#include <psploadcore.h>
+#include <pspstdio_kernel.h>
+#include <pspsysreg.h>
+#include <pspkdebug.h>
+#include <pspintrman_kernel.h>
+#include <pspmodulemgr_kernel.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Set the $pc register to a kernel memory address.
+ *
+ * When the PSP's kernel library stubs are called, they expect to be accessed
+ * from the kernel's address space.  Use this function to set $pc to the kernel
+ * address space, before calling a kernel library stub.
+ */
+#define pspKernelSetKernelPC()  \
+{     \
+	__asm__ volatile (      \
+	"la     $8, 1f\n\t"     \
+	"lui    $9, 0x8000\n\t" \
+	"or     $8, $9\n\t"     \
+	"jr     $8\n\t"         \
+	" nop\n\t"              \
+	"1:\n\t"                \
+	: : : "$8", "$9");      \
+	sceKernelIcacheClearAll(); \
+}
+
+/**
+ * Set the $pc register to a user memory address.
+ *
+ */
+#define pspKernelSetUserPC()  \
+{     \
+	__asm__ volatile (      \
+	"la     $8, 1f\n\t"     \
+	"li     $9, 0x7FFFFFFF\n\t" \
+	"and    $8, $9\n\t"     \
+	"jr     $8\n\t"         \
+	" nop\n\t"              \
+	"1:\n\t"                \
+	: : : "$8", "$9");      \
+	sceKernelIcacheClearAll(); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPKERNEL_H */
diff --git a/newlib/psp/include/pspkerneltypes.h b/newlib/psp/include/pspkerneltypes.h
new file mode 100644
index 0000000..16516ba
--- /dev/null
+++ b/newlib/psp/include/pspkerneltypes.h
@@ -0,0 +1,38 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspkerneltypes.h - PSP kernel types and definitions.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef PSPKERNELTYPES_H
+#define PSPKERNELTYPES_H
+
+#include <psptypes.h>
+
+/** UIDs are used to describe many different kernel objects. */
+typedef int SceUID;
+
+/* Misc. kernel types. */
+typedef unsigned int SceSize;
+typedef int SceSSize;
+
+typedef unsigned char SceUChar;
+typedef unsigned int SceUInt;
+
+/* File I/O types. */
+typedef int SceMode;
+typedef SceInt64 SceOff;
+typedef SceInt64 SceIores;
+
+#endif /* PSPKERNELTYPES_H */
diff --git a/newlib/psp/include/pspkerror.h b/newlib/psp/include/pspkerror.h
new file mode 100644
index 0000000..ec43e45
--- /dev/null
+++ b/newlib/psp/include/pspkerror.h
@@ -0,0 +1,220 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspkerror.h - Definitions for the kernel error codes
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef PSPKERROR_H
+#define PSPKERROR_H
+
+/* Note: The error code enumerations in this file were extrapolated from
+   symbolic debugging information found in the Japanese version of Puzzle Bobble. */
+
+enum PspKernelErrorCodes
+{
+	SCE_KERNEL_ERROR_OK	 = 0,	
+	SCE_KERNEL_ERROR_ERROR	 = 0x80020001,	
+	SCE_KERNEL_ERROR_NOTIMP	= 0x80020002,	
+	SCE_KERNEL_ERROR_ILLEGAL_EXPCODE	= 0x80020032,	
+	SCE_KERNEL_ERROR_EXPHANDLER_NOUSE	= 0x80020033,	
+	SCE_KERNEL_ERROR_EXPHANDLER_USED	= 0x80020034,	
+	SCE_KERNEL_ERROR_SYCALLTABLE_NOUSED	= 0x80020035,	
+	SCE_KERNEL_ERROR_SYCALLTABLE_USED	= 0x80020036,	
+	SCE_KERNEL_ERROR_ILLEGAL_SYSCALLTABLE	= 0x80020037,	
+	SCE_KERNEL_ERROR_ILLEGAL_PRIMARY_SYSCALL_NUMBER	= 0x80020038,	
+	SCE_KERNEL_ERROR_PRIMARY_SYSCALL_NUMBER_INUSE	= 0x80020039,	
+	SCE_KERNEL_ERROR_ILLEGAL_CONTEXT	= 0x80020064,	
+	SCE_KERNEL_ERROR_ILLEGAL_INTRCODE	= 0x80020065,	
+	SCE_KERNEL_ERROR_CPUDI	= 0x80020066,	
+	SCE_KERNEL_ERROR_FOUND_HANDLER	= 0x80020067,	
+	SCE_KERNEL_ERROR_NOTFOUND_HANDLER	= 0x80020068,	
+	SCE_KERNEL_ERROR_ILLEGAL_INTRLEVEL	= 0x80020069,	
+	SCE_KERNEL_ERROR_ILLEGAL_ADDRESS	= 0x8002006a,	
+	SCE_KERNEL_ERROR_ILLEGAL_INTRPARAM	= 0x8002006b,	
+	SCE_KERNEL_ERROR_ILLEGAL_STACK_ADDRESS	= 0x8002006c,	
+	SCE_KERNEL_ERROR_ALREADY_STACK_SET	= 0x8002006d,	
+	SCE_KERNEL_ERROR_NO_TIMER	= 0x80020096,	
+	SCE_KERNEL_ERROR_ILLEGAL_TIMERID	= 0x80020097,	
+	SCE_KERNEL_ERROR_ILLEGAL_SOURCE	= 0x80020098,	
+	SCE_KERNEL_ERROR_ILLEGAL_PRESCALE	= 0x80020099,	
+	SCE_KERNEL_ERROR_TIMER_BUSY	= 0x8002009a,	
+	SCE_KERNEL_ERROR_TIMER_NOT_SETUP	= 0x8002009b,	
+	SCE_KERNEL_ERROR_TIMER_NOT_INUSE	= 0x8002009c,	
+	SCE_KERNEL_ERROR_UNIT_USED	= 0x800200a0,	
+	SCE_KERNEL_ERROR_UNIT_NOUSE	= 0x800200a1,	
+	SCE_KERNEL_ERROR_NO_ROMDIR	= 0x800200a2,	
+	SCE_KERNEL_ERROR_IDTYPE_EXIST	= 0x800200c8,	
+	SCE_KERNEL_ERROR_IDTYPE_NOT_EXIST	= 0x800200c9,	
+	SCE_KERNEL_ERROR_IDTYPE_NOT_EMPTY	= 0x800200ca,	
+	SCE_KERNEL_ERROR_UNKNOWN_UID	= 0x800200cb,	
+	SCE_KERNEL_ERROR_UNMATCH_UID_TYPE	= 0x800200cc,	
+	SCE_KERNEL_ERROR_ID_NOT_EXIST	= 0x800200cd,	
+	SCE_KERNEL_ERROR_NOT_FOUND_UIDFUNC	= 0x800200ce,	
+	SCE_KERNEL_ERROR_UID_ALREADY_HOLDER	= 0x800200cf,	
+	SCE_KERNEL_ERROR_UID_NOT_HOLDER	= 0x800200d0,	
+	SCE_KERNEL_ERROR_ILLEGAL_PERM	= 0x800200d1,	
+	SCE_KERNEL_ERROR_ILLEGAL_ARGUMENT	= 0x800200d2,	
+	SCE_KERNEL_ERROR_ILLEGAL_ADDR	= 0x800200d3,	
+	SCE_KERNEL_ERROR_OUT_OF_RANGE	= 0x800200d4,	
+	SCE_KERNEL_ERROR_MEM_RANGE_OVERLAP	= 0x800200d5,	
+	SCE_KERNEL_ERROR_ILLEGAL_PARTITION	= 0x800200d6,	
+	SCE_KERNEL_ERROR_PARTITION_INUSE	= 0x800200d7,	
+	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCKTYPE	= 0x800200d8,	
+	SCE_KERNEL_ERROR_MEMBLOCK_ALLOC_FAILED	= 0x800200d9,	
+	SCE_KERNEL_ERROR_MEMBLOCK_RESIZE_LOCKED	= 0x800200da,	
+	SCE_KERNEL_ERROR_MEMBLOCK_RESIZE_FAILED	= 0x800200db,	
+	SCE_KERNEL_ERROR_HEAPBLOCK_ALLOC_FAILED	= 0x800200dc,	
+	SCE_KERNEL_ERROR_HEAP_ALLOC_FAILED	= 0x800200dd,	
+	SCE_KERNEL_ERROR_ILLEGAL_CHUNK_ID	= 0x800200de,	
+	SCE_KERNEL_ERROR_NOCHUNK	= 0x800200df,	
+	SCE_KERNEL_ERROR_NO_FREECHUNK	= 0x800200e0,	
+	SCE_KERNEL_ERROR_LINKERR	= 0x8002012c,	
+	SCE_KERNEL_ERROR_ILLEGAL_OBJECT	= 0x8002012d,	
+	SCE_KERNEL_ERROR_UNKNOWN_MODULE	= 0x8002012e,	
+	SCE_KERNEL_ERROR_NOFILE	= 0x8002012f,	
+	SCE_KERNEL_ERROR_FILEERR	= 0x80020130,	
+	SCE_KERNEL_ERROR_MEMINUSE	= 0x80020131,	
+	SCE_KERNEL_ERROR_PARTITION_MISMATCH	= 0x80020132,	
+	SCE_KERNEL_ERROR_ALREADY_STARTED	= 0x80020133,	
+	SCE_KERNEL_ERROR_NOT_STARTED	= 0x80020134,	
+	SCE_KERNEL_ERROR_ALREADY_STOPPED	= 0x80020135,	
+	SCE_KERNEL_ERROR_CAN_NOT_STOP	= 0x80020136,	
+	SCE_KERNEL_ERROR_NOT_STOPPED	= 0x80020137,	
+	SCE_KERNEL_ERROR_NOT_REMOVABLE	= 0x80020138,	
+	SCE_KERNEL_ERROR_EXCLUSIVE_LOAD	= 0x80020139,	
+	SCE_KERNEL_ERROR_LIBRARY_NOT_YET_LINKED	= 0x8002013a,	
+	SCE_KERNEL_ERROR_LIBRARY_FOUND	= 0x8002013b,	
+	SCE_KERNEL_ERROR_LIBRARY_NOTFOUND	= 0x8002013c,	
+	SCE_KERNEL_ERROR_ILLEGAL_LIBRARY	= 0x8002013d,	
+	SCE_KERNEL_ERROR_LIBRARY_INUSE	= 0x8002013e,	
+	SCE_KERNEL_ERROR_ALREADY_STOPPING	= 0x8002013f,	
+	SCE_KERNEL_ERROR_ILLEGAL_OFFSET	= 0x80020140,	
+	SCE_KERNEL_ERROR_ILLEGAL_POSITION	= 0x80020141,	
+	SCE_KERNEL_ERROR_ILLEGAL_ACCESS	= 0x80020142,	
+	SCE_KERNEL_ERROR_MODULE_MGR_BUSY	= 0x80020143,	
+	SCE_KERNEL_ERROR_ILLEGAL_FLAG	= 0x80020144,	
+	SCE_KERNEL_ERROR_CANNOT_GET_MODULELIST	= 0x80020145,	
+	SCE_KERNEL_ERROR_PROHIBIT_LOADMODULE_DEVICE	= 0x80020146,	
+	SCE_KERNEL_ERROR_PROHIBIT_LOADEXEC_DEVICE	= 0x80020147,	
+	SCE_KERNEL_ERROR_UNSUPPORTED_PRX_TYPE	= 0x80020148,	
+	SCE_KERNEL_ERROR_ILLEGAL_PERM_CALL	= 0x80020149,	
+	SCE_KERNEL_ERROR_CANNOT_GET_MODULE_INFORMATION	= 0x8002014a,	
+	SCE_KERNEL_ERROR_ILLEGAL_LOADEXEC_BUFFER	= 0x8002014b,	
+	SCE_KERNEL_ERROR_ILLEGAL_LOADEXEC_FILENAME	= 0x8002014c,	
+	SCE_KERNEL_ERROR_NO_EXIT_CALLBACK	= 0x8002014d,	
+	SCE_KERNEL_ERROR_NO_MEMORY	= 0x80020190,	
+	SCE_KERNEL_ERROR_ILLEGAL_ATTR	= 0x80020191,	
+	SCE_KERNEL_ERROR_ILLEGAL_ENTRY	= 0x80020192,	
+	SCE_KERNEL_ERROR_ILLEGAL_PRIORITY	= 0x80020193,	
+	SCE_KERNEL_ERROR_ILLEGAL_STACK_SIZE	= 0x80020194,	
+	SCE_KERNEL_ERROR_ILLEGAL_MODE	= 0x80020195,	
+	SCE_KERNEL_ERROR_ILLEGAL_MASK	= 0x80020196,	
+	SCE_KERNEL_ERROR_ILLEGAL_THID	= 0x80020197,	
+	SCE_KERNEL_ERROR_UNKNOWN_THID	= 0x80020198,	
+	SCE_KERNEL_ERROR_UNKNOWN_SEMID	= 0x80020199,	
+	SCE_KERNEL_ERROR_UNKNOWN_EVFID	= 0x8002019a,	
+	SCE_KERNEL_ERROR_UNKNOWN_MBXID	= 0x8002019b,	
+	SCE_KERNEL_ERROR_UNKNOWN_VPLID	= 0x8002019c,	
+	SCE_KERNEL_ERROR_UNKNOWN_FPLID	= 0x8002019d,	
+	SCE_KERNEL_ERROR_UNKNOWN_MPPID	= 0x8002019e,	
+	SCE_KERNEL_ERROR_UNKNOWN_ALMID	= 0x8002019f,	
+	SCE_KERNEL_ERROR_UNKNOWN_TEID	= 0x800201a0,	
+	SCE_KERNEL_ERROR_UNKNOWN_CBID	= 0x800201a1,	
+	SCE_KERNEL_ERROR_DORMANT	= 0x800201a2,	
+	SCE_KERNEL_ERROR_SUSPEND	= 0x800201a3,	
+	SCE_KERNEL_ERROR_NOT_DORMANT	= 0x800201a4,	
+	SCE_KERNEL_ERROR_NOT_SUSPEND	= 0x800201a5,	
+	SCE_KERNEL_ERROR_NOT_WAIT	= 0x800201a6,	
+	SCE_KERNEL_ERROR_CAN_NOT_WAIT	= 0x800201a7,	
+	SCE_KERNEL_ERROR_WAIT_TIMEOUT	= 0x800201a8,	
+	SCE_KERNEL_ERROR_WAIT_CANCEL	= 0x800201a9,	
+	SCE_KERNEL_ERROR_RELEASE_WAIT	= 0x800201aa,	
+	SCE_KERNEL_ERROR_NOTIFY_CALLBACK	= 0x800201ab,	
+	SCE_KERNEL_ERROR_THREAD_TERMINATED	= 0x800201ac,	
+	SCE_KERNEL_ERROR_SEMA_ZERO	= 0x800201ad,	
+	SCE_KERNEL_ERROR_SEMA_OVF	= 0x800201ae,	
+	SCE_KERNEL_ERROR_EVF_COND	= 0x800201af,	
+	SCE_KERNEL_ERROR_EVF_MULTI	= 0x800201b0,	
+	SCE_KERNEL_ERROR_EVF_ILPAT	= 0x800201b1,	
+	SCE_KERNEL_ERROR_MBOX_NOMSG	= 0x800201b2,	
+	SCE_KERNEL_ERROR_MPP_FULL	= 0x800201b3,	
+	SCE_KERNEL_ERROR_MPP_EMPTY	= 0x800201b4,	
+	SCE_KERNEL_ERROR_WAIT_DELETE	= 0x800201b5,	
+	SCE_KERNEL_ERROR_ILLEGAL_MEMBLOCK	= 0x800201b6,	
+	SCE_KERNEL_ERROR_ILLEGAL_MEMSIZE	= 0x800201b7,	
+	SCE_KERNEL_ERROR_ILLEGAL_SPADADDR	= 0x800201b8,	
+	SCE_KERNEL_ERROR_SPAD_INUSE	= 0x800201b9,	
+	SCE_KERNEL_ERROR_SPAD_NOT_INUSE	= 0x800201ba,	
+	SCE_KERNEL_ERROR_ILLEGAL_TYPE	= 0x800201bb,	
+	SCE_KERNEL_ERROR_ILLEGAL_SIZE	= 0x800201bc,	
+	SCE_KERNEL_ERROR_ILLEGAL_COUNT	= 0x800201bd,	
+	SCE_KERNEL_ERROR_UNKNOWN_VTID	= 0x800201be,	
+	SCE_KERNEL_ERROR_ILLEGAL_VTID	= 0x800201bf,	
+	SCE_KERNEL_ERROR_ILLEGAL_KTLSID	= 0x800201c0,	
+	SCE_KERNEL_ERROR_KTLS_FULL	= 0x800201c1,	
+	SCE_KERNEL_ERROR_KTLS_BUSY	= 0x800201c2,	
+	SCE_KERNEL_ERROR_PM_INVALID_PRIORITY	= 0x80020258,	
+	SCE_KERNEL_ERROR_PM_INVALID_DEVNAME	= 0x80020259,	
+	SCE_KERNEL_ERROR_PM_UNKNOWN_DEVNAME	= 0x8002025a,	
+	SCE_KERNEL_ERROR_PM_PMINFO_REGISTERED	= 0x8002025b,	
+	SCE_KERNEL_ERROR_PM_PMINFO_UNREGISTERED	= 0x8002025c,	
+	SCE_KERNEL_ERROR_PM_INVALID_MAJOR_STATE	= 0x8002025d,	
+	SCE_KERNEL_ERROR_PM_INVALID_REQUEST	= 0x8002025e,	
+	SCE_KERNEL_ERROR_PM_UNKNOWN_REQUEST	= 0x8002025f,	
+	SCE_KERNEL_ERROR_PM_INVALID_UNIT	= 0x80020260,	
+	SCE_KERNEL_ERROR_PM_CANNOT_CANCEL	= 0x80020261,	
+	SCE_KERNEL_ERROR_PM_INVALID_PMINFO	= 0x80020262,	
+	SCE_KERNEL_ERROR_PM_INVALID_ARGUMENT	= 0x80020263,	
+	SCE_KERNEL_ERROR_PM_ALREADY_TARGET_PWRSTATE	= 0x80020264,	
+	SCE_KERNEL_ERROR_PM_CHANGE_PWRSTATE_FAILED	= 0x80020265,	
+	SCE_KERNEL_ERROR_PM_CANNOT_CHANGE_DEVPWR_STATE	= 0x80020266,	
+	SCE_KERNEL_ERROR_PM_NO_SUPPORT_DEVPWR_STATE	= 0x80020267,	
+	SCE_KERNEL_ERROR_DMAC_REQUEST_FAILED	= 0x800202bc,	
+	SCE_KERNEL_ERROR_DMAC_REQUEST_DENIED	= 0x800202bd,	
+	SCE_KERNEL_ERROR_DMAC_OP_QUEUED	= 0x800202be,	
+	SCE_KERNEL_ERROR_DMAC_OP_NOT_QUEUED	= 0x800202bf,	
+	SCE_KERNEL_ERROR_DMAC_OP_RUNNING	= 0x800202c0,	
+	SCE_KERNEL_ERROR_DMAC_OP_NOT_ASSIGNED	= 0x800202c1,	
+	SCE_KERNEL_ERROR_DMAC_OP_TIMEOUT	= 0x800202c2,	
+	SCE_KERNEL_ERROR_DMAC_OP_FREED	= 0x800202c3,	
+	SCE_KERNEL_ERROR_DMAC_OP_USED	= 0x800202c4,	
+	SCE_KERNEL_ERROR_DMAC_OP_EMPTY	= 0x800202c5,	
+	SCE_KERNEL_ERROR_DMAC_OP_ABORTED	= 0x800202c6,	
+	SCE_KERNEL_ERROR_DMAC_OP_ERROR	= 0x800202c7,	
+	SCE_KERNEL_ERROR_DMAC_CHANNEL_RESERVED	= 0x800202c8,	
+	SCE_KERNEL_ERROR_DMAC_CHANNEL_EXCLUDED	= 0x800202c9,	
+	SCE_KERNEL_ERROR_DMAC_PRIVILEGE_ADDRESS	= 0x800202ca,	
+	SCE_KERNEL_ERROR_DMAC_NO_ENOUGHSPACE	= 0x800202cb,	
+	SCE_KERNEL_ERROR_DMAC_CHANNEL_NOT_ASSIGNED	= 0x800202cc,	
+	SCE_KERNEL_ERROR_DMAC_CHILD_OPERATION	= 0x800202cd,	
+	SCE_KERNEL_ERROR_DMAC_TOO_MUCH_SIZE	= 0x800202ce,	
+	SCE_KERNEL_ERROR_DMAC_INVALID_ARGUMENT	= 0x800202cf,	
+	SCE_KERNEL_ERROR_MFILE	= 0x80020320,	
+	SCE_KERNEL_ERROR_NODEV	= 0x80020321,	
+	SCE_KERNEL_ERROR_XDEV	= 0x80020322,	
+	SCE_KERNEL_ERROR_BADF	= 0x80020323,	
+	SCE_KERNEL_ERROR_INVAL	= 0x80020324,	
+	SCE_KERNEL_ERROR_UNSUP	= 0x80020325,	
+	SCE_KERNEL_ERROR_ALIAS_USED	= 0x80020326,	
+	SCE_KERNEL_ERROR_CANNOT_MOUNT	= 0x80020327,	
+	SCE_KERNEL_ERROR_DRIVER_DELETED	= 0x80020328,	
+	SCE_KERNEL_ERROR_ASYNC_BUSY	= 0x80020329,	
+	SCE_KERNEL_ERROR_NOASYNC	= 0x8002032a,	
+	SCE_KERNEL_ERROR_REGDEV	= 0x8002032b,	
+	SCE_KERNEL_ERROR_NOCWD	= 0x8002032c,	
+	SCE_KERNEL_ERROR_NAMETOOLONG	= 0x8002032d,	
+	SCE_KERNEL_ERROR_NXIO	= 0x800203e8,	
+	SCE_KERNEL_ERROR_IO	= 0x800203e9,	
+	SCE_KERNEL_ERROR_NOMEM	= 0x800203ea,	
+	SCE_KERNEL_ERROR_STDIO_NOT_OPENED	= 0x800203eb,	
+	SCE_KERNEL_ERROR_CACHE_ALIGNMENT	= 0x8002044c,	
+	SCE_KERNEL_ERROR_ERRORMAX	= 0x8002044d,	
+};
+
+#endif /* PSPKERROR_H */
diff --git a/newlib/psp/include/psploadcore.h b/newlib/psp/include/psploadcore.h
new file mode 100644
index 0000000..69ab392
--- /dev/null
+++ b/newlib/psp/include/psploadcore.h
@@ -0,0 +1,145 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psploadcore.h - Interface to LoadCoreForKernel.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPLOADCORE_H
+#define PSPLOADCORE_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup LoadCore Interface to the LoadCoreForKernel library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup LoadCore Interface to the LoadCoreForKernel library. */
+/**@{*/
+
+/** Describes a module.  This structure could change in future firmware revisions. */
+typedef struct SceModule {
+	struct SceModule	*next;
+	unsigned short		attribute;
+	unsigned char		version[2];
+	char				modname[27];
+	char				terminal;
+	unsigned int		unknown1;
+	unsigned int		unknown2;
+	SceUID				modid;
+	unsigned int		unknown3[4];
+	void *				ent_top;
+	unsigned int		ent_size;
+	void *				stub_top;
+	unsigned int		stub_size;
+	unsigned int		unknown4[4];
+	unsigned int		entry_addr;
+	unsigned int		gp_value;
+	unsigned int		text_addr;
+	unsigned int		text_size;
+	unsigned int		data_size;
+	unsigned int		bss_size;
+	unsigned int		nsegment;
+	unsigned int		segmentaddr[4];
+	unsigned int		segmentsize[4];
+} __attribute__((packed)) SceModule;
+
+/** Defines a library and its exported functions and variables.  Use the len
+    member to determine the real size of the table (size = len * 4). */
+typedef struct SceLibraryEntryTable {
+	/**The library's name. */
+	const char *		libname;
+	/** Library version. */
+	unsigned char		version[2];
+	/** Library attributes. */
+	unsigned short		attribute;
+	/** Length of this entry table in 32-bit WORDs. */
+	unsigned char		len;
+	/** The number of variables exported by the library. */
+	unsigned char		vstubcount;
+	/** The number of functions exported by the library. */
+	unsigned short		stubcount;
+	/** Pointer to the entry table; an array of NIDs followed by
+	    pointers to functions and variables. */
+	void *				entrytable;
+} SceLibraryEntryTable;
+
+/** Specifies a library and a set of imports from that library.  Use the len
+    member to determine the real size of the table (size = len * 4). */
+typedef struct SceLibraryStubTable {
+	/* The name of the library we're importing from. */
+	const char *		libname;
+	/** Minimum required version of the library we want to import. */
+	unsigned char		version[2];
+	/* Import attributes. */
+	unsigned short		attribute;
+	/** Length of this stub table in 32-bit WORDs. */
+	unsigned char		len;
+	/** The number of variables imported from the library. */
+	unsigned char		vstubcount;
+	/** The number of functions imported from the library. */
+	unsigned short		stubcount;
+	/** Pointer to an array of NIDs. */
+	unsigned int *		nidtable;
+	/** Pointer to the imported function stubs. */
+	void *				stubtable;
+	/** Pointer to the imported variable stubs. */
+	void *				vstubtable;
+} SceLibraryStubTable;
+
+
+/**
+ * Find a module by it's name.
+ *
+ * @param modname - The name of the module.
+ *
+ * @return Pointer to the ::SceModule structure if found, otherwise NULL.
+ */
+SceModule * sceKernelFindModuleByName(const char *modname);
+
+/**
+ * Find a module from an address.
+ *
+ * @param addr - Address somewhere within the module.
+ *
+ * @return Pointer to the ::SceModule structure if found, otherwise NULL.
+ */
+SceModule * sceKernelFindModuleByAddress(unsigned int addr);
+
+/**
+ * Find a module by it's UID.
+ *
+ * @param modid - The UID of the module.
+ *
+ * @return Pointer to the ::SceModule structure if found, otherwise NULL.
+ */
+SceModule * sceKernelFindModuleByUID(SceUID modid);
+
+/**
+ * Return the count of loaded modules.
+ *
+ * @return The count of loaded modules.
+ */
+int sceKernelModuleCount(void);
+
+/**
+ * Invalidate the CPU's instruction cache.
+ */
+void sceKernelIcacheClearAll(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPLOADCORE_H */
diff --git a/newlib/psp/include/psploadexec.h b/newlib/psp/include/psploadexec.h
new file mode 100644
index 0000000..8113ac1
--- /dev/null
+++ b/newlib/psp/include/psploadexec.h
@@ -0,0 +1,87 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psploadexec.h - Process load and exit related functions.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef __LOADEXEC_H__
+#define __LOADEXEC_H__
+
+/** @defgroup LoadExec LoadExec Library */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup LoadExec */
+
+/**@{*/
+
+/**
+ * Register callback
+ *
+ * @note By installing the exit callback the home button becomes active. However if sceKernelExitGame
+ * is not called in the callback it is likely that the psp will just crash.
+ *
+ * @par Example:
+ * @code
+ * int exit_callback(void) { sceKernelExitGame(); }
+ *
+ * cbid = sceKernelCreateCallback("ExitCallback", exit_callback, NULL);
+ * sceKernelRegisterExitCallback(cbid);
+ * @endcode
+ *
+ * @param cbid Callback id
+ * @return < 0 on error
+ */
+int sceKernelRegisterExitCallback(int cbid);
+
+/**
+ * Exit game and go back to the PSP browser.
+ *
+ * @note You need to be in a thread in order for this function to work
+ *
+ */
+void sceKernelExitGame(void);
+
+/** Structure to pass to loadexec */
+struct SceKernelLoadExecParam {
+	/** Size of the structure */
+	SceSize     size;
+	/** Size of the arg string */
+	SceSize     args;
+	/** Pointer to the arg string */
+	void *  argp;
+	/** Encryption key ? */
+	const char *    key;
+};
+
+/** 
+  * Execute a new game executable, limited when not running in kernel mode.
+  * 
+  * @param file - The file to execute.
+  * @param param - Pointer to a ::SceKernelLoadExecParam structure, or NULL.
+  *
+  * @return < 0 on error, probably.
+  *
+  */
+int sceKernelLoadExec(const char *file, struct SceKernelLoadExecParam *param);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif
diff --git a/newlib/psp/include/psploadexec_kernel.h b/newlib/psp/include/psploadexec_kernel.h
new file mode 100644
index 0000000..dedaae3
--- /dev/null
+++ b/newlib/psp/include/psploadexec_kernel.h
@@ -0,0 +1,164 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psploadexec_kernel.h - Interface to LoadExecForKernel.
+ *
+ * Copyright (c) 2007 - DA (Taken from the 303oe SDK)
+ *
+ */
+
+#ifndef PSPLOADEXEC_KERNEL_H
+#define PSPLOADEXEC_KERNEL_H
+
+#include <pspkerneltypes.h>
+#include <psploadexec.h>
+
+/** @defgroup LoadExecKernel Interface to the LoadExecForKernel library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup LoadExecKernel Interface to the LoadExecForKernel library. */
+/**@{*/
+
+/** Structure for LoadExecVSH* functions */
+struct SceKernelLoadExecVSHParam {
+/** Size of the structure in bytes */
+    SceSize     size;
+/** Size of the arguments string */
+    SceSize     args;
+/** Pointer to the arguments strings */
+    void * argp;
+/** The key, usually "game", "updater" or "vsh" */
+    const char * key;
+/** The size of the vshmain arguments */
+    u32 vshmain_args_size;
+/** vshmain arguments that will be passed to vshmain after the program has exited */
+    void *vshmain_args;
+/** "/kd/pspbtcnf_game.txt" or "/kd/pspbtcnf.txt" if not supplied (max. 256 chars) */
+    char *configfile;
+/** An unknown string (max. 256 chars) probably used in 2nd stage of loadexec */
+    u32 unk4;
+/** unknown flag default value = 0x10000 */
+    u32 unk5;
+}; 
+
+#if _PSP_FW_VERSION < 200
+/**
+ * Executes a new executable from a buffer.
+ *
+ * @param bufsize - Size in bytes of the buffer pointed by buf.
+ * @param buf - Pointer to a buffer containing the module to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecBufferPlain(SceSize bufsize, void *buf, struct SceKernelLoadExecParam *param);
+#endif
+
+/**
+ * Restart the vsh.
+ *
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL
+ *
+ * @return < 0 on some errors.
+ *
+ * @note - when called in game mode it will have the same effect that sceKernelExitGame
+ *
+*/
+int sceKernelExitVSHVSH(struct SceKernelLoadExecVSHParam *param);
+
+#if _PSP_FW_VERSION >= 200
+/**
+ * Restart the vsh (to be used by a kernel module)
+ *
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL
+ *
+ * @return < 0 on some errors.
+ *
+ * @note - when called in game mode it will have the same effect that sceKernelExitGame
+ * @note2: available since firmware 2.00.
+*/
+int sceKernelExitVSHKernel(struct SceKernelLoadExecVSHParam *param);
+#endif
+
+/**
+ * Executes a new executable from a disc.
+ * It is the function used by the firmware to execute the EBOOT.BIN from a disc.
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecVSHDisc(const char *file, struct SceKernelLoadExecVSHParam *param);
+
+/**
+ * Executes a new executable from a disc.
+ * It is the function used by the firmware to execute an updater from a disc.
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecVSHDiscUpdater(const char *file, struct SceKernelLoadExecVSHParam *param);
+
+/**
+ * Executes a new executable from a memory stick.
+ * It is the function used by the firmware to execute an updater from a memory stick.
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecVSHMs1(const char *file, struct SceKernelLoadExecVSHParam *param);
+
+/**
+ * Executes a new executable from a memory stick.
+ * It is the function used by the firmware to execute games (and homebrew :P) from a memory stick.
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecVSHMs2(const char *file, struct SceKernelLoadExecVSHParam *param);
+
+/**
+ * Executes a new executable from a memory stick.
+ * It is the function used by the firmware to execute ... ?
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+*/
+int sceKernelLoadExecVSHMs3(const char *file, struct SceKernelLoadExecVSHParam *param);
+
+#if _PSP_FW_VERSION >= 300
+/***
+ * Executes a new executable from a memory stick.
+ * It is the function used by the firmware to execute psx games
+ *
+ * @param file - The file to execute.
+ * @param param - Pointer to a ::SceKernelLoadExecVSHParam structure, or NULL.
+ *
+ * @return < 0 on some errors. 
+ * @note - Available since firmware 3.00
+*/
+int sceKernelLoadExecVSHMs4(const char *file, struct SceKernelLoadExecVSHParam *param);
+#endif
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
diff --git a/newlib/psp/include/pspmoduleexport.h b/newlib/psp/include/pspmoduleexport.h
new file mode 100644
index 0000000..b597831
--- /dev/null
+++ b/newlib/psp/include/pspmoduleexport.h
@@ -0,0 +1,28 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmoduleexport.h - Definitions for the .rodata.sceResident section.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSP_MODEXPORT_H_
+#define PSP_MODEXPORT_H_
+
+/** Structure to hold a single export entry */
+struct _PspLibraryEntry {
+	const char *	name;
+	unsigned short	version;
+	unsigned short	attribute;
+	unsigned char	entLen;
+	unsigned char	varCount;
+	unsigned short	funcCount;
+	void *			entrytable;
+}; 
+
+#endif
diff --git a/newlib/psp/include/pspmoduleinfo.h b/newlib/psp/include/pspmoduleinfo.h
new file mode 100644
index 0000000..a7a83ff
--- /dev/null
+++ b/newlib/psp/include/pspmoduleinfo.h
@@ -0,0 +1,110 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmoduleinfo.h - Definitions for the .rodata.sceModuleInfo ELF section.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef PSPMODULEINFO_H
+#define PSPMODULEINFO_H
+
+/* Note: Some of the structures and definitions in this file were extrapolated from
+   symbolic debugging information found in the Japanese version of Puzzle Bobble. */
+
+/* Module info structure.  Used to declare a module (library or executable).  This structure
+   is required in all PSP executables. */
+typedef struct _scemoduleinfo {
+	unsigned short		modattribute;
+	unsigned char		modversion[2];
+	char			modname[27];
+	char			terminal;
+	void *			gp_value;
+	void *			ent_top;
+	void *			ent_end;
+	void *			stub_top;
+	void *			stub_end;
+} _sceModuleInfo;
+
+typedef const _sceModuleInfo SceModuleInfo;
+
+extern char _gp[];
+
+enum PspModuleInfoAttr
+{
+	PSP_MODULE_USER			= 0,
+	PSP_MODULE_NO_STOP		= 0x0001,
+	PSP_MODULE_SINGLE_LOAD	= 0x0002,
+	PSP_MODULE_SINGLE_START	= 0x0004,
+	PSP_MODULE_KERNEL		= 0x1000,
+};
+
+#ifdef __cplusplus
+
+/* Declare a module.  This must be specified in the source of a library or executable. */
+#define PSP_MODULE_INFO(name, attributes, major_version, minor_version) \
+	extern char __lib_ent_top[], __lib_ent_bottom[];                \
+	extern char __lib_stub_top[], __lib_stub_bottom[];              \
+	extern SceModuleInfo module_info                                \
+		__attribute__((section(".rodata.sceModuleInfo"),        \
+			       aligned(16), unused)) = {                \
+	  attributes, { minor_version, major_version }, #name, 0, _gp,  \
+	  __lib_ent_top, __lib_ent_bottom,                              \
+	  __lib_stub_top, __lib_stub_bottom                             \
+	}
+#else
+/* Declare a module.  This must be specified in the source of a library or executable. */
+#define PSP_MODULE_INFO(name, attributes, major_version, minor_version) \
+	extern char __lib_ent_top[], __lib_ent_bottom[];                \
+	extern char __lib_stub_top[], __lib_stub_bottom[];              \
+	SceModuleInfo module_info                                       \
+		__attribute__((section(".rodata.sceModuleInfo"),        \
+			       aligned(16), unused)) = {                \
+	  attributes, { minor_version, major_version }, name, 0, _gp,  \
+	  __lib_ent_top, __lib_ent_bottom,                              \
+	  __lib_stub_top, __lib_stub_bottom                             \
+	}
+#endif
+
+/* Define the main thread's initial priority. */
+#define PSP_MAIN_THREAD_PRIORITY(priority) \
+	unsigned int sce_newlib_priority = (priority)
+/* Define the main thread's stack size (in KB). */
+#define PSP_MAIN_THREAD_STACK_SIZE_KB(size_kb) \
+	unsigned int sce_newlib_stack_kb_size = (size_kb)
+/* Define the main thread's attributes. */
+#define PSP_MAIN_THREAD_ATTR(attr) \
+	unsigned int sce_newlib_attribute = (attr)
+#define PSP_MAIN_THREAD_ATTRIBUTE PSP_MAIN_THREAD_ATTR
+
+/* Define all main thread parameters. */
+#define PSP_MAIN_THREAD_PARAMS(priority, size_kb, attribute) \
+	PSP_MAIN_THREAD_PRIORITY(priority); \
+	PSP_MAIN_THREAD_STACK_SIZE_KB(size_kb); \
+	PSP_MAIN_THREAD_ATTR(attribute)
+
+/* If declared, the runtime code won't create a main thread for the program. */
+#define PSP_NO_CREATE_MAIN_THREAD() \
+	int sce_newlib_nocreate_thread_in_start = 1
+
+/* Declare the size of the heap (in KB) that the program wants to allocate from. */
+#define PSP_HEAP_SIZE_KB(size_kb) \
+	int sce_newlib_heap_kb_size = (size_kb)
+
+/* Declare the threshold of the heap (in KB) that the program wants to keep for external allocation. */
+#define PSP_HEAP_THRESHOLD_SIZE_KB(size_kb) \
+	int sce_newlib_heap_threshold_kb_size = (size_kb)
+
+/* Declare the name of the main thread */
+#define PSP_MAIN_THREAD_NAME(s) const char* sce_newlib_main_thread_name = (s)
+
+/* Disable the use of newlib, getting a minimal binary. */
+#define PSP_DISABLE_NEWLIB() \
+	void __libcglue_init(int argc, char *argv[]) {} \
+	void __libcglue_deinit() {}
+
+#endif /* PSPMODULEINFO_H */
diff --git a/newlib/psp/include/pspmodulemgr.h b/newlib/psp/include/pspmodulemgr.h
new file mode 100644
index 0000000..527b7ef
--- /dev/null
+++ b/newlib/psp/include/pspmodulemgr.h
@@ -0,0 +1,226 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmodulemgr.h - Prototypes to manage modules.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef __MODLOAD_H__
+#define __MODLOAD_H__
+
+#include <pspkerneltypes.h>
+
+/** @defgroup ModuleMgr Module Manager Library
+  * This module contains the imports for the kernel's module management routines.
+  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup ModuleMgr Module Manager Library */
+/**@{*/
+
+#define PSP_MEMORY_PARTITION_KERNEL 1
+#define PSP_MEMORY_PARTITION_USER 2
+
+typedef struct SceKernelLMOption {
+	SceSize 		size;
+	SceUID 			mpidtext;
+	SceUID 			mpiddata;
+	unsigned int 	flags;
+	char 			position;
+	char 			access;
+	char 			creserved[2];
+} SceKernelLMOption;
+
+typedef struct SceKernelSMOption {
+	SceSize 		size;
+	SceUID 			mpidstack;
+	SceSize 		stacksize;
+	int 			priority;
+	unsigned int 	attribute;
+} SceKernelSMOption;
+
+
+/**
+  * Load a module.
+  * @note This function restricts where it can load from (such as from flash0) 
+  * unless you call it in kernel mode. It also must be called from a thread.
+  * 
+  * @param path - The path to the module to load.
+  * @param flags - Unused, always 0 .
+  * @param option  - Pointer to a mod_param_t structure. Can be NULL.
+  *
+  * @return The UID of the loaded module on success, otherwise one of ::PspKernelErrorCodes.
+  */
+SceUID sceKernelLoadModule(const char *path, int flags, SceKernelLMOption *option);
+
+/**
+  * Load a module from MS.
+  * @note This function restricts what it can load, e.g. it wont load plain executables.
+  * 
+  * @param path - The path to the module to load.
+  * @param flags - Unused, set to 0.
+  * @param option  - Pointer to a mod_param_t structure. Can be NULL.
+  *
+  * @return The UID of the loaded module on success, otherwise one of ::PspKernelErrorCodes.
+  */
+SceUID sceKernelLoadModuleMs(const char *path, int flags, SceKernelLMOption *option);
+
+/**
+ * Load a module from the given file UID.
+ *
+ * @param fid - The module's file UID.
+ * @param flags - Unused, always 0.
+ * @param option - Pointer to an optional ::SceKernelLMOption structure.
+ *
+ * @return The UID of the loaded module on success, otherwise one of ::PspKernelErrorCodes.
+ */
+SceUID sceKernelLoadModuleByID(SceUID fid, int flags, SceKernelLMOption *option);
+
+/**
+ * Load a module from a buffer using the USB/WLAN API.
+ *
+ * Can only be called from kernel mode, or from a thread that has attributes of 0xa0000000.
+ *
+ * @param bufsize - Size (in bytes) of the buffer pointed to by buf.
+ * @param buf - Pointer to a buffer containing the module to load.  The buffer must reside at an
+ *              address that is a multiple to 64 bytes.
+ * @param flags - Unused, always 0.
+ * @param option - Pointer to an optional ::SceKernelLMOption structure.
+ *
+ * @return The UID of the loaded module on success, otherwise one of ::PspKernelErrorCodes.
+ */
+SceUID sceKernelLoadModuleBufferUsbWlan(SceSize bufsize, void *buf, int flags, SceKernelLMOption *option);
+
+/**
+  * Start a loaded module.
+  *
+  * @param modid - The ID of the module returned from LoadModule.
+  * @param argsize - Length of the args.
+  * @param argp - A pointer to the arguments to the module.
+  * @param status - Returns the status of the start.
+  * @param option - Pointer to an optional ::SceKernelSMOption structure.
+  *
+  * @return ??? on success, otherwise one of ::PspKernelErrorCodes.
+  */
+int sceKernelStartModule(SceUID modid, SceSize argsize, void *argp, int *status, SceKernelSMOption *option);
+
+/**
+ * Stop a running module.
+ *
+ * @param modid - The UID of the module to stop.
+ * @param argsize - The length of the arguments pointed to by argp.
+ * @param argp - Pointer to arguments to pass to the module's module_stop() routine.
+ * @param status - Return value of the module's module_stop() routine.
+ * @param option - Pointer to an optional ::SceKernelSMOption structure.
+ *
+ * @return ??? on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int sceKernelStopModule(SceUID modid, SceSize argsize, void *argp, int *status, SceKernelSMOption *option);
+
+/**
+ * Unload a stopped module.
+ *
+ * @param modid - The UID of the module to unload.
+ *
+ * @return ??? on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int sceKernelUnloadModule(SceUID modid);
+
+/**
+ * Stop and unload the current module.
+ *
+ * @param unknown - Unknown (I've seen 1 passed).
+ * @param argsize - Size (in bytes) of the arguments that will be passed to module_stop().
+ * @param argp - Pointer to arguments that will be passed to module_stop().
+ *
+ * @return ??? on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int sceKernelSelfStopUnloadModule(int unknown, SceSize argsize, void *argp);
+
+/**
+ * Stop and unload the current module.
+ *
+ * @param argsize - Size (in bytes) of the arguments that will be passed to module_stop().
+ * @param argp - Poitner to arguments that will be passed to module_stop().
+ * @param status - Return value from module_stop().
+ * @param option - Pointer to an optional ::SceKernelSMOption structure.
+ *
+ * @return ??? on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int sceKernelStopUnloadSelfModule(SceSize argsize, void *argp, int *status, SceKernelSMOption *option);
+
+
+typedef struct SceKernelModuleInfo {
+	SceSize 		size;
+	char 			nsegment;
+	char 			reserved[3];
+	int 			segmentaddr[4];
+	int 			segmentsize[4];
+	unsigned int 	entry_addr;
+	unsigned int 	gp_value;
+	unsigned int 	text_addr;
+	unsigned int 	text_size;
+	unsigned int 	data_size;
+	unsigned int 	bss_size;
+	/* The following is only available in the v1.5 firmware and above,
+	   but as sceKernelQueryModuleInfo is broken in v1.0 is doesn't matter ;) */
+	unsigned short  attribute;
+	unsigned char   version[2];
+	char            name[28];
+} SceKernelModuleInfo;
+
+/**
+  * Query the information about a loaded module from its UID.
+  * @note This fails on v1.0 firmware (and even it worked has a limited structure)
+  * so if you want to be compatible with both 1.5 and 1.0 (and you are running in 
+  * kernel mode) then call this function first then ::pspSdkQueryModuleInfoV1 
+  * if it fails, or make separate v1 and v1.5+ builds.
+  *
+  * @param modid - The UID of the loaded module.
+  * @param info - Pointer to a ::SceKernelModuleInfo structure.
+  * 
+  * @return 0 on success, otherwise one of ::PspKernelErrorCodes.
+  */
+int sceKernelQueryModuleInfo(SceUID modid, SceKernelModuleInfo *info);
+
+/**
+  * Get a list of module IDs. NOTE: This is only available on 1.5 firmware
+  * and above. For V1 use ::pspSdkGetModuleIdList.
+  *
+  * @param readbuf - Buffer to store the module list.
+  * @param readbufsize - Number of elements in the readbuffer.
+  * @param idcount - Returns the number of module ids
+  *
+  * @return >= 0 on success
+  */
+int sceKernelGetModuleIdList(SceUID *readbuf, int readbufsize, int *idcount);
+
+/**
+ * Get the ID of the module occupying the address
+ *
+ * @param moduleAddr - A pointer to the module
+ *
+ * @return >= 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelGetModuleIdByAddress(const void *moduleAddr);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspmodulemgr_kernel.h b/newlib/psp/include/pspmodulemgr_kernel.h
new file mode 100644
index 0000000..14f496f
--- /dev/null
+++ b/newlib/psp/include/pspmodulemgr_kernel.h
@@ -0,0 +1,67 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmodulemgr_kernel.h - Prototypes to manage modules.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef __MODMGRKERNEL_H__
+#define __MODMGRKERNEL_H__
+
+#include <pspkerneltypes.h>
+#include <pspmodulemgr.h>
+
+/** @defgroup ModuleMgrKern Kernel Module Manager Library
+  * This module contains the imports for the kernel's module management routines.
+  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup ModuleMgrKern Kernel Module Manager Library */
+/**@{*/
+
+/**
+  * Gets the current module list.
+  * 
+  * @param readbufsize - The size of the read buffer.
+  * @param readbuf     - Pointer to a buffer to store the IDs
+  *
+  * @return < 0 on error.
+  */
+int sceKernelGetModuleList(int readbufsize, SceUID *readbuf);
+
+/**
+  * Get the number of loaded modules.
+  *
+  * @return The number of loaded modules.
+  */
+int sceKernelModuleCount(void);
+
+/**
+ * Load a module from a buffer
+ *
+ * @param buf - Pointer to a buffer containing the module to load.  The buffer must reside at an
+ *              address that is a multiple to 64 bytes.
+ * @param bufsize - Size (in bytes) of the buffer pointed to by buf.
+ * @param flags - Unused, always 0.
+ * @param option - Pointer to an optional ::SceKernelLMOption structure.
+ *
+ * @return The UID of the loaded module on success, otherwise one of ::PspKernelErrorCodes.
+ */
+SceUID sceKernelLoadModuleBuffer(void *buf, SceSize bufsize, int flags, SceKernelLMOption *option);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspmp3.h b/newlib/psp/include/pspmp3.h
new file mode 100644
index 0000000..20a87ed
--- /dev/null
+++ b/newlib/psp/include/pspmp3.h
@@ -0,0 +1,201 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmp3.h - Prototypes for the sceMp3 library
+ *
+ * Copyright (c) 2008 David Perry <tias_dp@hotmail.com>
+ * Copyright (c) 2008 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+
+#ifndef __SCELIBMP3_H__
+#define __SCELIBMP3_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct SceMp3InitArg {
+	/** Stream start position */
+	SceUInt32	mp3StreamStart;
+	/** Unknown - set to 0 */
+	SceUInt32	unk1;
+	/** Stream end position */
+	SceUInt32	mp3StreamEnd;
+	/** Unknown - set to 0 */
+	SceUInt32	unk2;
+	/** Pointer to a buffer to contain raw mp3 stream data (+1472 bytes workspace) */
+	SceVoid*	mp3Buf;
+	/** Size of mp3Buf buffer (must be >= 8192) */
+	SceInt32	mp3BufSize;
+	/** Pointer to decoded pcm samples buffer */
+	SceVoid*	pcmBuf;
+	/** Size of pcmBuf buffer (must be >= 9216) */
+	SceInt32	pcmBufSize;
+} SceMp3InitArg;
+
+/**
+ * sceMp3ReserveMp3Handle
+ *
+ * @param args - Pointer to SceMp3InitArg structure
+ *
+ * @return sceMp3 handle on success, < 0 on error.
+ */
+SceInt32 sceMp3ReserveMp3Handle(SceMp3InitArg* args);
+
+/**
+ * sceMp3ReleaseMp3Handle
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3ReleaseMp3Handle(SceInt32 handle);
+
+/**
+ * sceMp3InitResource
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3InitResource();
+
+/**
+ * sceMp3TermResource
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3TermResource();
+
+/**
+ * sceMp3Init
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3Init(SceInt32 handle);
+
+/**
+ * sceMp3Decode
+ *
+ * @param handle - sceMp3 handle
+ * @param dst - Pointer to destination pcm samples buffer
+ *
+ * @return number of bytes in decoded pcm buffer, < 0 on error.
+ */
+SceInt32 sceMp3Decode(SceInt32 handle, SceShort16** dst);
+
+/**
+ * sceMp3GetInfoToAddStreamData
+ *
+ * @param handle - sceMp3 handle
+ * @param dst - Pointer to stream data buffer
+ * @param towrite - Space remaining in stream data buffer
+ * @param srcpos - Position in source stream to start reading from
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3GetInfoToAddStreamData(SceInt32 handle, SceUChar8** dst, SceInt32* towrite, SceInt32* srcpos);
+
+/**
+ * sceMp3NotifyAddStreamData
+ *
+ * @param handle - sceMp3 handle
+ * @param size - number of bytes added to the stream data buffer
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3NotifyAddStreamData(SceInt32 handle, SceInt32 size);
+
+/**
+ * sceMp3CheckStreamDataNeeded
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return 1 if more stream data is needed, < 0 on error.
+ */
+SceInt32 sceMp3CheckStreamDataNeeded(SceInt32 handle);
+
+/**
+ * sceMp3SetLoopNum
+ *
+ * @param handle - sceMp3 handle
+ * @param loop - Number of loops
+ *
+ * @return 0 if success, < 0 on error.
+ */
+SceInt32 sceMp3SetLoopNum(SceInt32 handle, SceInt32 loop);
+
+/**
+ * sceMp3GetLoopNum
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Number of loops
+ */
+SceInt32 sceMp3GetLoopNum(SceInt32 handle);
+
+/**
+ * sceMp3GetSumDecodedSample
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Number of decoded samples
+ */
+SceInt32 sceMp3GetSumDecodedSample(SceInt32 handle);
+
+/**
+ * sceMp3GetMaxOutputSample
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Number of max samples to output
+ */
+SceInt32 sceMp3GetMaxOutputSample(SceInt32 handle);
+
+/**
+ * sceMp3GetSamplingRate
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Sampling rate of the mp3
+ */
+SceInt32 sceMp3GetSamplingRate(SceInt32 handle);
+
+/**
+ * sceMp3GetBitRate
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Bitrate of the mp3
+ */
+SceInt32 sceMp3GetBitRate(SceInt32 handle);
+
+/**
+ * sceMp3GetMp3ChannelNum
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return Number of channels of the mp3
+ */
+SceInt32 sceMp3GetMp3ChannelNum(SceInt32 handle);
+
+/**
+ * sceMp3ResetPlayPosition
+ *
+ * @param handle - sceMp3 handle
+ *
+ * @return < 0 on error
+ */
+SceInt32 sceMp3ResetPlayPosition(SceInt32 handle); 
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspmpeg.h b/newlib/psp/include/pspmpeg.h
new file mode 100644
index 0000000..4a1d2f7
--- /dev/null
+++ b/newlib/psp/include/pspmpeg.h
@@ -0,0 +1,343 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmpeg.h - Prototypes for the sceMpeg library
+ *
+ * Copyright (c) 2006 Sorin P. C. <magik@hypermagik.com>
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+
+#ifndef __SCELIBMPEG_H__
+#define __SCELIBMPEG_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** points to "LIBMPEG" */
+typedef ScePVoid SceMpeg;
+
+/** some structure */
+typedef SceVoid  SceMpegStream;
+
+/** Ringbuffer callback */
+typedef SceInt32 (*sceMpegRingbufferCB)(ScePVoid pData, SceInt32 iNumPackets, ScePVoid pParam);
+
+typedef struct SceMpegRingbuffer
+{
+    /** packets */
+	SceInt32			iPackets;
+
+    /** unknown */
+	SceUInt32			iUnk0;
+    /** unknown */
+	SceUInt32			iUnk1;
+    /** unknown */
+	SceUInt32			iUnk2;
+    /** unknown */
+	SceUInt32			iUnk3;
+
+    /** pointer to data */
+	ScePVoid			pData;
+
+    /** ringbuffer callback */
+	sceMpegRingbufferCB	Callback;
+    /** callback param */
+	ScePVoid			pCBparam;
+
+    /** unknown */
+	SceUInt32			iUnk4;
+    /** unknown */
+	SceUInt32			iUnk5;
+    /** mpeg id */
+	SceMpeg				pSceMpeg;
+
+} SceMpegRingbuffer;
+
+typedef struct SceMpegAu
+{
+    /** presentation timestamp MSB */
+	SceUInt32			iPtsMSB;
+    /** presentation timestamp LSB */
+	SceUInt32			iPts;
+    /** decode timestamp MSB */
+	SceUInt32			iDtsMSB;
+    /** decode timestamp LSB */
+	SceUInt32			iDts;
+    /** Es buffer handle */
+	SceUInt32			iEsBuffer;
+    /** Au size */
+	SceUInt32			iAuSize;
+
+} SceMpegAu;
+
+#define SCE_MPEG_AVC_FORMAT_DEFAULT -1
+#define SCE_MPEG_AVC_FORMAT_5650 0
+#define SCE_MPEG_AVC_FORMAT_5551 1
+#define SCE_MPEG_AVC_FORMAT_4444 2
+#define SCE_MPEG_AVC_FORMAT_8888 3
+
+typedef struct SceMpegAvcMode
+{
+	/** unknown, set to -1 */
+	SceInt32			iUnk0;
+	/** Decode pixelformat */
+	SceInt32			iPixelFormat;
+
+} SceMpegAvcMode;
+
+/**
+ * sceMpegInit
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegInit();
+
+/**
+ * sceMpegFinish
+ */
+SceVoid sceMpegFinish();
+
+/**
+ * sceMpegRingbufferQueryMemSize
+ *
+ * @param iPackets - number of packets in the ringbuffer
+ *
+ * @return < 0 if error else ringbuffer data size.
+ */
+SceInt32 sceMpegRingbufferQueryMemSize(SceInt32 iPackets);
+
+/**
+ * sceMpegRingbufferConstruct
+ *
+ * @param Ringbuffer - pointer to a sceMpegRingbuffer struct
+ * @param iPackets - number of packets in the ringbuffer
+ * @param pData - pointer to allocated memory
+ * @param iSize - size of allocated memory, shoud be sceMpegRingbufferQueryMemSize(iPackets)
+ * @param Callback - ringbuffer callback
+ * @param pCBparam - param passed to callback
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegRingbufferConstruct(SceMpegRingbuffer* Ringbuffer, SceInt32 iPackets, ScePVoid pData, SceInt32 iSize, sceMpegRingbufferCB Callback, ScePVoid pCBparam);
+
+/**
+ * sceMpegRingbufferDestruct
+ *
+ * @param Ringbuffer - pointer to a sceMpegRingbuffer struct
+ */
+SceVoid sceMpegRingbufferDestruct(SceMpegRingbuffer* Ringbuffer);
+
+/**
+ * sceMpegQueryMemSize 
+ *
+ * @param Ringbuffer - pointer to a sceMpegRingbuffer struct
+ *
+ * @return < 0 if error else number of free packets in the ringbuffer.
+ */
+SceInt32 sceMpegRingbufferAvailableSize(SceMpegRingbuffer* Ringbuffer);
+
+/**
+ * sceMpegRingbufferPut
+ *
+ * @param Ringbuffer - pointer to a sceMpegRingbuffer struct
+ * @param iNumPackets - num packets to put into the ringbuffer
+ * @param iAvailable - free packets in the ringbuffer, should be sceMpegRingbufferAvailableSize()
+ *
+ * @return < 0 if error else number of packets.
+ */
+SceInt32 sceMpegRingbufferPut(SceMpegRingbuffer* Ringbuffer, SceInt32 iNumPackets, SceInt32 iAvailable);
+
+/**
+ * sceMpegQueryMemSize
+ *
+ * @param iUnk - Unknown, set to 0
+ *
+ * @return < 0 if error else decoder data size.
+ */
+SceInt32 sceMpegQueryMemSize(int iUnk);
+
+/**
+ * sceMpegCreate
+ *
+ * @param Mpeg - will be filled
+ * @param pData - pointer to allocated memory of size = sceMpegQueryMemSize()
+ * @param iSize - size of data, should be = sceMpegQueryMemSize()
+ * @param Ringbuffer - a ringbuffer
+ * @param iFrameWidth - display buffer width, set to 512 if writing to framebuffer
+ * @param iUnk1 - unknown, set to 0
+ * @param iUnk2 - unknown, set to 0
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegCreate(SceMpeg* Mpeg, ScePVoid pData, SceInt32 iSize, SceMpegRingbuffer* Ringbuffer, SceInt32 iFrameWidth, SceInt32 iUnk1, SceInt32 iUnk2);
+
+/**
+ * sceMpegDelete
+ *
+ * @param Mpeg - SceMpeg handle
+ */
+SceVoid sceMpegDelete(SceMpeg* Mpeg);
+
+/**
+ * sceMpegQueryStreamOffset
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pBuffer - pointer to file header
+ * @param iOffset - will contain stream offset in bytes, usually 2048
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegQueryStreamOffset(SceMpeg* Mpeg, ScePVoid pBuffer, SceInt32* iOffset);
+
+/**
+ * sceMpegQueryStreamSize
+ *
+ * @param pBuffer - pointer to file header
+ * @param iSize - will contain stream size in bytes
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegQueryStreamSize(ScePVoid pBuffer, SceInt32* iSize);
+
+/**
+ * sceMpegRegistStream
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param iStreamID - stream id, 0 for video, 1 for audio
+ * @param iUnk - unknown, set to 0
+ *
+ * @return 0 if error.
+ */
+SceMpegStream* sceMpegRegistStream(SceMpeg* Mpeg, SceInt32 iStreamID, SceInt32 iUnk);
+
+/**
+ * sceMpegUnRegistStream
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pStream - pointer to stream
+ */
+SceVoid sceMpegUnRegistStream(SceMpeg Mpeg, SceMpegStream* pStream);
+
+/**
+ * sceMpegFlushAllStreams
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegFlushAllStream(SceMpeg* Mpeg);
+
+/**
+ * sceMpegMallocAvcEsBuf
+ *
+ * @return 0 if error else pointer to buffer.
+ */
+ScePVoid sceMpegMallocAvcEsBuf(SceMpeg* Mpeg);
+
+/**
+ * sceMpegFreeAvcEsBuf
+ *
+ */
+SceVoid sceMpegFreeAvcEsBuf(SceMpeg* Mpeg, ScePVoid pBuf);
+
+/**
+ * sceMpegQueryAtracEsSize
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param iEsSize - will contain size of Es
+ * @param iOutSize - will contain size of decoded data
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegQueryAtracEsSize(SceMpeg* Mpeg, SceInt32* iEsSize, SceInt32* iOutSize);
+
+/**
+ * sceMpegInitAu
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pEsBuffer - prevously allocated Es buffer
+ * @param pAu - will contain pointer to Au
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegInitAu(SceMpeg* Mpeg, ScePVoid pEsBuffer, SceMpegAu* pAu);
+
+/**
+ * sceMpegGetAvcAu
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pStream - associated stream
+ * @param pAu - will contain pointer to Au
+ * @param iUnk - unknown
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegGetAvcAu(SceMpeg* Mpeg, SceMpegStream* pStream, SceMpegAu* pAu, SceInt32* iUnk);
+
+/**
+ * sceMpegAvcDecodeMode
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pMode - pointer to SceMpegAvcMode struct defining the decode mode (pixelformat)
+ * @return 0 if success.
+ */
+SceInt32 sceMpegAvcDecodeMode(SceMpeg* Mpeg, SceMpegAvcMode* pMode);
+
+/**
+ * sceMpegAvcDecode
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pAu - video Au
+ * @param iFrameWidth - output buffer width, set to 512 if writing to framebuffer
+ * @param pBuffer - buffer that will contain the decoded frame
+ * @param iInit - will be set to 0 on first call, then 1
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegAvcDecode(SceMpeg* Mpeg, SceMpegAu* pAu, SceInt32 iFrameWidth, ScePVoid pBuffer, SceInt32* iInit);
+
+/**
+ * sceMpegAvcDecodeStop
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param iFrameWidth - output buffer width, set to 512 if writing to framebuffer
+ * @param pBuffer - buffer that will contain the decoded frame
+ * @param iStatus - frame number
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegAvcDecodeStop(SceMpeg* Mpeg, SceInt32 iFrameWidth, ScePVoid pBuffer, SceInt32* iStatus);
+
+/**
+ * sceMpegGetAtracAu
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pStream - associated stream
+ * @param pAu - will contain pointer to Au
+ * @param pUnk - unknown
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegGetAtracAu(SceMpeg* Mpeg, SceMpegStream* pStream, SceMpegAu* pAu, ScePVoid pUnk);
+
+/**
+ * sceMpegAtracDecode
+ *
+ * @param Mpeg - SceMpeg handle
+ * @param pAu - video Au
+ * @param pBuffer - buffer that will contain the decoded frame
+ * @param iInit - set this to 1 on first call
+ *
+ * @return 0 if success.
+ */
+SceInt32 sceMpegAtracDecode(SceMpeg* Mpeg, SceMpegAu* pAu, ScePVoid pBuffer, SceInt32 iInit);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspmpegbase.h b/newlib/psp/include/pspmpegbase.h
new file mode 100644
index 0000000..e7bc3b6
--- /dev/null
+++ b/newlib/psp/include/pspmpegbase.h
@@ -0,0 +1,65 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmpegbase.h - Prototypes for the sceMpegbase library
+ *
+ * Copyright (c) 2006 Sorin P. C. <magik@hypermagik.com>
+ * Copyright (c) 2007 cooleyes
+ * Copyright (c) 2007 Alexander Berl <raphael@fx-world.org>
+ *
+ */
+
+#ifndef __SCELIBMPEGBASE_H__
+#define __SCELIBMPEGBASE_H__
+
+
+#include <psptypes.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct SceMpegLLI
+{
+	ScePVoid pSrc;
+	ScePVoid pDst;
+	ScePVoid Next;
+	SceInt32 iSize;
+} __attribute__((aligned(64))) SceMpegLLI;
+
+
+
+typedef struct SceMpegYCrCbBuffer
+{
+	SceInt32	iFrameBufferHeight16;
+	SceInt32	iFrameBufferWidth16;
+	SceInt32	iUnknown;			// Set to 0
+	SceInt32	iUnknown2;			// Set to 1
+	ScePVoid	pYBuffer;			// pointer to YBuffer (in VME EDRAM?)
+	ScePVoid	pYBuffer2;			// pointer to YBuffer + framebufferwidth*(frameheight/32)
+	ScePVoid	pCrBuffer;			// pointer to CrBuffer (in VME EDRAM?)
+	ScePVoid	pCbBuffer;			// pointer to CbBuffer (in VME EDRAM?)
+	ScePVoid	pCrBuffer2;			// pointer to CrBuffer + (framebufferwidth/2)*(frameheight/64)
+	ScePVoid	pCbBuffer2;			// pointer to CbBuffer + (framebufferwidth/2)*(frameheight/64)
+	SceInt32	iFrameHeight;
+	SceInt32	iFrameWidth;
+	SceInt32	iFrameBufferWidth;
+	SceInt32	iUnknown3[11];
+} __attribute__((aligned(64))) SceMpegYCrCbBuffer;
+
+
+SceInt32 sceMpegBaseYCrCbCopyVme(ScePVoid YUVBuffer, SceInt32 *Buffer, SceInt32 Type);
+SceInt32 sceMpegBaseCscInit(SceInt32 width);
+SceInt32 sceMpegBaseCscVme(ScePVoid pRGBbuffer, ScePVoid pRGBbuffer2, SceInt32 width, SceMpegYCrCbBuffer* pYCrCbBuffer);
+
+SceInt32 sceMpegbase_BEA18F91(SceMpegLLI *pLLI);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspmscm.h b/newlib/psp/include/pspmscm.h
new file mode 100644
index 0000000..69ed5b4
--- /dev/null
+++ b/newlib/psp/include/pspmscm.h
@@ -0,0 +1,66 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmscm.h - Memory stick utility functions
+ *
+ * Copyright (c) 2006 Adrahil
+ *
+ */
+#ifndef PSPMSCM_H
+#define PSPMSCM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Returns whether a memory stick is current inserted
+ *
+ * @return 1 if memory stick inserted, 0 if not or if < 0 on error
+ */
+static __inline__ int MScmIsMediumInserted(void)
+{
+	int status, ret;
+
+	ret = sceIoDevctl("mscmhc0:", 0x02025806, 0, 0, &status, sizeof(status));
+	if(ret < 0) return ret;
+	if(status != 1) return 0;
+
+	return 1;
+}
+
+/* Event which has occurred in the memory stick ejection callback, passed in arg2 */
+#define MS_CB_EVENT_INSERTED 1
+#define MS_CB_EVENT_EJECTED  2
+
+/**
+ * Registers a memory stick ejection callback
+ *
+ * @param cbid - The uid of an allocated callback
+ *
+ * @return 0 on success, < 0 on error
+ */
+static __inline__ int MScmRegisterMSInsertEjectCallback(SceUID cbid)
+{
+	return sceIoDevctl("fatms0:", 0x02415821, &cbid, sizeof(cbid), 0, 0);
+}
+
+/**
+ * Unregister a memory stick ejection callback
+ *
+ * @param cbid - The uid of an allocated callback
+ *
+ * @return 0 on success, < 0 on error
+ */
+static __inline__ int MScmUnregisterMSInsertEjectCallback(SceUID cbid)
+{
+	return sceIoDevctl("fatms0:", 0x02415822, &cbid, sizeof(cbid), 0, 0);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPMSCM_H */
diff --git a/newlib/psp/include/pspnand_driver.h b/newlib/psp/include/pspnand_driver.h
new file mode 100644
index 0000000..de8b13e
--- /dev/null
+++ b/newlib/psp/include/pspnand_driver.h
@@ -0,0 +1,75 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnand_driver.h - Definitions and interfaces to the NAND (flash) driver.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@0xd6.org>
+ *
+ */
+
+#ifndef PSPNAND_DRIVER_H
+#define PSPNAND_DRIVER_H
+
+#include <pspkerneltypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int sceNandSetWriteProtect(int protectFlag);
+
+int sceNandLock(int writeFlag);
+
+void sceNandUnlock(void);
+
+int sceNandReadStatus(void);
+
+int sceNandReset(int flag);
+
+int sceNandReadId(void *buf, SceSize size);
+
+int sceNandReadPages(u32 ppn, void *buf, void *buf2, u32 count);
+
+/*
+// sceNandWritePages
+// sceNandReadAccess
+// sceNandWriteAccess
+// sceNandEraseBlock
+// sceNandReadExtraOnly
+// sceNandCalcEcc
+// sceNandVerifyEcc
+// sceNandCollectEcc
+*/
+
+int sceNandGetPageSize(void);
+
+int sceNandGetPagesPerBlock(void);
+
+int sceNandGetTotalBlocks(void);
+
+/*
+// sceNandWriteBlock
+// sceNandWriteBlockWithVerify
+*/
+
+int sceNandReadBlockWithRetry(u32 ppn, void *buf, void *buf2);
+
+/*
+// sceNandVerifyBlockWithRetry
+// sceNandEraseBlockWithRetry
+*/
+
+int sceNandIsBadBlock(u32 ppn);
+
+/*
+// sceNandEraseAllBlock
+// sceNandTestBlock
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPNAND_DRIVER_H */
diff --git a/newlib/psp/include/pspnet.h b/newlib/psp/include/pspnet.h
new file mode 100644
index 0000000..55d5914
--- /dev/null
+++ b/newlib/psp/include/pspnet.h
@@ -0,0 +1,106 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet.h - PSP networking libraries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@0xd6.org>
+ * Copyright (c) 2008 David Perry <tias_dp@hotmail.com>
+ *
+ * Portions based on PspPet's wifi_03 sample code.
+ * 
+ */
+
+#ifndef PSPNET_H
+#define PSPNET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	
+typedef struct SceNetMallocStat
+{
+	int pool;
+	int maximum;
+	int free;
+	
+} SceNetMallocStat;
+
+/**
+ * Initialise the networking library
+ *
+ * @param poolsize - Memory pool size (appears to be for the whole of the networking library).
+ * @param calloutprio - Priority of the SceNetCallout thread.
+ * @param calloutstack - Stack size of the SceNetCallout thread (defaults to 4096 on non 1.5 firmware regardless of what value is passed).
+ * @param netintrprio - Priority of the SceNetNetintr thread.
+ * @param netintrstack - Stack size of the SceNetNetintr thread (defaults to 4096 on non 1.5 firmware regardless of what value is passed).
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetInit(int poolsize, int calloutprio, int calloutstack, int netintrprio, int netintrstack);
+	
+/**
+ * Terminate the networking library
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetTerm(void);
+
+/**
+ * Free (delete) thread info/data
+ *
+ * @param thid - The thread id.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetFreeThreadinfo(int thid);
+
+/**
+ * Abort a thread
+ *
+ * @param thid - The thread id.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetThreadAbort(int thid);
+
+/**
+ * Convert string to a Mac address
+ *
+ * @param name - The string to convert.
+ * @param mac - Pointer to a buffer to store the result.
+ */
+void sceNetEtherStrton(char *name, unsigned char *mac);
+
+/**
+ * Convert Mac address to a string
+ *
+ * @param mac - The Mac address to convert.
+ * @param name - Pointer to a buffer to store the result.
+ */
+void sceNetEtherNtostr(unsigned char *mac, char *name);
+
+/**
+ * Retrieve the local Mac address
+ *
+ * @param mac - Pointer to a buffer to store the result.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetGetLocalEtherAddr(unsigned char *mac);
+
+/**
+ * Retrieve the networking library memory usage
+ *
+ * @param stat - Pointer to a ::SceNetMallocStat type to store the result.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetGetMallocStat(SceNetMallocStat *stat);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPNET_H */
diff --git a/newlib/psp/include/pspnet_adhoc.h b/newlib/psp/include/pspnet_adhoc.h
new file mode 100644
index 0000000..3e1fa6f
--- /dev/null
+++ b/newlib/psp/include/pspnet_adhoc.h
@@ -0,0 +1,309 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_adhoc.h - PSP Adhoc networking libraries.
+ *
+ * Copyright (c) 2006 James F.
+ * Copyright (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ * Based on the adhoc code in SMS Plus
+ * 
+ */
+#ifndef __PSPNET_ADHOC_H__
+#define __PSPNET_ADHOC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** 
+ * Initialise the adhoc library.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocInit(void);
+
+/**
+ * Terminate the adhoc library
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocTerm(void);
+
+/**
+ * Create a PDP object.
+ *
+ * @param mac - Your MAC address (from sceWlanGetEtherAddr)
+ * @param port - Port to use, lumines uses 0x309
+ * @param bufsize - Socket buffer size, lumines sets to 0x400
+ * @param unk1 - Unknown, lumines sets to 0
+ *
+ * @return The ID of the PDP object (< 0 on error)
+ */
+int sceNetAdhocPdpCreate(unsigned char *mac, unsigned short port, unsigned int bufsize, int unk1);
+
+/**
+ * Delete a PDP object.
+ *
+ * @param id - The ID returned from ::sceNetAdhocPdpCreate
+ * @param unk1 - Unknown, set to 0
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocPdpDelete(int id, int unk1); 
+
+/**
+ * Set a PDP packet to a destination
+ *
+ * @param id - The ID as returned by ::sceNetAdhocPdpCreate
+ * @param destMacAddr - The destination MAC address, can be set to all 0xFF for broadcast
+ * @param port - The port to send to
+ * @param data - The data to send
+ * @param len - The length of the data.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return Bytes sent, < 0 on error
+ */
+int sceNetAdhocPdpSend(int id, unsigned char *destMacAddr, unsigned short port, void *data, unsigned int len, unsigned int timeout, int nonblock); 
+
+/**
+ * Receive a PDP packet
+ *
+ * @param id - The ID of the PDP object, as returned by ::sceNetAdhocPdpCreate
+ * @param srcMacAddr - Buffer to hold the source mac address of the sender
+ * @param port - Buffer to hold the port number of he received data
+ * @param data - Data buffer
+ * @param dataLength - The length of the data buffer
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return Number of bytes received, < 0 on error.
+ */
+int sceNetAdhocPdpRecv(int id, unsigned char *srcMacAddr, unsigned short *port, void *data, void *dataLength, unsigned int timeout, int nonblock);
+
+/**
+ * PDP status structure
+ */
+typedef struct pdpStatStruct
+{
+	/** Pointer to next PDP structure in list */
+	struct pdpStatStruct *next;
+	/** pdp ID */
+	int pdpId;
+	/** MAC address */
+	unsigned char mac[6];
+	/** Port */
+	unsigned short port;
+	/** Bytes received */
+	unsigned int rcvdData;
+} pdpStatStruct;
+
+/**
+ * Get the status of all PDP objects
+ *
+ * @param size - Pointer to the size of the stat array (e.g 20 for one structure)
+ * @param stat - Pointer to a list of ::pdpStatStruct structures.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocGetPdpStat(int *size, pdpStatStruct *stat);
+
+/**
+ * Create own game object type data.
+ *
+ * @param data - A pointer to the game object data.
+ * @param size - Size of the game data.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocGameModeCreateMaster(void *data, int size);
+
+/**
+ * Create peer game object type data.
+ *
+ * @param mac - The mac address of the peer.
+ * @param data - A pointer to the game object data.
+ * @param size - Size of the game data.
+ *
+ * @return The id of the replica on success, < 0 on error.
+ */
+int sceNetAdhocGameModeCreateReplica(unsigned char *mac, void *data, int size);
+
+/**
+ * Update own game object type data.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocGameModeUpdateMaster(void);
+
+/**
+ * Update peer game object type data.
+ *
+ * @param id - The id of the replica returned by sceNetAdhocGameModeCreateReplica.
+ * @param unk1 - Pass 0.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocGameModeUpdateReplica(int id, int unk1);
+
+/**
+ * Delete own game object type data.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocGameModeDeleteMaster(void);
+
+/**
+ * Delete peer game object type data.
+ *
+ * @param id - The id of the replica.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocGameModeDeleteReplica(int id);
+
+/**
+ * Open a PTP connection
+ *
+ * @param srcmac - Local mac address.
+ * @param srcport - Local port.
+ * @param destmac - Destination mac.
+ * @param destport - Destination port
+ * @param bufsize - Socket buffer size
+ * @param delay - Interval between retrying (microseconds).
+ * @param count - Number of retries.
+ * @param unk1 - Pass 0.
+ *
+ * @return A socket ID on success, < 0 on error.
+ */
+int sceNetAdhocPtpOpen(unsigned char *srcmac, unsigned short srcport, unsigned char *destmac, unsigned short destport, unsigned int bufsize, unsigned int delay, int count, int unk1);
+
+/**
+ * Wait for connection created by sceNetAdhocPtpOpen()
+ *
+ * @param id - A socket ID.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocPtpConnect(int id, unsigned int timeout, int nonblock);
+
+/**
+ * Wait for an incoming PTP connection
+ *
+ * @param srcmac - Local mac address.
+ * @param srcport - Local port.
+ * @param bufsize - Socket buffer size
+ * @param delay - Interval between retrying (microseconds).
+ * @param count - Number of retries.
+ * @param queue - Connection queue length.
+ * @param unk1 - Pass 0.
+ *
+ * @return A socket ID on success, < 0 on error.
+ */
+int sceNetAdhocPtpListen(unsigned char *srcmac, unsigned short srcport, unsigned int bufsize, unsigned int delay, int count, int queue, int unk1);
+
+/**
+ * Accept an incoming PTP connection
+ *
+ * @param id - A socket ID.
+ * @param mac - Connecting peers mac.
+ * @param port - Connecting peers port.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocPtpAccept(int id, unsigned char *mac, unsigned short *port, unsigned int timeout, int nonblock);
+
+/**
+ * Send data
+ *
+ * @param id - A socket ID.
+ * @param data - Data to send.
+ * @param datasize - Size of the data.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return 0 success, < 0 on error.
+ */
+int sceNetAdhocPtpSend(int id, void *data, int *datasize, unsigned int timeout, int nonblock);
+
+/**
+ * Receive data
+ *
+ * @param id - A socket ID.
+ * @param data - Buffer for the received data.
+ * @param datasize - Size of the data received.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocPtpRecv(int id, void *data, int *datasize, unsigned int timeout, int nonblock);
+
+/**
+ * Wait for data in the buffer to be sent
+ *
+ * @param id - A socket ID.
+ * @param timeout - Timeout in microseconds.
+ * @param nonblock - Set to 0 to block, 1 for non-blocking.
+ *
+ * @return A socket ID on success, < 0 on error.
+ */
+int sceNetAdhocPtpFlush(int id, unsigned int timeout, int nonblock);
+
+/**
+ * Close a socket
+ *
+ * @param id - A socket ID.
+ * @param unk1 - Pass 0.
+ *
+ * @return A socket ID on success, < 0 on error.
+ */
+int sceNetAdhocPtpClose(int id, int unk1);
+
+/**
+ * PTP status structure
+ */
+typedef struct ptpStatStruct
+{
+	/** Pointer to next PTP structure in list */
+	struct ptpStatStruct *next;
+	/** ptp ID */
+	int ptpId;
+	/** MAC address */
+	unsigned char mac[6];
+	/** Peer MAC address */
+	unsigned char peermac[6];
+	/** Port */
+	unsigned short port;
+	/** Peer Port */
+	unsigned short peerport;
+	/** Bytes sent */
+	unsigned int sentData;
+	/** Bytes received */
+	unsigned int rcvdData;
+	/** Unknown */
+	int unk1;
+} ptpStatStruct;
+
+/**
+ * Get the status of all PTP objects
+ *
+ * @param size - Pointer to the size of the stat array (e.g 20 for one structure)
+ * @param stat - Pointer to a list of ::ptpStatStruct structures.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocGetPtpStat(int *size, ptpStatStruct *stat);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspnet_adhocctl.h b/newlib/psp/include/pspnet_adhocctl.h
new file mode 100644
index 0000000..f357322
--- /dev/null
+++ b/newlib/psp/include/pspnet_adhocctl.h
@@ -0,0 +1,288 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_adhocctl.h - PSP Adhoc control networking libraries.
+ *
+ * Copyright (c) 2006 James F.
+ * Copyright (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ * Based on the adhoc code in SMS Plus
+ * 
+ */
+#ifndef __PSPNETCTL_ADHOC_H__
+#define __PSPNETCTL_ADHOC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Product structure */
+struct productStruct
+{
+	/** Unknown, set to 0, other values used are 1 and 2. Not sure on what they represent */
+	int unknown;
+	/** The product ID string */
+	char product[9];
+	/* possibly padding */
+	char unk[3];
+};
+
+/** Peer info structure */
+struct SceNetAdhocctlPeerInfo
+{
+	struct SceNetAdhocctlPeerInfo *next;
+	/** Nickname */
+	char nickname[128];	
+	/** Mac address */
+	unsigned char mac[6];
+	/** Unknown */
+	unsigned char unknown[6];
+	/** Time stamp */
+	unsigned long timestamp;
+};
+
+/** Scan info structure */
+struct SceNetAdhocctlScanInfo
+{
+	struct SceNetAdhocctlScanInfo *next;
+	/** Channel number */
+	int channel;
+	/** Name of the connection (alphanumeric characters only) */
+	char name[8];
+	/** The BSSID */
+	unsigned char bssid[6];
+	/** Unknown */
+	unsigned char unknown[2];
+	/** Unknown */
+	int unknown2;
+};
+
+struct SceNetAdhocctlGameModeInfo
+{
+	/** Number of peers (including self) */
+	int count;
+	/** MAC addresses of peers (including self) */
+	unsigned char macs[16][6];
+};
+
+/** Params structure */
+struct SceNetAdhocctlParams
+{
+	/** Channel number */
+	int channel;
+	/** Name of the connection */
+	char name[8];
+	/** The BSSID */
+	unsigned char bssid[6];
+	/** Nickname */
+	char nickname[128];
+};
+
+/**
+ * Initialise the Adhoc control library
+ *
+ * @param stacksize - Stack size of the adhocctl thread. Set to 0x2000
+ * @param priority - Priority of the adhocctl thread. Set to 0x30
+ * @param product - Pass a filled in ::productStruct
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocctlInit(int stacksize, int priority, struct productStruct *product);
+
+/**
+ * Terminate the Adhoc control library
+ *
+ * @return 0 on success, < on error.
+ */
+int sceNetAdhocctlTerm(void);
+
+/**
+ * Connect to the Adhoc control
+ *
+ * @param name - The name of the connection (maximum 8 alphanumeric characters).
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlConnect(const char *name);
+
+/**
+ * Disconnect from the Adhoc control
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocctlDisconnect(void);
+
+/**
+ * Get the state of the Adhoc control
+ *
+ * @param event - Pointer to an integer to receive the status. Can continue when it becomes 1.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocctlGetState(int *event);
+
+/**
+ * Connect to the Adhoc control (as a host)
+ *
+ * @param name - The name of the connection (maximum 8 alphanumeric characters).
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlCreate(const char *name);
+
+/**
+ * Connect to the Adhoc control (as a client)
+ *
+ * @param scaninfo - A valid ::SceNetAdhocctlScanInfo struct that has been filled by sceNetAchocctlGetScanInfo
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlJoin(struct SceNetAdhocctlScanInfo *scaninfo);
+
+/**
+ * Get the adhoc ID
+ *
+ * @param product - A pointer to a  ::productStruct
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetAdhocId(struct productStruct *product);
+
+/**
+ * Connect to the Adhoc control game mode (as a host)
+ *
+ * @param name - The name of the connection (maximum 8 alphanumeric characters).
+ * @param unknown - Pass 1.
+ * @param num - The total number of players (including the host).
+ * @param macs - A pointer to a list of the participating mac addresses, host first, then clients.
+ * @param timeout - Timeout in microseconds.
+ * @param unknown2 - pass 0.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlCreateEnterGameMode(const char *name, int unknown, int num, unsigned char *macs, unsigned int timeout, int unknown2);
+
+/**
+ * Connect to the Adhoc control game mode (as a client)
+ *
+ * @param name - The name of the connection (maximum 8 alphanumeric characters).
+ * @param hostmac - The mac address of the host.
+ * @param timeout - Timeout in microseconds.
+ * @param unknown - pass 0.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlJoinEnterGameMode(const char *name, unsigned char *hostmac, unsigned int timeout, int unknown);
+
+/**
+ * Get game mode information
+ *
+ * @param gamemodeinfo - Pointer to store the info.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetGameModeInfo(struct SceNetAdhocctlGameModeInfo *gamemodeinfo);
+
+/**
+ * Exit game mode.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlExitGameMode(void);
+
+/**
+ * Get a list of peers
+ *
+ * @param length - The length of the list.
+ * @param buf - An allocated area of size length.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetPeerList(int *length, void *buf);
+
+/**
+ * Get peer information
+ *
+ * @param mac - The mac address of the peer.
+ * @param size - Size of peerinfo.
+ * @param peerinfo - Pointer to store the information.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetPeerInfo(unsigned char *mac, int size, struct SceNetAdhocctlPeerInfo *peerinfo);
+
+/**
+ * Scan the adhoc channels
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlScan(void);
+
+/**
+ * Get the results of a scan
+ *
+ * @param length - The length of the list.
+ * @param buf - An allocated area of size length.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetScanInfo(int *length, void *buf);
+
+typedef void (*sceNetAdhocctlHandler)(int flag, int error, void *unknown);
+
+/**
+ * Register an adhoc event handler
+ *
+ * @param handler - The event handler.
+ * @param unknown - Pass NULL.
+ *
+ * @return Handler id on success, < 0 on error.
+ */
+int sceNetAdhocctlAddHandler(sceNetAdhocctlHandler handler, void *unknown);
+
+/**
+ * Delete an adhoc event handler
+ *
+ * @param id - The handler id as returned by sceNetAdhocctlAddHandler.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlDelHandler(int id);
+
+/**
+ * Get nickname from a mac address
+ *
+ * @param mac - The mac address.
+ * @param nickname - Pointer to a char buffer where the nickname will be stored.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetNameByAddr(unsigned char *mac, char *nickname);
+
+/**
+ * Get mac address from nickname
+ *
+ * @param nickname - The nickname.
+ * @param length - The length of the list.
+ * @param buf - An allocated area of size length.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetAddrByName(char *nickname, int *length, void *buf);
+
+/**
+ * Get Adhocctl parameter
+ *
+ * @param params - Pointer to a ::SceNetAdhocctlParams
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocctlGetParameter(struct SceNetAdhocctlParams *params);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspnet_adhocmatching.h b/newlib/psp/include/pspnet_adhocmatching.h
new file mode 100644
index 0000000..b361056
--- /dev/null
+++ b/newlib/psp/include/pspnet_adhocmatching.h
@@ -0,0 +1,268 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_adhocmatching.h - PSP Adhoc matching networking libraries.
+ *
+ * Copyright (c) 2006 James F.
+ * Copyright (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ * Based on the adhoc code in SMS Plus
+ * 
+ */
+#ifndef __PSPNETMATCHING_ADHOC_H__
+#define __PSPNETMATCHING_ADHOC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** 
+ * Matching events used in pspAdhocMatchingCallback
+ */
+enum pspAdhocMatchingEvents
+{
+	/** Hello event. optdata contains data if optlen > 0. */
+	PSP_ADHOC_MATCHING_EVENT_HELLO =		1,
+	/** Join request. optdata contains data if optlen > 0. */
+	PSP_ADHOC_MATCHING_EVENT_JOIN =			2,
+	/** Target left matching. */
+	PSP_ADHOC_MATCHING_EVENT_LEFT =			3,
+	/** Join request rejected. */
+	PSP_ADHOC_MATCHING_EVENT_REJECT =		4,
+	/** Join request cancelled. */
+	PSP_ADHOC_MATCHING_EVENT_CANCEL =		5,
+	/** Join request accepted. optdata contains data if optlen > 0. */
+	PSP_ADHOC_MATCHING_EVENT_ACCEPT =		6,
+	/** Matching is complete. */
+	PSP_ADHOC_MATCHING_EVENT_COMPLETE =		7,
+	/** Ping timeout event. */
+	PSP_ADHOC_MATCHING_EVENT_TIMEOUT =		8,
+	/** Error event. */
+	PSP_ADHOC_MATCHING_EVENT_ERROR =		9,
+	/** Peer disconnect event. */
+	PSP_ADHOC_MATCHING_EVENT_DISCONNECT =	10,
+	/** Data received event. optdata contains data if optlen > 0. */
+	PSP_ADHOC_MATCHING_EVENT_DATA =			11,
+	/** Data acknowledged event. */
+	PSP_ADHOC_MATCHING_EVENT_DATA_CONFIRM =	12,
+	/** Data timeout event. */
+	PSP_ADHOC_MATCHING_EVENT_DATA_TIMEOUT =	13
+};
+
+/** 
+ * Matching modes used in sceNetAdhocMatchingCreate
+ */
+enum pspAdhocMatchingModes
+{
+	/** Host */
+	PSP_ADHOC_MATCHING_MODE_HOST =		1,
+	/** Client */
+	PSP_ADHOC_MATCHING_MODE_CLIENT =	2,
+	/** Peer to peer */
+	PSP_ADHOC_MATCHING_MODE_PTP =		3
+};
+
+/** 
+ * Linked list for sceNetAdhocMatchingGetMembers
+ */
+struct pspAdhocMatchingMember
+{
+	struct pspAdhocMatchingMember *next;
+	unsigned char mac[6];
+	char unknown[2];
+};
+
+/** 
+ * Linked list for sceNetAdhocMatchingGetMembers
+ */
+struct pspAdhocPoolStat
+{
+	/** Size of the pool */
+	int size;
+	/** Maximum size of the pool */
+	int maxsize;
+	/** Unused memory in the pool */
+	int freesize;
+};
+
+/** 
+ * Initialise the Adhoc matching library
+ *
+ * @param memsize - Internal memory pool size. Lumines uses 0x20000
+ * 
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocMatchingInit(int memsize);
+
+/**
+ * Terminate the Adhoc matching library
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocMatchingTerm(void);
+
+/** Matching callback */
+typedef void (*pspAdhocMatchingCallback)(int matchingid, int event, unsigned char *mac, int optlen, void *optdata);
+
+/**
+ * Create an Adhoc matching object
+ *
+ * @param mode - One of ::pspAdhocMatchingModes
+ * @param maxpeers - Maximum number of peers to match (only used when mode is PSP_ADHOC_MATCHING_MODE_HOST)
+ * @param port - Port. Lumines uses 0x22B
+ * @param bufsize - Receiving buffer size
+ * @param hellodelay - Hello message send delay in microseconds (only used when mode is PSP_ADHOC_MATCHING_MODE_HOST or PSP_ADHOC_MATCHING_MODE_PTP)
+ * @param pingdelay - Ping send delay in microseconds. Lumines uses 0x5B8D80 (only used when mode is PSP_ADHOC_MATCHING_MODE_HOST or PSP_ADHOC_MATCHING_MODE_PTP)
+ * @param initcount - Initial count of the of the resend counter. Lumines uses 3
+ * @param msgdelay - Message send delay in microseconds
+ * @param callback - Callback to be called for matching
+ *
+ * @return ID of object on success, < 0 on error.
+ */
+int sceNetAdhocMatchingCreate(int mode, int maxpeers, unsigned short port, int bufsize, unsigned int hellodelay, unsigned int pingdelay, int initcount, unsigned int msgdelay, pspAdhocMatchingCallback callback);
+
+/**
+ * Delete an Adhoc matching object
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingDelete(int matchingid);
+
+/**
+ * Start a matching object
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param evthpri - Priority of the event handler thread. Lumines uses 0x10
+ * @param evthstack - Stack size of the event handler thread. Lumines uses 0x2000
+ * @param inthpri - Priority of the input handler thread. Lumines uses 0x10
+ * @param inthstack - Stack size of the input handler thread. Lumines uses 0x2000
+ * @param optlen - Size of hellodata
+ * @param optdata - Pointer to block of data passed to callback
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetAdhocMatchingStart(int matchingid, int evthpri, int evthstack, int inthpri, int inthstack, int optlen, void *optdata);
+
+/** 
+ * Stop a matching object
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingStop(int matchingid);
+
+/**
+ * Select a matching target
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param mac - MAC address to select
+ * @param optlen - Optional data length
+ * @param optdata - Pointer to the optional data
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingSelectTarget(int matchingid, unsigned char *mac, int optlen, void *optdata);
+
+/**
+ * Cancel a matching target
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param mac - The MAC address to cancel
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingCancelTarget(int matchingid, unsigned char *mac);
+
+/**
+ * Cancel a matching target (with optional data)
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param mac - The MAC address to cancel
+ * @param optlen - Optional data length
+ * @param optdata - Pointer to the optional data
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingCancelTargetWithOpt(int matchingid, unsigned char *mac, int optlen, void *optdata);
+
+/**
+ * Send data to a matching target
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param mac - The MAC address to send the data to
+ * @param datalen - Length of the data
+ * @param data - Pointer to the data
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingSendData(int matchingid, unsigned char *mac, int datalen, void *data);
+
+/**
+ * Abort a data send to a matching target
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param mac - The MAC address to send the data to
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingAbortSendData(int matchingid, unsigned char *mac);
+
+/**
+ * Set the optional hello message
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param optlen - Length of the hello data
+ * @param optdata - Pointer to the hello data
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingSetHelloOpt(int matchingid, int optlen, void *optdata);
+
+/**
+ * Get the optional hello message
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param optlen - Length of the hello data
+ * @param optdata - Pointer to the hello data
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingGetHelloOpt(int matchingid, int *optlen, void *optdata);
+
+/**
+ * Get a list of matching members
+ *
+ * @param matchingid - The ID returned from ::sceNetAdhocMatchingCreate
+ * @param length - The length of the list.
+ * @param buf - An allocated area of size length.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingGetMembers(int matchingid, int *length, void *buf);
+
+/**
+ * Get the maximum memory usage by the matching library
+ *
+ * @return The memory usage on success, < 0 on error.
+ */
+int sceNetAdhocMatchingGetPoolMaxAlloc(void);
+
+/**
+ * Get the status of the memory pool used by the matching library
+ *
+ * @param poolstat - A ::pspAdhocPoolStat.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceNetAdhocMatchingGetPoolStat(struct pspAdhocPoolStat *poolstat);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspnet_apctl.h b/newlib/psp/include/pspnet_apctl.h
new file mode 100644
index 0000000..9bcce95
--- /dev/null
+++ b/newlib/psp/include/pspnet_apctl.h
@@ -0,0 +1,170 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_apctl.h - PSP networking libraries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@0xd6.org>
+ * Copyright (c) 2008 David Perry <tias_dp@hotmail.com>
+ *
+ * Portions based on PspPet's wifi_03 sample code.
+ * 
+ */
+
+#ifndef PSPNET_APCTL_H
+#define PSPNET_APCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	
+#define PSP_NET_APCTL_STATE_DISCONNECTED	0
+#define PSP_NET_APCTL_STATE_SCANNING		1
+#define PSP_NET_APCTL_STATE_JOINING			2
+#define PSP_NET_APCTL_STATE_GETTING_IP      3
+#define PSP_NET_APCTL_STATE_GOT_IP			4
+#define PSP_NET_APCTL_STATE_EAP_AUTH		5
+#define PSP_NET_APCTL_STATE_KEY_EXCHANGE	6
+	
+#define PSP_NET_APCTL_EVENT_CONNECT_REQUEST		0
+#define PSP_NET_APCTL_EVENT_SCAN_REQUEST		1
+#define PSP_NET_APCTL_EVENT_SCAN_COMPLETE		2
+#define PSP_NET_APCTL_EVENT_ESTABLISHED			3
+#define PSP_NET_APCTL_EVENT_GET_IP				4
+#define PSP_NET_APCTL_EVENT_DISCONNECT_REQUEST	5
+#define PSP_NET_APCTL_EVENT_ERROR				6
+#define PSP_NET_APCTL_EVENT_INFO				7
+#define PSP_NET_APCTL_EVENT_EAP_AUTH			8
+#define PSP_NET_APCTL_EVENT_KEY_EXCHANGE		9
+#define PSP_NET_APCTL_EVENT_RECONNECT			10
+	
+#define PSP_NET_APCTL_INFO_PROFILE_NAME		0
+#define PSP_NET_APCTL_INFO_BSSID			1
+#define PSP_NET_APCTL_INFO_SSID				2
+#define PSP_NET_APCTL_INFO_SSID_LENGTH		3
+#define PSP_NET_APCTL_INFO_SECURITY_TYPE	4
+#define PSP_NET_APCTL_INFO_STRENGTH			5
+#define PSP_NET_APCTL_INFO_CHANNEL			6
+#define PSP_NET_APCTL_INFO_POWER_SAVE		7
+#define PSP_NET_APCTL_INFO_IP				8
+#define PSP_NET_APCTL_INFO_SUBNETMASK		9
+#define PSP_NET_APCTL_INFO_GATEWAY			10
+#define PSP_NET_APCTL_INFO_PRIMDNS			11
+#define PSP_NET_APCTL_INFO_SECDNS			12
+#define PSP_NET_APCTL_INFO_USE_PROXY		13
+#define PSP_NET_APCTL_INFO_PROXY_URL		14
+#define PSP_NET_APCTL_INFO_PROXY_PORT		15
+#define PSP_NET_APCTL_INFO_8021_EAP_TYPE	16
+#define PSP_NET_APCTL_INFO_START_BROWSER	17
+#define PSP_NET_APCTL_INFO_WIFISP			18
+	
+#define PSP_NET_APCTL_INFO_SECURITY_TYPE_NONE	0
+#define PSP_NET_APCTL_INFO_SECURITY_TYPE_WEP	1
+#define PSP_NET_APCTL_INFO_SECURITY_TYPE_WPA	2
+	
+union SceNetApctlInfo 
+{ 
+	char name[64];				/* Name of the config used */ 
+	unsigned char bssid[6];		/* MAC address of the access point */ 
+	unsigned char ssid[32];		/* ssid */ 			
+	unsigned int ssidLength;	/* ssid string length*/ 
+	unsigned int securityType;	/* 0 for none, 1 for WEP, 2 for WPA) */ 
+	unsigned char strength;		/* Signal strength in % */ 
+	unsigned char channel;		/* Channel */ 
+	unsigned char powerSave;	/* 1 on, 0 off */ 
+	char ip[16];				/* PSP's ip */ 
+	char subNetMask[16];		/* Subnet mask */ 
+	char gateway[16];			/* Gateway */ 
+	char primaryDns[16];		/* Primary DNS */ 
+	char secondaryDns[16];		/* Secondary DNS */ 
+	unsigned int useProxy;		/* 1 for proxy, 0 for no proxy */ 
+	char proxyUrl[128];			/* Proxy url */ 
+	unsigned short proxyPort;	/* Proxy port */ 
+	unsigned int eapType;		/* 0 is none, 1 is EAP-MD5 */ 
+	unsigned int startBrowser;	/* Should browser be started */ 
+	unsigned int wifisp;		/* 1 if connection is for Wifi service providers (WISP) */ 
+
+};
+	
+typedef void (*sceNetApctlHandler)(int oldState, int newState, int event, int error, void *pArg);
+
+/**
+ * Init the apctl.
+ *
+ * @param stackSize - The stack size of the internal thread.
+ *
+ * @param initPriority - The priority of the internal thread.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlInit(int stackSize, int initPriority);
+
+/**
+ * Terminate the apctl.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlTerm(void);
+
+/**
+ * Get the apctl information.
+ *
+ * @param code - One of the PSP_NET_APCTL_INFO_* defines.
+ *
+ * @param pInfo - Pointer to a ::SceNetApctlInfo.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlGetInfo(int code, union SceNetApctlInfo *pInfo);
+
+/**
+ * Add an apctl event handler.
+ *
+ * @param handler - Pointer to the event handler function.
+ *
+ * @param pArg - Value to be passed to the pArg parameter of the handler function.
+ *
+ * @return A handler id or < 0 on error.
+ */
+int sceNetApctlAddHandler(sceNetApctlHandler handler, void *pArg);
+	
+/**
+ * Delete an apctl event handler.
+ *
+ * @param handlerId - A handler as created returned from sceNetApctlAddHandler.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlDelHandler(int handlerId);
+
+/**
+ * Connect to an access point.
+ *
+ * @param connIndex - The index of the connection.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlConnect(int connIndex);
+
+/**
+ * Disconnect from an access point.
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlDisconnect(void);
+
+/**
+ * Get the state of the access point connection.
+ *
+ * @param pState - Pointer to receive the current state (one of the PSP_NET_APCTL_STATE_* defines).
+ *
+ * @return < 0 on error.
+ */
+int sceNetApctlGetState(int *pState);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPNET_APCTL_H */
diff --git a/newlib/psp/include/pspnet_inet.h b/newlib/psp/include/pspnet_inet.h
new file mode 100644
index 0000000..a4bb6a0
--- /dev/null
+++ b/newlib/psp/include/pspnet_inet.h
@@ -0,0 +1,59 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_inet.h - PSP networking libraries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@0xd6.org>
+ *
+ * Portions based on PspPet's wifi_03 sample code.
+ * 
+ */
+
+#ifndef PSPNET_INET_H
+#define PSPNET_INET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+/** 
+ *  This struct is needed because tv_sec size is different from what newlib expect
+ *  Newlib expects 64bits for seconds and PSP expects 32bits
+ */
+struct SceNetInetTimeval {
+    uint32_t tv_sec;
+    uint32_t tv_usec;
+};
+
+int sceNetInetInit(void);
+int sceNetInetSelect(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct SceNetInetTimeval *timeout);
+int sceNetInetTerm(void);
+int sceNetInetGetErrno(void);
+int	sceNetInetAccept(int s, struct sockaddr *addr, socklen_t *addrlen);
+int	sceNetInetBind(int s, const struct sockaddr *my_addr, socklen_t addrlen);
+int	sceNetInetConnect(int s, const struct sockaddr *serv_addr, socklen_t addrlen);
+int	sceNetInetGetsockopt(int s, int level, int optname, void *optval, socklen_t *optlen);
+int	sceNetInetListen(int s, int backlog);
+size_t	sceNetInetRecv(int s, void *buf, size_t len, int flags);
+size_t	sceNetInetRecvfrom(int s, void *buf, size_t flags, int, struct sockaddr *from, socklen_t *fromlen);
+size_t	sceNetInetSend(int s, const void *buf, size_t len, int flags);
+size_t	sceNetInetSendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
+int	sceNetInetSetsockopt(int s, int level, int optname, const void *optval, socklen_t optlen);
+int	sceNetInetShutdown(int s, int how);
+int	sceNetInetSocket(int domain, int type, int protocol);
+int sceNetInetClose(int s);
+int sceNetInetGetErrno(void);
+int	sceNetInetGetpeername(int s, struct sockaddr *name, socklen_t *namelen);
+int	sceNetInetGetsockname(int s, struct sockaddr *name, socklen_t *namelen);
+ssize_t sceNetInetSendmsg(int s, const struct msghdr *msg, int flags);
+ssize_t sceNetInetRecvmsg(int s, struct msghdr *msg, int flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPNET_INET_H */
diff --git a/newlib/psp/include/pspnet_resolver.h b/newlib/psp/include/pspnet_resolver.h
new file mode 100644
index 0000000..df0ff28
--- /dev/null
+++ b/newlib/psp/include/pspnet_resolver.h
@@ -0,0 +1,97 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspnet_resolver.h - PSP networking libraries.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@0xd6.org>
+ *
+ * Portions based on PspPet's wifi_03 sample code.
+ * 
+ */
+
+#ifndef PSPNET_RESOLVER_H
+#define PSPNET_RESOLVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <netinet/in.h>
+
+/**
+ * Inititalise the resolver library
+ *
+ * @return 0 on sucess, < 0 on error.
+ */
+int sceNetResolverInit(void);
+
+/**
+ * Create a resolver object
+ *
+ * @param rid - Pointer to receive the resolver id
+ * @param buf - Temporary buffer
+ * @param buflen - Length of the temporary buffer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverCreate(int *rid, void *buf, SceSize buflen);
+
+/**
+ * Delete a resolver
+ *
+ * @param rid - The resolver to delete
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverDelete(int rid);
+
+/**
+ * Begin a name to address lookup
+ *
+ * @param rid - Resolver id
+ * @param hostname - Name to resolve
+ * @param addr - Pointer to in_addr structure to receive the address
+ * @param timeout - Number of seconds before timeout
+ * @param retry - Number of retires
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverStartNtoA(int rid, const char *hostname, struct in_addr* addr, unsigned int timeout, int retry);
+
+/**
+ * Begin a address to name lookup
+ *
+ * @param rid -Resolver id
+ * @param addr - Pointer to the address to resolve
+ * @param hostname - Buffer to receive the name
+ * @param hostname_len - Length of the buffer
+ * @param timeout - Number of seconds before timeout
+ * @param retry - Number of retries
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverStartAtoN(int rid, const struct in_addr* addr, char *hostname, SceSize hostname_len, unsigned int timeout, int retry);
+
+/**
+ * Stop a resolver operation
+ * 
+ * @param rid - Resolver id
+ * 
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverStop(int rid);
+
+/**
+ * Terminate the resolver library
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceNetResolverTerm(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPNET_RESOLVER_H */
diff --git a/newlib/psp/include/pspopenpsid.h b/newlib/psp/include/pspopenpsid.h
new file mode 100644
index 0000000..949924b
--- /dev/null
+++ b/newlib/psp/include/pspopenpsid.h
@@ -0,0 +1,30 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspopenpsid.h - Prototypes for the OpenPSID library
+ *
+ * Copyright (c) 2008 InsertWittyName (David Perry) 
+ *
+ */
+ 
+#ifndef __PSPOPENPSID_H__
+#define __PSPOPENPSID_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct PspOpenPSID
+{
+	unsigned char data[16];
+} PspOpenPSID;
+
+int sceOpenPSIDGetOpenPSID(PspOpenPSID *openpsid);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __PSPOPENPSID_H__ */
diff --git a/newlib/psp/include/psppower.h b/newlib/psp/include/psppower.h
new file mode 100644
index 0000000..bbd3766
--- /dev/null
+++ b/newlib/psp/include/psppower.h
@@ -0,0 +1,279 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psppower.h - Prototypes for the scePower library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2005 David Perry <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __POWER_H__
+#define __POWER_H__
+
+#include <pspkerneltypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Power callback flags
+ */
+ /*indicates the power switch it pushed, putting the unit into suspend mode*/
+#define PSP_POWER_CB_POWER_SWITCH	0x80000000
+/*indicates the hold switch is on*/
+#define PSP_POWER_CB_HOLD_SWITCH	0x40000000
+/*what is standby mode?*/
+#define PSP_POWER_CB_STANDBY		0x00080000
+/*indicates the resume process has been completed (only seems to be triggered when another event happens)*/
+#define PSP_POWER_CB_RESUME_COMPLETE	0x00040000
+/*indicates the unit is resuming from suspend mode*/
+#define PSP_POWER_CB_RESUMING		0x00020000
+/*indicates the unit is suspending, seems to occur due to inactivity*/
+#define PSP_POWER_CB_SUSPENDING		0x00010000
+/*indicates the unit is plugged into an AC outlet*/
+#define PSP_POWER_CB_AC_POWER		0x00001000
+/*indicates the battery charge level is low*/
+#define PSP_POWER_CB_BATTERY_LOW	0x00000100
+/*indicates there is a battery present in the unit*/
+#define PSP_POWER_CB_BATTERY_EXIST	0x00000080
+/*unknown*/
+#define PSP_POWER_CB_BATTPOWER		0x0000007F
+
+/**
+ * Power tick flags
+ */
+/* All */
+#define PSP_POWER_TICK_ALL		0
+/* Suspend */
+#define PSP_POWER_TICK_SUSPEND	1
+/* Display */
+#define PSP_POWER_TICK_DISPLAY	6
+
+/**
+ * Power Callback Function Definition
+ *
+ * @param unknown - unknown function, appears to cycle between 1,2 and 3
+ * @param powerInfo - combination of PSP_POWER_CB_ flags
+ */
+typedef void (*powerCallback_t)(int unknown, int powerInfo);
+
+/**
+ * Register Power Callback Function
+ *
+ * @param slot - slot of the callback in the list, 0 to 15, pass -1 to get an auto assignment.
+ * @param cbid - callback id from calling sceKernelCreateCallback
+ *
+ * @return 0 on success, the slot number if -1 is passed, < 0 on error.
+ */
+int scePowerRegisterCallback(int slot, SceUID cbid);
+
+/**
+ * Unregister Power Callback Function
+ *
+ * @param slot - slot of the callback
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int scePowerUnregisterCallback(int slot);
+
+/**
+ * Check if unit is plugged in
+ *
+ * @return 1 if plugged in, 0 if not plugged in, < 0 on error.
+ */
+int scePowerIsPowerOnline(void);
+
+/**
+ * Check if a battery is present
+ *
+ * @return 1 if battery present, 0 if battery not present, < 0 on error.
+ */
+int scePowerIsBatteryExist(void);
+
+/**
+ * Check if the battery is charging
+ *
+ * @return 1 if battery charging, 0 if battery not charging, < 0 on error.
+ */
+int scePowerIsBatteryCharging(void);
+
+/**
+ * Get the status of the battery charging
+ */
+int scePowerGetBatteryChargingStatus(void);
+
+/**
+ * Check if the battery is low
+ *
+ * @return 1 if the battery is low, 0 if the battery is not low, < 0 on error.
+ */
+int scePowerIsLowBattery(void);
+
+/**
+ * Get battery life as integer percent
+ *
+ * @return Battery charge percentage (0-100), < 0 on error.
+ */
+int scePowerGetBatteryLifePercent(void);
+
+/**
+ * Get battery life as time
+ *
+ * @return Battery life in minutes, < 0 on error.
+ */
+int scePowerGetBatteryLifeTime(void);
+
+/**
+ * Get temperature of the battery
+ */
+int scePowerGetBatteryTemp(void);
+
+/**
+ * unknown? - crashes PSP in usermode
+ */
+int scePowerGetBatteryElec(void);
+
+/**
+ * Get battery volt level
+ */
+int scePowerGetBatteryVolt(void);
+
+/**
+ * Set CPU Frequency
+ * @param cpufreq - new CPU frequency, valid values are 1 - 333
+ */
+int scePowerSetCpuClockFrequency(int cpufreq);
+
+/**
+ * Set Bus Frequency
+ * @param busfreq - new BUS frequency, valid values are 1 - 167
+ */
+int scePowerSetBusClockFrequency(int busfreq);
+
+/**
+ * Alias for scePowerGetCpuClockFrequencyInt
+ * @return frequency as int
+ */
+int scePowerGetCpuClockFrequency(void);
+
+/**
+ * Get CPU Frequency as Integer
+ * @return frequency as int
+ */
+int scePowerGetCpuClockFrequencyInt(void);
+
+/**
+ * Get CPU Frequency as Float
+ * @return frequency as float
+ */
+float scePowerGetCpuClockFrequencyFloat(void);
+
+/**
+ * Alias for scePowerGetBusClockFrequencyInt
+ * @return frequency as int
+ */
+int scePowerGetBusClockFrequency(void);
+
+/**
+ * Get Bus fequency as Integer
+ * @return frequency as int
+ */
+int scePowerGetBusClockFrequencyInt(void);
+
+/**
+ * Get Bus frequency as Float
+ * @return frequency as float
+ */
+float scePowerGetBusClockFrequencyFloat(void);
+
+/**
+ * Set Clock Frequencies
+ *
+ * @param pllfreq - pll frequency, valid from 19-333
+ * @param cpufreq - cpu frequency, valid from 1-333
+ * @param busfreq - bus frequency, valid from 1-167
+ * 
+ * and:
+ * 
+ * cpufreq <= pllfreq
+ * busfreq*2 <= pllfreq
+ *
+ */
+int scePowerSetClockFrequency(int pllfreq, int cpufreq, int busfreq);
+
+/**
+ * Lock power switch
+ *
+ * Note: if the power switch is toggled while locked
+ * it will fire immediately after being unlocked.
+ *
+ * @param unknown - pass 0
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int scePowerLock(int unknown);
+
+/**
+ * Unlock power switch
+ *
+ * @param unknown - pass 0
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int scePowerUnlock(int unknown);
+
+/**
+ * Generate a power tick, preventing unit from 
+ * powering off and turning off display.
+ *
+ * @param type - Either PSP_POWER_TICK_ALL, PSP_POWER_TICK_SUSPEND or PSP_POWER_TICK_DISPLAY
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int scePowerTick(int type);
+
+/**
+ * Get Idle timer
+ *
+ */
+int scePowerGetIdleTimer(void);
+
+/**
+ * Enable Idle timer
+ *
+ * @param unknown - pass 0
+ */
+int scePowerIdleTimerEnable(int unknown);
+
+/**
+ * Disable Idle timer
+ *
+ * @param unknown - pass 0
+ */
+int scePowerIdleTimerDisable(int unknown);
+
+/**
+ * Request the PSP to go into standby
+ *
+ * @return 0 always
+ */
+int scePowerRequestStandby(void);
+
+/**
+ * Request the PSP to go into suspend
+ *
+ * @return 0 always
+ */
+int scePowerRequestSuspend(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspprof.h b/newlib/psp/include/pspprof.h
new file mode 100644
index 0000000..d47722a
--- /dev/null
+++ b/newlib/psp/include/pspprof.h
@@ -0,0 +1,24 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspprof.h - Prototypes for the profiler library
+ *
+ * Copyright (c) 2006 Urchin
+ *
+ */
+#ifndef __PSPPROF_H__
+#define __PSPPROF_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void gprof_cleanup();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __PSPPROF_H__ */
diff --git a/newlib/psp/include/pspreg.h b/newlib/psp/include/pspreg.h
new file mode 100644
index 0000000..5624bf8
--- /dev/null
+++ b/newlib/psp/include/pspreg.h
@@ -0,0 +1,236 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspreg.h - Prototypes for the sceReg library.
+ *
+ * Copyright (c) 2005 James F
+ *
+ */
+
+#ifndef __REG_H__
+#define __REG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Reg Registry Kernel Library */
+/**@{*/
+
+/** System registry path */
+#define SYSTEM_REGISTRY "/system"
+
+/** Size of a keyname, used in ::sceRegGetKeys */
+#define REG_KEYNAME_SIZE 27
+
+/** Key types */
+enum RegKeyTypes
+{
+	/** Key is a directory */
+	REG_TYPE_DIR = 1,
+	/** Key is an integer (4 bytes) */
+	REG_TYPE_INT = 2,
+	/** Key is a string */
+	REG_TYPE_STR = 3,
+	/** Key is a binary string */
+	REG_TYPE_BIN = 4,
+};
+
+/** Typedef for a registry handle */
+typedef unsigned int REGHANDLE;
+
+/** Struct used to open a registry */
+struct RegParam
+{
+	unsigned int regtype;     /* 0x0, set to 1 only for system */
+	/** Seemingly never used, set to ::SYSTEM_REGISTRY */
+	char name[256];        /* 0x4-0x104 */
+	/** Length of the name */
+	unsigned int namelen;     /* 0x104 */
+	/** Unknown, set to 1 */
+	unsigned int unk2;     /* 0x108 */
+	/** Unknown, set to 1 */
+	unsigned int unk3;     /* 0x10C */
+};
+
+/**
+ * Open the registry
+ *
+ * @param reg - A filled in ::RegParam structure
+ * @param mode - Open mode (set to 1)
+ * @param h - Pointer to a REGHANDLE to receive the registry handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegOpenRegistry(struct RegParam *reg, int mode, REGHANDLE *h);
+
+/**
+ * Flush the registry to disk
+ *
+ * @param h - The open registry handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegFlushRegistry(REGHANDLE h);
+
+/**
+ * Close the registry 
+ *
+ * @param h - The open registry handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegCloseRegistry(REGHANDLE h);
+
+/**
+ * Open a registry directory
+ *
+ * @param h - The open registry handle
+ * @param name - The path to the dir to open (e.g. /CONFIG/SYSTEM)
+ * @param mode - Open mode (can be 1 or 2, probably read or read/write
+ * @param hd - Pointer to a REGHANDLE to receive the registry dir handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegOpenCategory(REGHANDLE h, const char *name, int mode, REGHANDLE *hd);
+
+/**
+ * Remove a registry dir
+ *
+ * @param h - The open registry dir handle
+ * @param name - The name of the key
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegRemoveCategory(REGHANDLE h, const char *name);
+
+/**
+ * Close the registry directory
+ *
+ * @param hd - The open registry dir handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegCloseCategory(REGHANDLE hd);
+
+/**
+ * Flush the registry directory to disk
+ *
+ * @param hd - The open registry dir handle
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegFlushCategory(REGHANDLE hd);
+
+/**
+ * Get a key's information
+ *
+ * @param hd - The open registry dir handle
+ * @param name - Name of the key
+ * @param hk - Pointer to a REGHANDLE to get registry key handle
+ * @param type - Type of the key, on of ::RegKeyTypes
+ * @param size - The size of the key's value in bytes
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeyInfo(REGHANDLE hd, const char *name, REGHANDLE *hk, unsigned int *type, SceSize *size);
+
+/**
+ * Get a key's information by name
+ *
+ * @param hd - The open registry dir handle
+ * @param name - Name of the key
+ * @param type - Type of the key, on of ::RegKeyTypes
+ * @param size - The size of the key's value in bytes
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeyInfoByName(REGHANDLE hd, const char *name, unsigned int *type, SceSize *size);
+
+/**
+ * Get a key's value
+ *
+ * @param hd - The open registry dir handle
+ * @param hk - The open registry key handler (from ::sceRegGetKeyInfo)
+ * @param buf - Buffer to hold the value
+ * @param size - The size of the buffer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeyValue(REGHANDLE hd, REGHANDLE hk, void *buf, SceSize size);
+
+/**
+ * Get a key's value by name
+ *
+ * @param hd - The open registry dir handle
+ * @param name - The key name
+ * @param buf - Buffer to hold the value
+ * @param size - The size of the buffer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeyValueByName(REGHANDLE hd, const char *name, void *buf, SceSize size);
+
+/**
+ * Set a key's value
+ *
+ * @param hd - The open registry dir handle
+ * @param name - The key name
+ * @param buf - Buffer to hold the value
+ * @param size - The size of the buffer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegSetKeyValue(REGHANDLE hd, const char *name, const void *buf, SceSize size);
+
+/**
+ * Get number of subkeys in the current dir
+ *
+ * @param hd - The open registry dir handle
+ * @param num - Pointer to an integer to receive the number
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeysNum(REGHANDLE hd, int *num);
+
+/** 
+ * Get the key names in the current directory
+ *
+ * @param hd - The open registry dir handle
+ * @param buf - Buffer to hold the NUL terminated strings, should be num*REG_KEYNAME_SIZE
+ * @param num - Number of elements in buf
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegGetKeys(REGHANDLE hd, char *buf, int num);
+
+/**
+ * Create a key
+ * 
+ * @param hd - The open registry dir handle
+ * @param name - Name of the key to create
+ * @param type - Type of key (note cannot be a directory type)
+ * @param size - Size of the allocated value space
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegCreateKey(REGHANDLE hd, const char *name, int type, SceSize size);
+
+/**
+ * Remove a registry (HONESTLY, DO NOT USE)
+ *
+ * @param reg - Filled out registry parameter
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceRegRemoveRegistry(struct RegParam *reg);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psprtc.h b/newlib/psp/include/psprtc.h
new file mode 100644
index 0000000..be3aef0
--- /dev/null
+++ b/newlib/psp/include/psprtc.h
@@ -0,0 +1,281 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psprtc.h - Prototypes for the sceRtc library
+ *
+ * Function returns marked with (?) have not been tested.
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPRTC_H__
+#define __PSPRTC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+	u16 year;
+	u16 month;
+	u16 day;
+	u16 hour;
+	u16 minutes;
+	u16 seconds;
+	u32 microseconds;
+} pspTime;
+
+enum pspRtcCheckValidErrors {
+	PSP_TIME_INVALID_YEAR = -1,
+	PSP_TIME_INVALID_MONTH = -2,
+	PSP_TIME_INVALID_DAY = -3,
+	PSP_TIME_INVALID_HOUR = -4,
+	PSP_TIME_INVALID_MINUTES = -5,
+	PSP_TIME_INVALID_SECONDS = -6,
+	PSP_TIME_INVALID_MICROSECONDS = -7
+};
+
+/**
+ * Get the resolution of the tick counter
+ *
+ * @return # of ticks per second
+ */
+u32 sceRtcGetTickResolution();
+
+/**
+ * Get current tick count
+ *
+ * @param tick - pointer to u64 to receive tick count
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcGetCurrentTick(u64 *tick);
+
+/**
+ * Get current tick count, adjusted for local time zone
+ *
+ * @param time - pointer to pspTime struct to receive time
+ * @param tz - time zone to adjust to (minutes from UTC)
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcGetCurrentClock(pspTime *time, int tz);
+
+/**
+ * Get current local time into a pspTime struct
+ *
+ * @param time - pointer to pspTime struct to receive time
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcGetCurrentClockLocalTime(pspTime *time);
+
+/**
+ * Convert a UTC-based tickcount into a local time tick count
+ *
+ * @param tickUTC - pointer to u64 tick in UTC time
+ * @param tickLocal - pointer to u64 to receive tick in local time
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcConvertUtcToLocalTime(const u64* tickUTC, u64* tickLocal);
+
+/**
+ * Convert a local time based tickcount into a UTC-based tick count
+ *
+ * @param tickLocal - pointer to u64 tick in local time
+ * @param tickUTC - pointer to u64 to receive tick in UTC based time
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcConvertLocalTimeToUTC(const u64* tickLocal, u64* tickUTC);
+
+/**
+ * Check if a year is a leap year
+ *
+ * @param year - year to check if is a leap year
+ * @return 1 on leapyear, 0 if not
+ */
+int sceRtcIsLeapYear(int year);
+
+/**
+ * Get number of days in a specific month
+ *
+ * @param year - year in which to check (accounts for leap year)
+ * @param month - month to get number of days for
+ * @return # of days in month, <0 on error (?)
+ */
+int sceRtcGetDaysInMonth(int year, int month);
+
+/**
+ * Get day of the week for a date
+ *
+ * @param year - year in which to check (accounts for leap year)
+ * @param month - month that day is in
+ * @param day - day to get day of week for
+ * @return day of week with 0 representing Monday
+ */
+int sceRtcGetDayOfWeek(int year, int month, int day);
+
+/**
+ * Validate pspDate component ranges
+ *
+ * @param date - pointer to pspDate struct to be checked
+ * @return 0 on success, one of ::pspRtcCheckValidErrors on error
+ */
+int sceRtcCheckValid(const pspTime* date);
+
+/**
+ * Set a pspTime struct based on ticks
+ *
+ * @param date - pointer to pspTime struct to set
+ * @param tick - pointer to ticks to convert
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcSetTick(pspTime* date, const u64* tick);
+
+/**
+ * Set ticks based on a pspTime struct
+ *
+ * @param date - pointer to pspTime to convert
+ * @param tick - pointer to tick to set
+ * @return 0 on success, < 0 on error
+ */
+int sceRtcGetTick(const pspTime* date, u64 *tick);
+
+/**
+ * Compare two ticks
+ *
+ * @param tick1 - pointer to first tick
+ * @param tick2 - poiinter to second tick
+ * @return 0 on equal, <0 when tick1 < tick2, >0 when tick1 > tick2
+ */
+int sceRtcCompareTick(const u64* tick1, const u64* tick2);
+
+/**
+ * Add two ticks
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numTicks - number of ticks to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddTicks(u64* destTick, const u64* srcTick, u64 numTicks);
+
+/**
+ * Add an amount of ms to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numMS - number of ms to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddMicroseconds(u64* destTick, const u64* srcTick, u64 numMS);
+
+/**
+ * Add an amount of seconds to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numSecs - number of seconds to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddSeconds(u64* destTick, const u64* srcTick, u64 numSecs);
+
+/**
+ * Add an amount of minutes to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numMins - number of minutes to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddMinutes(u64* destTick, const u64* srcTick, u64 numMins);
+
+/**
+ * Add an amount of hours to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numHours - number of hours to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddHours(u64* destTick, const u64* srcTick, int numHours);
+
+/**
+ * Add an amount of days to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numDays - number of days to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddDays(u64* destTick, const u64* srcTick, int numDays);
+
+/**
+ * Add an amount of weeks to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numWeeks - number of weeks to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddWeeks(u64* destTick, const u64* srcTick, int numWeeks);
+
+
+/**
+ * Add an amount of months to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numMonths - number of months to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddMonths(u64* destTick, const u64* srcTick, int numMonths);
+
+/**
+ * Add an amount of years to a tick
+ *
+ * @param destTick - pointer to tick to hold result
+ * @param srcTick - pointer to source tick
+ * @param numYears - number of years to add
+ * @return 0 on success, <0 on error
+ */
+int sceRtcTickAddYears(u64* destTick, const u64* srcTick, int numYears);
+
+int sceRtcSetTime_t(pspTime* date, const time_t time);
+int sceRtcGetTime_t(const pspTime* date, time_t *time);
+int sceRtcSetDosTime(pspTime* date, u32 dosTime);
+int sceRtcGetDosTime(pspTime* date, u32 dosTime);
+int sceRtcSetWin32FileTime(pspTime* date, u64* win32Time);
+int sceRtcGetWin32FileTime(pspTime* date, u64* win32Time);
+
+int sceRtcParseDateTime(u64 *destTick, const char *dateString);
+
+/**
+ * Format Tick-representation UTC time in RFC2822 format
+ */
+int sceRtcFormatRFC2822(char *pszDateTime, const u64 *pUtc, int iTimeZoneMinutes);
+
+/**
+ * Format Tick-representation UTC time in RFC2822 format
+ */
+int sceRtcFormatRFC2822LocalTime(char *pszDateTime, const u64 *pUtc);
+
+/**
+ * Format Tick-representation UTC time in RFC3339(ISO8601) format
+ */
+int sceRtcFormatRFC3339(char *pszDateTime, const u64 *pUtc, int iTimeZoneMinutes);
+
+/**
+ * Format Tick-representation UTC time in RFC3339(ISO8601) format
+ */
+int sceRtcFormatRFC3339LocalTime(char *pszDateTime, const u64 *pUtc);
+
+/**
+ * Parse time information represented in RFC3339 format
+ */
+int sceRtcParseRFC3339(u64 *pUtc, const char *pszDateTime);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspsdk.h b/newlib/psp/include/pspsdk.h
new file mode 100644
index 0000000..e267ba2
--- /dev/null
+++ b/newlib/psp/include/pspsdk.h
@@ -0,0 +1,295 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsdk.h - Interface to the PSPSDK utility library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPSDK_H
+#define PSPSDK_H
+
+#include <pspkerneltypes.h>
+#include <pspmodulemgr.h>
+#include <pspmoduleinfo.h>
+#include <pspthreadman.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PSPSDK PSPSDK Utility Library */
+
+/** @addtogroup PSPSDK */
+/**@{*/
+
+/**
+  * Query a modules information from its uid.
+  * @note this is a replacement function for the broken kernel sceKernelQueryModuleInfo in v1.0 firmware
+  * DO NOT use on a anything above that version. This also needs kernel mode access where
+  * the normal one has a user mode stub.
+  * 
+  * @param uid - The UID of the module to query.
+  * @param modinfo - Pointer a module SceKernelModuleInfo structure.
+  *
+  * @return < 0 on error.
+  */
+int pspSdkQueryModuleInfoV1(SceUID uid, SceKernelModuleInfo *modinfo);
+
+/**
+  * Get the list of module IDs.
+  * @note This is a replacement function for the missing v1.5 sceKernelGetModuleIdList
+  * on v1.0 firmware. DO NOT use on anything above that version.
+  *
+  * @param readbuf - Buffer to store the module list.
+  * @param readbufsize - Number of elements in the readbuffer.
+  * @param idcount - Returns the number of module ids
+  *
+  * @return >= 0 on success
+  */
+int pspSdkGetModuleIdList(SceUID *readbuf, int readbufsize, int *idcount);
+
+/**
+ * Patch the sceModuleManager module to nullify LoadDeviceCheck() calls.
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes.
+ *
+ * @note This function must be called while running in kernel mode.  The program
+ * must also be linked against the pspkernel library.
+ */
+int pspSdkInstallNoDeviceCheckPatch(void);
+
+/**
+ * Patch sceLoadCore module to remove loading plain module checks
+ *
+ * @note This function must be called while running in kernel mode.
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkInstallNoPlainModuleCheckPatch(void);
+
+/**
+ * Patch sceLoadModuleWithApiType to remove the kernel check in loadmodule allowing all modules to load
+ *
+ * @note This function must be called while running in kernel mode
+ *
+ * @return 0 on success
+ */
+int pspSdkInstallKernelLoadModulePatch(void);
+
+/**
+ * Load a module and start it.
+ *
+ * @param filename - Path to the module.
+ * @param mpid - Memory parition ID to use to load the module int.
+ *
+ * @return - The UID of the module on success, otherwise one of ::PspKernelErrorCodes.
+ */
+SceUID pspSdkLoadStartModule(const char *filename, int mpid);
+
+/**
+ * Load a module and start it with arguments
+ *
+ * @param filename - Path to the module.
+ * @param mpid - Memory parition ID to use to load the module int.
+ * @param argc - Number of arguments to pass to start module
+ * @param argv - Array of arguments
+ *
+ * @return - The UID of the module on success, otherwise one of ::PspKernelErrorCodes.
+ */
+SceUID pspSdkLoadStartModuleWithArgs(const char *filename, int mpid, int argc, char * const argv[]);
+
+/**
+ * Manually fixup library imports for late binding modules.
+ *
+ * @param moduleId - Id of the module to fixup
+ */
+void pspSdkFixupImports(int moduleId);
+
+/**
+ * Load Inet related modules.
+ * @note You must be in kernel mode to execute this function.
+ *
+ * @return - 0 on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkLoadInetModules();
+
+/**
+ * Initialize Inet related modules.
+ *
+ * @return - 0 on success, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkInetInit();
+
+/**
+ * Terminate Inet related modules.
+ */
+void pspSdkInetTerm();
+
+/**
+ * Search for a thread with the given name and retrieve it's ::SceKernelThreadInfo struct.
+ *
+ * @param name - The name of the thread to search for.
+ * @param pUID - If the thread with the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the thread with the given name is found, it's ::SceKernelThreadInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferThreadStatusByName(const char *name, SceUID *pUID, SceKernelThreadInfo *pInfo);
+
+/**
+ * Search for a semaphore with the given name and retrieve it's ::SceKernelSemaInfo struct.
+ *
+ * @param name - The name of the sema to search for.
+ * @param pUID - If the sema with the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the sema with the given name is found, it's ::SceKernelSemaInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferSemaStatusByName(const char *name, SceUID *pUID, SceKernelSemaInfo *pInfo);
+
+/**
+ * Search for an event flag with the given name and retrieve it's ::SceKernelEventFlagInfo struct.
+ *
+ * @param name - The name of the event flag to search for.
+ * @param pUID - If the event flag with the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the event flag with the given name is found, it's ::SceKernelEventFlagInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferEventFlagStatusByName(const char *name, SceUID *pUID, SceKernelEventFlagInfo *pInfo);
+
+/**
+ * Search for a message box with the given name and retrieve it's ::SceKernelMbxInfo struct.
+ *
+ * @param name - The name of the message box to search for.
+ * @param pUID - If the message box with the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the message box with the given name is found, it's ::SceKernelMbxInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferMboxStatusByName(const char *name, SceUID *pUID, SceKernelMbxInfo *pInfo);
+
+/**
+ * Search for a VPL with the given name and retrieve it's ::SceKernelVplInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelVplInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferVplStatusByName(const char *name, SceUID *pUID, SceKernelVplInfo *pInfo);
+
+/**
+ * Search for a FPL with the given name and retrieve it's ::SceKernelFplInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelFplInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferFplStatusByName(const char *name, SceUID *pUID, SceKernelFplInfo *pInfo);
+
+/**
+ * Search for a message pipe with the given name and retrieve it's ::SceKernelMppInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelMppInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferMppStatusByName(const char *name, SceUID *pUID, SceKernelMppInfo *pInfo);
+
+/**
+ * Search for a callback with the given name and retrieve it's ::SceKernelCallbackInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelMppInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferCallbackStatusByName(const char *name, SceUID *pUID, SceKernelCallbackInfo *pInfo);
+
+/**
+ * Search for a vtimer with the given name and retrieve it's ::SceKernelVTimerInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelVTimerInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferVTimerStatusByName(const char *name, SceUID *pUID, SceKernelVTimerInfo *pInfo);
+
+/**
+ * Search for a thread event handler with the given name and retrieve it's ::SceKernelThreadEventHandlerInfo struct.
+ *
+ * @param name - The name of to search for.
+ * @param pUID - If the given name is found, it's ::SceUID is stored here.
+ * @param pInfo - If the given name is found, it's ::SceKernelThreadEventHandlerInfo data is stored here.
+ *
+ * @return 0 if successful, otherwise one of ::PspKernelErrorCodes.
+ */
+int pspSdkReferThreadEventHandlerStatusByName(const char *name, SceUID *pUID, SceKernelThreadEventHandlerInfo *pInfo);
+
+/**
+ * Disable interrupts
+ *
+ * @note Do not disable interrupts for too long otherwise the watchdog will get you.
+ *
+ * @return The previous state of the interrupt enable bit (should be passed back to ::pspSdkEnableInterrupts)
+ */
+unsigned int pspSdkDisableInterrupts(void);
+
+/**
+ * Enable interrupts
+ *
+ * @param istate - The interrupt state as returned from ::pspSdkDisableInterrupts
+ */
+void pspSdkEnableInterrupts(unsigned int istate);
+
+/**
+ * Set the processors K1 register to a known value
+ *
+ * @note This function is for use in kernel mode syscall exports. The kernel
+ * sets the k1 register to indicate what mode called the function, i.e. 
+ * whether it was directly called, was called via a syscall from a kernel
+ * thread or called via a syscall from a user thread. By setting k1 to 0
+ * before doing anything in your code you can make the other functions think
+ * you are calling from a kernel thread and therefore disable numerous 
+ * protections.
+ *
+ * @param k1 - The k1 value to set
+ * 
+ * @return The previous value of k1
+ */
+unsigned int pspSdkSetK1(unsigned int k1);
+
+/**
+ * Get the current value of the processors K1 register
+ *
+ * @return The current value of K1
+ */
+unsigned int pspSdkGetK1(void);
+
+/**
+ * Disable the CPUs FPU exceptions
+ */
+void pspSdkDisableFPUExceptions(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPSDK_H */
diff --git a/newlib/psp/include/pspsircs.h b/newlib/psp/include/pspsircs.h
new file mode 100644
index 0000000..5aae391
--- /dev/null
+++ b/newlib/psp/include/pspsircs.h
@@ -0,0 +1,45 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspmodulemgr.h - Prototypes to manage manage modules.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2005 Matthew H <matthewh@webone.com.au>
+ *
+ * $$
+ */
+#ifndef __SIRCS_H__
+#define __SIRCS_H__
+
+/** @defgroup Sony Integrated Remote Control System Library
+  * This module contains the imports for the kernel's remote control routines.
+  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Sony Integrated Remote Control System Library */
+/**@{*/
+
+struct sircs_data {
+	u8 type; // 12, 15 or 20 bits
+	u8 cmd;  // 7 bit cmd
+	u16 dev; // 5, 8 or 13 bit device address
+} __packed__;
+
+/**
+  */
+int sceSircsSend(struct sircs_data* sd, int count); 
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspssl.h b/newlib/psp/include/pspssl.h
new file mode 100644
index 0000000..b4bced2
--- /dev/null
+++ b/newlib/psp/include/pspssl.h
@@ -0,0 +1,58 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspssl.h - Interface to the ssl library.
+ *
+ * Copyright (c) 2008 David Perry (InsertWittyName)
+ * Copyright (c) 2008 moonlight
+ *
+ */
+
+#ifndef __PSPSSL_H__
+#define __PSPSSL_H__
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * Init the ssl library.
+ *
+ * @param unknown1 - Memory size? Pass 0x28000
+ *
+ * @return 0 on success
+*/
+int sceSslInit(int unknown1);
+
+/**
+ * Terminate the ssl library.
+ *
+ * @return 0 on success
+*/
+int sceSslEnd(void);
+
+/**
+ * Get the maximum memory size used by ssl.
+ *
+ * @param memory - Pointer where the maximum memory used value will be stored.
+ *
+ * @return 0 on success
+*/
+int sceSslGetUsedMemoryMax(unsigned int *memory);
+
+/**
+ * Get the current memory size used by ssl.
+ *
+ * @param memory - Pointer where the current memory used value will be stored.
+ *
+ * @return 0 on success
+*/
+int sceSslGetUsedMemoryCurrent(unsigned int *memory);
+
+#if defined(__cplusplus)
+};
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspstdio.h b/newlib/psp/include/pspstdio.h
new file mode 100644
index 0000000..891ae75
--- /dev/null
+++ b/newlib/psp/include/pspstdio.h
@@ -0,0 +1,56 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspstdio.h - Prototypes for the sceStdio library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPSTDIO_H__
+#define __PSPSTDIO_H__
+
+#include <pspkerneltypes.h>
+
+/** @defgroup Stdio Stdio Library 
+ *  This module contains the imports for the kernel's stdio routines.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Stdio Stdio Library */
+/**@{*/
+
+/**
+  * Function to get the current standard in file no
+  * 
+  * @return The stdin fileno
+  */
+SceUID sceKernelStdin(void);
+
+/**
+  * Function to get the current standard out file no
+  * 
+  * @return The stdout fileno
+  */
+SceUID sceKernelStdout(void);
+
+/**
+  * Function to get the current standard err file no
+  * 
+  * @return The stderr fileno
+  */
+SceUID sceKernelStderr(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspstdio_kernel.h b/newlib/psp/include/pspstdio_kernel.h
new file mode 100644
index 0000000..acc37f6
--- /dev/null
+++ b/newlib/psp/include/pspstdio_kernel.h
@@ -0,0 +1,71 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspstdio_kernel.h - Interface to the kernel mode library for Stdio.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPSTDIO_KERNEL_H
+#define PSPSTDIO_KERNEL_H
+
+#include <psptypes.h>
+#include <pspkerneltypes.h>
+#include <pspiofilemgr.h>
+
+/** @defgroup Stdio_Kernel Driver interface to Stdio
+ *  This module contains the imports for the kernel's stdio routines.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Stdio_Kernel Driver interface to Stdio */
+/**@{*/
+
+/** 
+  * Function reopen the stdout file handle to a new file
+  *
+  * @param file - The file to open.
+  * @param flags - The open flags 
+  * @param mode - The file mode
+  * 
+  * @return < 0 on error.
+  */
+int sceKernelStdoutReopen(const char *file, int flags, SceMode mode);
+
+/** 
+  * Function reopen the stderr file handle to a new file
+  *
+  * @param file - The file to open.
+  * @param flags - The open flags 
+  * @param mode - The file mode
+  * 
+  * @return < 0 on error.
+  */
+int sceKernelStderrReopen(const char *file, int flags, SceMode mode);
+
+
+/** 
+  * fprintf but for file descriptors
+  *
+  * @param fd - file descriptor from sceIoOpen
+  * @param format - format string
+  * @param ... - variables
+  * 
+  * @return number of characters printed, <0 on error
+  */
+int fdprintf(int fd, const char *format, ...);
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPSTDIO_KERNEL_H */
diff --git a/newlib/psp/include/pspstub.s b/newlib/psp/include/pspstub.s
new file mode 100644
index 0000000..ca04503
--- /dev/null
+++ b/newlib/psp/include/pspstub.s
@@ -0,0 +1,83 @@
+# common.s - GAS macros for creating import libraries.
+#
+# Use STUB_START to declare the start of an import library.  The module parameter
+# is the name of the library to import, flags_ver is both the import flags and library
+# version, and stub_len is both the number of stubs to import and the size of the
+# stub itself (in 32-bit words).
+# Use the STUB_FUNC macro for each stub you want to import.  The funcid parameter is
+# the 32-bit SHA1-derived NID value, and the funcname is the name you want to call
+# the imported function.
+# Use STUB_END to declare the end of your import library.
+
+.macro STUB_START module, flags_ver, stub_len
+
+	.set push
+	.section .rodata.sceResident, "a"
+	.word   0
+__stub_modulestr_\module:
+	.asciz  "\module"
+	.align  2
+
+	.section .lib.stub, "a", @progbits
+	.word   __stub_modulestr_\module
+	.word   \flags_ver
+	.word   \stub_len
+	.word   __stub_idtable_\module
+	.word   __stub_text_\module
+
+	.section .rodata.sceNid, "a"
+__stub_idtable_\module:
+
+	.section .sceStub.text, "ax", @progbits
+__stub_text_\module:
+
+	.set pop
+.endm
+
+.macro STUB_FUNC funcid, funcname
+
+	.set push
+	.set noreorder
+
+	.section .sceStub.text, "ax", @progbits
+	.globl  \funcname
+	.type   \funcname, @function
+	.ent    \funcname, 0
+\funcname:
+	jr	$ra
+	nop
+	.end    \funcname
+	.size   \funcname, .-\funcname
+
+	.section .rodata.sceNid
+	.word   \funcid
+
+	.set pop
+.endm
+
+.macro STUB_FUNC_WITH_ALIAS funcid, funcname, alias
+
+	.set push
+	.set noreorder
+
+	.section .sceStub.text, "ax", @progbits
+	.globl  \alias
+	.type   \alias, @function
+\alias:
+	.globl  \funcname
+	.type   \funcname, @function
+	.ent    \funcname, 0
+\funcname:
+	jr	$ra
+	nop
+	.end    \funcname
+	.size   \funcname, .-\funcname
+
+	.section .rodata.sceNid
+	.word   \funcid
+
+	.set pop
+.endm
+
+.macro STUB_END
+.endm
diff --git a/newlib/psp/include/pspsuspend.h b/newlib/psp/include/pspsuspend.h
new file mode 100644
index 0000000..31e9913
--- /dev/null
+++ b/newlib/psp/include/pspsuspend.h
@@ -0,0 +1,56 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsuspend.h - User interface to the PSP suspend.
+ *
+ * Copyright (c) 2006 James F
+ *
+ */
+
+#ifndef __PSPSUSPEND_H__
+#define __PSPSUSPEND_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Allocate the extra 4megs of RAM
+ *
+ * @param unk - No idea as it is never used, set to anything
+ * @param ptr - Pointer to a pointer to hold the address of the memory
+ * @param size - Pointer to an int which will hold the size of the memory
+ *
+ * @return 0 on success
+ */
+int sceKernelVolatileMemLock(int unk, void **ptr, int *size);
+
+/**
+ * Try and allocate the extra 4megs of RAM, will return an error if 
+ * something has already allocated it
+ *
+ * @param unk - No idea as it is never used, set to anything
+ * @param ptr - Pointer to a pointer to hold the address of the memory
+ * @param size - Pointer to an int which will hold the size of the memory
+ *
+ * @return 0 on success
+ */
+int sceKernelVolatileMemTryLock(int unk, void **ptr, int *size);
+
+/**
+ * Deallocate the extra 4 megs of RAM
+ *
+ * @param unk - Set to 0, otherwise it fails in 3.52+, possibly earlier
+ * @return 0 on success
+ */
+int sceKernelVolatileMemUnlock(int unk);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspsysclib.h b/newlib/psp/include/pspsysclib.h
new file mode 100644
index 0000000..57d9917
--- /dev/null
+++ b/newlib/psp/include/pspsysclib.h
@@ -0,0 +1,42 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsysclib.h - Interface to sysclib library.
+ *
+ * Copyright (c) 2007 James F
+ *
+ */
+
+#ifndef PSPSYSCLIB_H
+#define PSPSYSCLIB_H
+
+#include <pspkerneltypes.h>
+#include <stdarg.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Callback type, ch is 0x200 on start of string, 0x201 on end */
+typedef void (*prnt_callback)(void *ctx, int ch);
+
+/** 
+ * Generic print routine
+ *
+ * @param cb - Callback, called for every character printed
+ * @param ctx - Context parameter passed to the callback
+ * @param fmt - Format data
+ * @param args - Arguments for format
+ *
+ */
+void prnt(prnt_callback cb, void *ctx, const char *fmt, va_list args);
+
+/*@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspsyscon.h b/newlib/psp/include/pspsyscon.h
new file mode 100644
index 0000000..526e5a4
--- /dev/null
+++ b/newlib/psp/include/pspsyscon.h
@@ -0,0 +1,85 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsyscon.h - Interface to sceSyscon_driver.
+ *
+ * Copyright (c) 2006 James F
+ *
+ */
+
+#ifndef PSPSYSCON_H
+#define PSPSYSCON_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup Syscon Interface to the sceSyscon_driver library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Syscon Interface to the sceSyscon_driver library. */
+/**@{*/
+
+/**
+  * Force the PSP to go into standby
+  */
+void sceSysconPowerStandby(void);
+
+/**
+ * Reset the PSP
+ *
+ * @param unk1 - Unknown, pass 1
+ * @param unk2 - Unknown, pass 1
+ */
+void sceSysconResetDevice(int unk1, int unk2);
+
+#define SCE_LED_POWER 1
+#define LED_ON 1
+#define LED_OFF 0
+/**
+ * Control an LED
+ *
+ * @param SceLED - The led to toggle (only SCE_LED_POWER)
+ * @param state - Whether to turn on or off
+ */
+int sceSysconCtrlLED(int SceLED, int state);
+
+/**
+ * Control the remote control power
+ *
+ * @param power - 1 is on, 0 is off
+ * 
+ * @return < 0 on error
+ */
+int sceSysconCtrlHRPower(int power);
+
+
+int	sceSysconGetHPConnect(void);
+
+int sceSysconSetHPConnectCallback( void (*)(int), int unk0 );
+
+int sceSysconSetHRPowerCallback( void (*)(int), int unk0 );
+
+/**
+ * Get the PSP's Pommel version
+ * @param version - A pointer to an int to receive the Pommel version into
+ */
+int sceSysconGetPommelVersion( int* version );
+
+/**
+ * Get the PSP's Baryon version
+ * @param version - A pointer to an int to receive the Baryon version into
+ */
+int sceSysconGetBaryonVersion( int* version );
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspsysevent.h b/newlib/psp/include/pspsysevent.h
new file mode 100644
index 0000000..62a6640
--- /dev/null
+++ b/newlib/psp/include/pspsysevent.h
@@ -0,0 +1,88 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsysevent.h - Prototypes for the sceSysEventForKernel library
+ *
+ * Copyright (c) 2007 Iaroslav Gaponenko <adrahil@gmail.com>
+ *
+ */
+#ifndef __PSPSYSEVENT_H__
+#define __PSPSYSEVENT_H__
+ 
+#ifdef __cplusplus
+extern "C" {
+#endif
+ 
+typedef struct PspSysEventHandler _PspSysEventHandler;
+ 
+typedef int (*PspSysEventHandlerFunc)(int ev_id, char* ev_name, void* param, int* result);
+ 
+typedef struct PspSysEventHandler{
+  int size;
+  char* name;
+  int type_mask;
+  int (*handler)(int ev_id, char* ev_name, void* param, int* result);
+  int r28;
+  int busy;
+  _PspSysEventHandler *next;
+  int reserved[9];
+}PspSysEventHandler;
+ 
+ 
+/**
+ * Dispatch a SysEvent event.
+ *
+ * @param ev_type_mask - the event type mask
+ * @param ev_id - the event id
+ * @param ev_name - the event name
+ * @param param - the pointer to the custom parameters
+ * @param result - the pointer to the result
+ * @param break_nonzero - set to 1 to interrupt the calling chain after the first non-zero return
+ * @param break_handler - the pointer to the event handler having interrupted
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSysEventDispatch(int ev_type_mask, int ev_id, char* ev_name, void* param, int* result, int break_nonzero, PspSysEventHandler* break_handler);
+ 
+ 
+/**
+ * Get the first SysEvent handler (the rest can be found with the linked list).
+ *
+ * @return 0 on error, handler on success
+ */
+PspSysEventHandler* sceKernelReferSysEventHandler(void);
+ 
+ 
+/**
+ * Check if a SysEvent handler is registered.
+ *
+ * @param handler - the handler to check
+ * @return 0 if the handler is not registered
+ */
+int sceKernelIsRegisterSysEventHandler(PspSysEventHandler* handler);
+ 
+ 
+/**
+ * Register a SysEvent handler.
+ *
+ * @param handler - the handler to register
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelRegisterSysEventHandler(PspSysEventHandler* handler);
+ 
+ 
+/**
+ * Unregister a SysEvent handler.
+ *
+ * @param handler - the handler to unregister
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelUnregisterSysEventHandler(PspSysEventHandler* handler);
+ 
+#ifdef __cplusplus
+}
+#endif
+ 
+#endif
+
diff --git a/newlib/psp/include/pspsysmem.h b/newlib/psp/include/pspsysmem.h
new file mode 100644
index 0000000..16447a6
--- /dev/null
+++ b/newlib/psp/include/pspsysmem.h
@@ -0,0 +1,138 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsysmem.h - Interface to the system memory manager.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef PSPSYSMEM_H
+#define PSPSYSMEM_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup SysMem System Memory Manager
+  * This module contains routines to manage heaps of memory.
+  */
+
+/** @addtogroup SysMem System Memory Manager */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Specifies the type of allocation used for memory blocks. */
+enum PspSysMemBlockTypes {
+	/** Allocate from the lowest available address. */
+	PSP_SMEM_Low = 0,
+	/** Allocate from the highest available address. */
+	PSP_SMEM_High,
+	/** Allocate from the specified address. */
+	PSP_SMEM_Addr
+};
+
+typedef int SceKernelSysMemAlloc_t;
+
+/**
+ * Allocate a memory block from a memory partition.
+ *
+ * @param partitionid - The UID of the partition to allocate from.
+ * @param name - Name assigned to the new block.
+ * @param type - Specifies how the block is allocated within the partition.  One of ::PspSysMemBlockTypes.
+ * @param size - Size of the memory block, in bytes.
+ * @param addr - If type is PSP_SMEM_Addr, then addr specifies the lowest address allocate the block from.
+ *
+ * @return The UID of the new block, or if less than 0 an error.
+ */
+SceUID sceKernelAllocPartitionMemory(SceUID partitionid, const char *name, int type, SceSize size, void *addr);
+
+/**
+ * Free a memory block allocated with ::sceKernelAllocPartitionMemory.
+ *
+ * @param blockid - UID of the block to free.
+ *
+ * @return ? on success, less than 0 on error.
+ */
+int sceKernelFreePartitionMemory(SceUID blockid);
+
+/**
+ * Get the address of a memory block.
+ *
+ * @param blockid - UID of the memory block.
+ *
+ * @return The lowest address belonging to the memory block.
+ */
+void * sceKernelGetBlockHeadAddr(SceUID blockid);
+
+/**
+ * Get the total amount of free memory.
+ *
+ * @return The total amount of free memory, in bytes.
+ */
+SceSize sceKernelTotalFreeMemSize(void);
+
+/**
+ * Get the size of the largest free memory block.
+ *
+ * @return The size of the largest free memory block, in bytes.
+ */
+SceSize sceKernelMaxFreeMemSize(void);
+
+/**
+ * Get the firmware version.
+ * 
+ * @return The firmware version.
+ * 0x01000300 on v1.00 unit,
+ * 0x01050001 on v1.50 unit,
+ * 0x01050100 on v1.51 unit,
+ * 0x01050200 on v1.52 unit,
+ * 0x02000010 on v2.00/v2.01 unit,
+ * 0x02050010 on v2.50 unit,
+ * 0x02060010 on v2.60 unit,
+ * 0x02070010 on v2.70 unit,
+ * 0x02070110 on v2.71 unit.
+ */
+int sceKernelDevkitVersion(void);
+
+#if _PSP_FW_VERSION >= 150
+
+/**
+ * Kernel printf function.
+ *
+ * @param format - The format string.
+ * @param ... - Arguments for the format string.
+ */
+void sceKernelPrintf(const char *format, ...) __attribute__((format(printf, 1, 2)));
+
+#endif
+
+/**
+ * Set the version of the SDK with which the caller was compiled.
+ * Version numbers are as for sceKernelDevkitVersion().
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelSetCompiledSdkVersion(int version);
+
+/**
+ * Get the SDK version set with sceKernelSetCompiledSdkVersion().
+ *
+ * @return Version number, or 0 if unset.
+ */
+int sceKernelGetCompiledSdkVersion(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* PSPSYSMEM_H */
diff --git a/newlib/psp/include/pspsysmem_kernel.h b/newlib/psp/include/pspsysmem_kernel.h
new file mode 100644
index 0000000..8dd60a6
--- /dev/null
+++ b/newlib/psp/include/pspsysmem_kernel.h
@@ -0,0 +1,224 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsysmem_kernel.h - Interface to the system memory manager (kernel).
+ *
+ * Copyright (c) 2005 James F.
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef PSPSYSMEMKERNEL_H
+#define PSPSYSMEMKERNEL_H
+
+#include <pspkerneltypes.h>
+#include <pspsysmem.h>
+
+/** @defgroup SysMemKern System Memory Manager Kernel
+  * This module contains routines to manage heaps of memory.
+  */
+
+/** @addtogroup SysMemKern System Memory Manager Kernel */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _PspSysmemPartitionInfo
+{
+	SceSize size;
+	unsigned int startaddr;
+	unsigned int memsize;
+	unsigned int attr;
+} PspSysmemPartitionInfo;
+
+/**
+ * Query the parition information
+ *
+ * @param pid  - The partition id
+ * @param info - Pointer to the ::PspSysmemPartitionInfo structure
+ *
+ * @return 0 on success.
+ */
+int sceKernelQueryMemoryPartitionInfo(int pid, PspSysmemPartitionInfo *info);
+
+/**
+ * Get the total amount of free memory.
+ *
+ * @param pid - The partition id
+ *
+ * @return The total amount of free memory, in bytes.
+ */
+SceSize sceKernelPartitionTotalFreeMemSize(int pid);
+
+/**
+ * Get the size of the largest free memory block.
+ *
+ * @param pid - The partition id
+ *
+ * @return The size of the largest free memory block, in bytes.
+ */
+SceSize sceKernelPartitionMaxFreeMemSize(int pid);
+
+/**
+ * Get the kernel to dump the internal memory table to Kprintf
+ */
+void sceKernelSysMemDump(void);
+
+/**
+ * Dump the list of memory blocks
+ */
+void sceKernelSysMemDumpBlock(void);
+
+/**
+ * Dump the tail blocks
+ */
+void sceKernelSysMemDumpTail(void);
+
+/**
+ * Set the protection of a block of ddr memory
+ *
+ * @param addr - Address to set protection on
+ * @param size - Size of block
+ * @param prot - Protection bitmask
+ *
+ * @return < 0 on error
+ */
+int sceKernelSetDdrMemoryProtection(void *addr, int size, int prot);
+
+/**
+ * Create a heap.
+ *
+ * @param partitionid - The UID of the partition where allocate the heap.
+ * @param size - The size in bytes of the heap.
+ * @param unk - Unknown, probably some flag or type, pass 1.
+ * @param name - Name assigned to the new heap.
+ *
+ * @return The UID of the new heap, or if less than 0 an error. 
+*/
+SceUID sceKernelCreateHeap(SceUID partitionid, SceSize size, int unk, const char *name);
+
+/**
+ * Allocate a memory block from a heap.
+ *
+ * @param heapid - The UID of the heap to allocate from.
+ * @param size - The number of bytes to allocate.
+ *
+ * @return The address of the allocated memory block, or NULL on error.
+*/
+void *sceKernelAllocHeapMemory(SceUID heapid, SceSize size);
+
+/**
+ * Free a memory block allocated from a heap.
+ *
+ * @param heapid - The UID of the heap where block belongs.
+ * @param block - The block of memory to free from the heap.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelFreeHeapMemory(SceUID heapid, void *block);
+
+/**
+ * Delete a heap.
+ *
+ * @param heapid - The UID of the heap to delete.
+ *
+ * @return 0 on success, < 0 on error.
+*/
+int sceKernelDeleteHeap(SceUID heapid);
+
+/**
+ * Get the amount of free size of a heap, in bytes.
+ *
+ * @param heapid - The UID of the heap
+ *
+ * @return the free size of the heap, in bytes. < 0 on error.
+*/
+SceSize sceKernelHeapTotalFreeSize(SceUID heapid);
+
+/** Structure of a UID control block */
+struct _uidControlBlock {
+    struct _uidControlBlock *parent;
+    struct _uidControlBlock *nextChild;
+    struct _uidControlBlock *type;   //(0x8)
+    u32 UID;					//(0xC)
+    char *name;					//(0x10)
+	unsigned char unk;
+	unsigned char size;			// Size in words
+    short attribute;
+    struct _uidControlBlock *nextEntry;
+} __attribute__((packed));
+typedef struct _uidControlBlock uidControlBlock;
+
+/**
+ * Get a UID control block
+ *
+ * @param uid - The UID to find
+ * @param block - Pointer to hold the pointer to the block
+ *
+ * @return 0 on success
+ */
+int sceKernelGetUIDcontrolBlock(SceUID uid, uidControlBlock** block);
+
+/**
+ * Get a UID control block on a particular type
+ *
+ * @param uid - The UID to find
+ * @param type - Pointer to the type UID block
+ * @param block - Pointer to hold the pointer to the block
+ *
+ * @return 0 on success
+ */
+int sceKernelGetUIDcontrolBlockWithType(SceUID uid, uidControlBlock* type, uidControlBlock** block);
+
+/**
+ * Get the root of the UID tree (1.5+ only)
+ *
+ * @return Pointer to the UID tree root
+ */
+uidControlBlock* SysMemForKernel_536AD5E1(void);
+
+/**
+ * Delete a UID
+ *
+ * @param uid - The UID to delete
+ *
+ * @return 0 on success
+ */
+int sceKernelDeleteUID(SceUID uid);
+
+/**
+ * Get the model of PSP
+ *
+ * @return <= 0 original, 1 slim
+ */
+int sceKernelGetModel(void);
+
+/**
+ * Set the version of the SDK with which the caller was compiled.
+ * Version numbers are as for sceKernelDevkitVersion().
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelSetCompiledSdkVersion(int version);
+
+/**
+ * Get the SDK version set with sceKernelSetCompiledSdkVersion().
+ *
+ * @return Version number, or 0 if unset.
+ */
+int sceKernelGetCompiledSdkVersion(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* PSPSYSMEMKERNEL_H */
diff --git a/newlib/psp/include/pspsysreg.h b/newlib/psp/include/pspsysreg.h
new file mode 100644
index 0000000..c1cad61
--- /dev/null
+++ b/newlib/psp/include/pspsysreg.h
@@ -0,0 +1,82 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsysreg.h - Interface to sceSysreg_driver.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPSYSREG_H
+#define PSPSYSREG_H
+
+#include <pspkerneltypes.h>
+
+/** @defgroup Sysreg Interface to the sceSysreg_driver library.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup Sysreg Interface to the sceSysreg_driver library. */
+/**@{*/
+
+/**
+  * Enable the ME reset.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregMeResetEnable(void);
+
+/**
+  * Disable the ME reset.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregMeResetDisable(void);
+
+/**
+  * Enable the VME reset.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregVmeResetEnable(void);
+
+/**
+  * Disable the VME reset.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregVmeResetDisable(void);
+
+/**
+  * Enable the ME bus clock.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregMeBusClockEnable(void);
+
+/**
+  * Disable the ME bus clock.
+  *
+  * @return < 0 on error.
+  */
+int sceSysregMeBusClockDisable(void);
+
+/**
+ * Get the PSP's Tachyon version.
+ */
+int sceSysregGetTachyonVersion(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PSPLOADCORE_H */
diff --git a/newlib/psp/include/pspsystimer.h b/newlib/psp/include/pspsystimer.h
new file mode 100644
index 0000000..1437c80
--- /dev/null
+++ b/newlib/psp/include/pspsystimer.h
@@ -0,0 +1,92 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspsystimer.h - Prototypes for the sceSystimer library.
+ *
+ * Copyright (c) 2007 Iaroslav Gaponenko <adrahil@gmail.com>
+ *
+ */
+
+#ifndef __SYSTIMER_H__
+#define __SYSTIMER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int SceSysTimerId;
+
+/**
+ * Allocate a new SysTimer timer instance.
+ *
+ * @return SysTimerId on success, < 0 on error
+ */
+SceSysTimerId sceSTimerAlloc(void);
+
+/**
+ * Free an instance of a SysTimer timer.
+ *
+ * @param timer - The timer id.
+ *
+ */
+void sceSTimerFree(SceSysTimerId timer);
+
+/**
+ * Start the SysTimer timer count.
+ *
+ * @param timer - The timer id.
+ *
+ */
+void sceSTimerStartCount(SceSysTimerId timer);
+
+/**
+ * Stop the current SysTimer timer count.
+ *
+ * @param timer - The timer id.
+ *
+ */
+void sceSTimerStopCount(SceSysTimerId timer);
+
+/**
+ * Reset the current SysTimer timer count.
+ *
+ * @param timer - The timer id.
+ *
+ */
+void sceSTimerResetCount(SceSysTimerId timer);
+
+/**
+ * Get the current SysTimer timer count.
+ *
+ * @param timer - The timer id.
+ * @param count - The pointer to an integer into which the count will be written.
+ *
+ */
+void sceSTimerGetCount(SceSysTimerId timer, int* count);
+
+/**
+ * Setup a SysTimer handler
+ *
+ * @param timer - The timer id.
+ * @param cycle - The timer cycle in microseconds (???). Maximum: 4194303 which represents ~1/10 seconds.
+ * @param handler - The handler function. Has to return -1.
+ * @param unk1 - Unknown. Pass 0.
+ *
+ */
+void sceSTimerSetHandler(SceSysTimerId timer, int cycle, int (*handler)(void), int unk1);
+
+/* Unknown functions. */
+//probably something to set the cycle of an active timer.
+void SysTimerForKernel_53231A15(SceSysTimerId timer, int unk1);
+//more complex. computes some ratio (unk2/unk1) and saves both parameters into the hardware registers. Might be some sort of scaling factor?
+void SysTimerForKernel_B53534B4(SceSysTimerId timer, int unk1, int unk2);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspthreadman.h b/newlib/psp/include/pspthreadman.h
new file mode 100644
index 0000000..f35c9a2
--- /dev/null
+++ b/newlib/psp/include/pspthreadman.h
@@ -0,0 +1,1836 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspthreadman.h - Library imports for the kernel threading library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2005 Florin Sasu
+ *
+ */
+#ifndef __THREADMAN_H__
+#define __THREADMAN_H__
+
+#include <psptypes.h>
+#include <pspkerneltypes.h>
+/* Include for profile register definitions */
+#include <pspdebug.h>
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+/** @defgroup ThreadMan Thread Manager Library
+  * Library imports for the kernel threading library.
+  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup ThreadMan */
+
+/**@{*/
+
+/** 64-bit system clock type. */
+typedef struct SceKernelSysClock {
+	SceUInt32   low;
+	SceUInt32   hi;
+} SceKernelSysClock;
+
+/** Attribute for threads. */
+enum PspThreadAttributes
+{
+	/** Enable VFPU access for the thread. */
+	PSP_THREAD_ATTR_VFPU = 0x00004000,
+	/** Start the thread in user mode (done automatically 
+	  if the thread creating it is in user mode). */
+	PSP_THREAD_ATTR_USER = 0x80000000,
+	/** Thread is part of the USB/WLAN API. */
+	PSP_THREAD_ATTR_USBWLAN = 0xa0000000,
+	/** Thread is part of the VSH API. */
+	PSP_THREAD_ATTR_VSH = 0xc0000000,
+	/** Allow using scratchpad memory for a thread, NOT USABLE ON V1.0 */
+	PSP_THREAD_ATTR_SCRATCH_SRAM = 0x00008000,
+	/** Disables filling the stack with 0xFF on creation */
+	PSP_THREAD_ATTR_NO_FILLSTACK = 0x00100000,
+	/** Clear the stack when the thread is deleted */
+	PSP_THREAD_ATTR_CLEAR_STACK = 0x00200000,
+};
+
+/* Maintained for compatibility with older versions of PSPSDK. */
+#define THREAD_ATTR_VFPU PSP_THREAD_ATTR_VFPU
+#define THREAD_ATTR_USER PSP_THREAD_ATTR_USER
+
+
+/* Threads. */
+
+typedef int (*SceKernelThreadEntry)(SceSize args, void *argp);
+
+/** Additional options used when creating threads. */
+typedef struct SceKernelThreadOptParam {
+	/** Size of the ::SceKernelThreadOptParam structure. */
+	SceSize 	size;
+	/** UID of the memory block (?) allocated for the thread's stack. */
+	SceUID 		stackMpid;
+} SceKernelThreadOptParam;
+
+/** Structure to hold the status information for a thread
+  * @see sceKernelReferThreadStatus
+  */
+typedef struct SceKernelThreadInfo {
+	/** Size of the structure */
+	SceSize     size;
+	/** Nul terminated name of the thread */
+	char    	name[32];
+	/** Thread attributes */
+	SceUInt     attr;
+	/** Thread status */
+	int     	status;
+	/** Thread entry point */
+	SceKernelThreadEntry    entry;
+	/** Thread stack pointer */
+	void *  	stack;
+	/** Thread stack size */
+	int     	stackSize;
+	/** Pointer to the gp */
+	void *  	gpReg;
+	/** Initial priority */
+	int     	initPriority;
+	/** Current priority */
+	int     	currentPriority;
+	/** Wait type */
+	int     	waitType;
+	/** Wait id */
+	SceUID  	waitId;
+	/** Wakeup count */
+	int     	wakeupCount;
+	/** Exit status of the thread */
+	int     	exitStatus;
+	/** Number of clock cycles run */
+	SceKernelSysClock   runClocks;
+	/** Interrupt preemption count */
+	SceUInt     intrPreemptCount;
+	/** Thread preemption count */
+	SceUInt     threadPreemptCount;
+	/** Release count */
+	SceUInt     releaseCount;
+} SceKernelThreadInfo;
+
+/** Statistics about a running thread.
+ * @see sceKernelReferThreadRunStatus.
+ */
+typedef struct SceKernelThreadRunStatus {
+	SceSize 	size;
+	int 		status;
+	int 		currentPriority;
+	int 		waitType;
+	int 		waitId;
+	int 		wakeupCount;
+	SceKernelSysClock runClocks;
+	SceUInt 	intrPreemptCount;
+	SceUInt 	threadPreemptCount;
+	SceUInt 	releaseCount;
+} SceKernelThreadRunStatus;
+
+/* Sure there must be more than this, but haven't seen them */
+enum PspThreadStatus
+{
+	PSP_THREAD_RUNNING = 1,
+	PSP_THREAD_READY   = 2,
+	PSP_THREAD_WAITING = 4,
+	PSP_THREAD_SUSPEND = 8,
+	PSP_THREAD_STOPPED = 16,
+	PSP_THREAD_KILLED  = 32, /* Thread manager has killed the thread (stack overflow) */
+};
+
+/**
+ * Create a thread
+ *
+ * @par Example:
+ * @code
+ * SceUID thid;
+ * thid = sceKernelCreateThread("my_thread", threadFunc, 0x18, 0x10000, 0, NULL);
+ * @endcode
+ *
+ * @param name - An arbitrary thread name.
+ * @param entry - The thread function to run when started.
+ * @param initPriority - The initial priority of the thread. Less if higher priority.
+ * @param stackSize - The size of the initial stack.
+ * @param attr - The thread attributes, zero or more of ::PspThreadAttributes.
+ * @param option - Additional options specified by ::SceKernelThreadOptParam.
+
+ * @return UID of the created thread, or an error code.
+ */
+SceUID sceKernelCreateThread(const char *name, SceKernelThreadEntry entry, int initPriority,
+                             int stackSize, SceUInt attr, SceKernelThreadOptParam *option);
+
+/**
+ * Delate a thread
+ *
+ * @param thid - UID of the thread to be deleted.
+ *
+ * @return < 0 on error.
+ */
+int sceKernelDeleteThread(SceUID thid);
+
+/**
+ * Start a created thread
+ *
+ * @param thid - Thread id from sceKernelCreateThread
+ * @param arglen - Length of the data pointed to by argp, in bytes
+ * @param argp - Pointer to the arguments.
+ */
+int sceKernelStartThread(SceUID thid, SceSize arglen, void *argp);
+
+/**
+ * Exit a thread
+ *
+ * @param status - Exit status.
+ */
+int sceKernelExitThread(int status);
+
+/** 
+  * Exit a thread and delete itself.
+  *
+  * @param status - Exit status
+  */
+int sceKernelExitDeleteThread(int status);
+
+/**
+ * Terminate a thread.
+ *
+ * @param thid - UID of the thread to terminate.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelTerminateThread(SceUID thid);
+
+/**
+ * Terminate and delete a thread.
+ *
+ * @param thid - UID of the thread to terminate and delete.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelTerminateDeleteThread(SceUID thid);
+
+/**
+ * Suspend the dispatch thread
+ *
+ * @return The current state of the dispatch thread, < 0 on error
+ */
+int sceKernelSuspendDispatchThread(void);
+
+/**
+ * Resume the dispatch thread
+ *
+ * @param state - The state of the dispatch thread 
+ * (from ::sceKernelSuspendDispatchThread)
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelResumeDispatchThread(int state);
+
+/**
+ * Sleep thread
+ *
+ * @return < 0 on error.
+ */
+int sceKernelSleepThread(void);
+
+/**
+ * Sleep thread but service any callbacks as necessary
+ *
+ * @par Example:
+ * @code
+ * // Once all callbacks have been setup call this function
+ * sceKernelSleepThreadCB();
+ * @endcode
+ */
+int sceKernelSleepThreadCB(void);
+
+/**
+ * Wake a thread previously put into the sleep state.
+ *
+ * @param thid - UID of the thread to wake.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelWakeupThread(SceUID thid);
+
+/**
+ * Cancel a thread that was to be woken with ::sceKernelWakeupThread.
+ *
+ * @param thid - UID of the thread to cancel.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelCancelWakeupThread(SceUID thid);
+
+/**
+ * Suspend a thread.
+ *
+ * @param thid - UID of the thread to suspend.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelSuspendThread(SceUID thid);
+
+/**
+ * Resume a thread previously put into a suspended state with ::sceKernelSuspendThread.
+ *
+ * @param thid - UID of the thread to resume.
+ *
+ * @return Success if >= 0, an error if < 0.
+ */
+int sceKernelResumeThread(SceUID thid);
+
+/** 
+  * Wait until a thread has ended.
+  *
+  * @param thid - Id of the thread to wait for.
+  * @param timeout - Timeout in microseconds (assumed).
+  *
+  * @return < 0 on error.
+  */
+int sceKernelWaitThreadEnd(SceUID thid, SceUInt *timeout);
+
+/** 
+  * Wait until a thread has ended and handle callbacks if necessary.
+  *
+  * @param thid - Id of the thread to wait for.
+  * @param timeout - Timeout in microseconds (assumed).
+  *
+  * @return < 0 on error.
+  */
+int sceKernelWaitThreadEndCB(SceUID thid, SceUInt *timeout);
+
+/**
+  * Delay the current thread by a specified number of microseconds
+  *
+  * @param delay - Delay in microseconds.
+  *
+  * @par Example:
+  * @code
+  * sceKernelDelayThread(1000000); // Delay for a second
+  * @endcode
+  */
+int sceKernelDelayThread(SceUInt delay);
+
+/**
+  * Delay the current thread by a specified number of microseconds and handle any callbacks.
+  *
+  * @param delay - Delay in microseconds.
+  *
+  * @par Example:
+  * @code
+  * sceKernelDelayThread(1000000); // Delay for a second
+  * @endcode
+  */
+int sceKernelDelayThreadCB(SceUInt delay);
+
+/**
+  * Delay the current thread by a specified number of sysclocks
+  *
+  * @param delay - Delay in sysclocks
+  *
+  * @return 0 on success, < 0 on error
+  */
+int sceKernelDelaySysClockThread(SceKernelSysClock *delay);
+
+/**
+  * Delay the current thread by a specified number of sysclocks handling callbacks
+  *
+  * @param delay - Delay in sysclocks
+  *
+  * @return 0 on success, < 0 on error
+  *
+  */
+int sceKernelDelaySysClockThreadCB(SceKernelSysClock *delay);
+
+/**
+ * Modify the attributes of the current thread.
+ *
+ * @param unknown - Set to 0.
+ * @param attr - The thread attributes to modify.  One of ::PspThreadAttributes.
+ *
+ * @return < 0 on error.
+ */
+int sceKernelChangeCurrentThreadAttr(int unknown, SceUInt attr);
+
+/**
+  * Change the threads current priority.
+  * 
+  * @param thid - The ID of the thread (from sceKernelCreateThread or sceKernelGetThreadId)
+  * @param priority - The new priority (the lower the number the higher the priority)
+  *
+  * @par Example:
+  * @code
+  * int thid = sceKernelGetThreadId();
+  * // Change priority of current thread to 16
+  * sceKernelChangeThreadPriority(thid, 16);
+  * @endcode
+  *
+  * @return 0 if successful, otherwise the error code.
+  */
+int sceKernelChangeThreadPriority(SceUID thid, int priority);
+
+/**
+ * Rotate thread ready queue at a set priority
+ *
+ * @param priority - The priority of the queue
+ * 
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelRotateThreadReadyQueue(int priority);
+
+/**
+ * Release a thread in the wait state.
+ *
+ * @param thid - The UID of the thread.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReleaseWaitThread(SceUID thid);
+
+/** 
+  * Get the current thread Id
+  *
+  * @return The thread id of the calling thread.
+  */
+int sceKernelGetThreadId(void);
+
+/**
+ * Get the current priority of the thread you are in.
+ *
+ * @return The current thread priority
+ */
+int sceKernelGetThreadCurrentPriority(void);
+
+/**
+ * Get the exit status of a thread.
+ *
+ * @param thid - The UID of the thread to check.
+ *
+ * @return The exit status
+ */
+int sceKernelGetThreadExitStatus(SceUID thid);
+
+/**
+ * Check the thread stack?
+ *
+ * @return Unknown.
+ */
+int sceKernelCheckThreadStack(void);
+
+/**
+ * Get the free stack size for a thread.
+ *
+ * @param thid - The thread ID. Seem to take current thread
+ * if set to 0.
+ *
+ * @return The free size.
+ */
+int sceKernelGetThreadStackFreeSize(SceUID thid);
+
+/** 
+  * Get the status information for the specified thread.
+  * 
+  * @param thid - Id of the thread to get status
+  * @param info - Pointer to the info structure to receive the data.
+  * Note: The structures size field should be set to
+  * sizeof(SceKernelThreadInfo) before calling this function.
+  *
+  * @par Example:
+  * @code
+  * SceKernelThreadInfo status;
+  * status.size = sizeof(SceKernelThreadInfo);
+  * if(sceKernelReferThreadStatus(thid, &status) == 0)
+  * { Do something... }
+  * @endcode 
+  * @return 0 if successful, otherwise the error code.
+  */
+int sceKernelReferThreadStatus(SceUID thid, SceKernelThreadInfo *info);
+
+/**
+ * Retrive the runtime status of a thread.
+ *
+ * @param thid - UID of the thread to retrive status.
+ * @param status - Pointer to a ::SceKernelThreadRunStatus struct to receive the runtime status.
+ *
+ * @return 0 if successful, otherwise the error code.
+ */
+int sceKernelReferThreadRunStatus(SceUID thid, SceKernelThreadRunStatus *status);
+
+
+/* Semaphores. */
+
+/** Additional options used when creating semaphores. */
+typedef struct SceKernelSemaOptParam {
+	/** Size of the ::SceKernelSemaOptParam structure. */
+	SceSize 	size;
+} SceKernelSemaOptParam;
+
+/** Current state of a semaphore.
+ * @see sceKernelReferSemaStatus.
+ */
+typedef struct SceKernelSemaInfo {
+	/** Size of the ::SceKernelSemaInfo structure. */
+	SceSize 	size;
+	/** NUL-terminated name of the semaphore. */
+	char 		name[32];
+	/** Attributes. */
+	SceUInt 	attr;
+	/** The initial count the semaphore was created with. */
+	int 		initCount;
+	/** The current count. */
+	int 		currentCount;
+	/** The maximum count. */
+	int 		maxCount;
+	/** The number of threads waiting on the semaphore. */
+	int 		numWaitThreads;
+} SceKernelSemaInfo;
+
+/**
+ * Creates a new semaphore
+ *
+ * @par Example:
+ * @code
+ * int semaid;
+ * semaid = sceKernelCreateSema("MyMutex", 0, 1, 1, 0);
+ * @endcode
+ *
+ * @param name - Specifies the name of the sema
+ * @param attr - Sema attribute flags (normally set to 0)
+ * @param initVal - Sema initial value 
+ * @param maxVal - Sema maximum value
+ * @param option - Sema options (normally set to 0)
+ * @return A semaphore id
+ */
+SceUID sceKernelCreateSema(const char *name, SceUInt attr, int initVal, int maxVal, SceKernelSemaOptParam *option);
+
+/**
+ * Destroy a semaphore
+ *
+ * @param semaid - The semaid returned from a previous create call.
+ * @return Returns the value 0 if its succesful otherwise -1
+ */
+int sceKernelDeleteSema(SceUID semaid);
+
+/**
+ * Send a signal to a semaphore
+ *
+ * @par Example:
+ * @code
+ * // Signal the sema
+ * sceKernelSignalSema(semaid, 1);
+ * @endcode
+ *
+ * @param semaid - The sema id returned from sceKernelCreateSema
+ * @param signal - The amount to signal the sema (i.e. if 2 then increment the sema by 2)
+ *
+ * @return < 0 On error.
+ */
+int sceKernelSignalSema(SceUID semaid, int signal);
+
+/**
+ * Lock a semaphore
+ *
+ * @par Example:
+ * @code
+ * sceKernelWaitSema(semaid, 1, 0);
+ * @endcode
+ *
+ * @param semaid - The sema id returned from sceKernelCreateSema
+ * @param signal - The value to wait for (i.e. if 1 then wait till reaches a signal state of 1)
+ * @param timeout - Timeout in microseconds (assumed).
+ *
+ * @return < 0 on error.
+ */
+int sceKernelWaitSema(SceUID semaid, int signal, SceUInt *timeout);
+
+/**
+ * Lock a semaphore a handle callbacks if necessary.
+ *
+ * @par Example:
+ * @code
+ * sceKernelWaitSemaCB(semaid, 1, 0);
+ * @endcode
+ *
+ * @param semaid - The sema id returned from sceKernelCreateSema
+ * @param signal - The value to wait for (i.e. if 1 then wait till reaches a signal state of 1)
+ * @param timeout - Timeout in microseconds (assumed).
+ *
+ * @return < 0 on error.
+ */
+int sceKernelWaitSemaCB(SceUID semaid, int signal, SceUInt *timeout);
+
+/**
+ * Poll a sempahore.
+ *
+ * @param semaid - UID of the semaphore to poll.
+ * @param signal - The value to test for.
+ *
+ * @return < 0 on error.
+ */
+int sceKernelPollSema(SceUID semaid, int signal);
+
+/**
+ * Retrieve information about a semaphore.
+ *
+ * @param semaid - UID of the semaphore to retrieve info for.
+ * @param info - Pointer to a ::SceKernelSemaInfo struct to receive the info.
+ *
+ * @return < 0 on error.
+ */
+int sceKernelReferSemaStatus(SceUID semaid, SceKernelSemaInfo *info);
+
+/** Struct as workarea for lightweight mutex */
+typedef struct {
+    /** Count */
+    int lockLevel;
+    /** Locking thread */
+    SceUID lockThread;
+    /** Attribute */
+    int attr;
+    /** Number of waiting threads */
+    int numWaitThreads;
+    /** UID */
+    SceUID uid;
+    /** Padding */
+    int pad[3];
+} SceLwMutexWorkarea;
+
+/**
+ * Create a lightweight mutex
+ *
+ * @param workarea - The pointer to the workarea
+ * @param name - The name of the lightweight mutex
+ * @param attr - 
+ * @param initialCount - THe inital value of the mutex
+ * @param optionsPTr - Other optioons for mutex
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelCreateLwMutex(SceLwMutexWorkarea *workarea, const char *name, u32 attr, int initialCount, u32 *optionsPtr);
+
+/**
+ * Delete a lightweight mutex
+ *
+ * @param workarea - The pointer to the workarea
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelDeleteLwMutex(SceLwMutexWorkarea *workarea);
+
+/**
+ * Try to lock a lightweight mutex
+ *
+ * @param workarea - The pointer to the workarea
+ * @param lockCount - value of increase the lock counter
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelTryLockLwMutex(SceLwMutexWorkarea *workarea, int lockCount);
+
+/**
+ * Lock a lightweight mutex
+ *
+ * @param workarea - The pointer to the workarea
+ * @param lockCount - value of increase the lock counter
+ * @param pTimeout - The pointer for timeout waiting
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelLockLwMutex(SceLwMutexWorkarea *workarea, int lockCount, unsigned int *pTimeout);
+
+/**
+ * Lock a lightweight mutex
+ *
+ * @param workarea - The pointer to the workarea
+ * @param name - The name of the lightweight mutex
+ * @param lockCount - value of decrease the lock counter
+ *
+ * @return 0 on success, otherwise one of ::PspKernelErrorCodes
+ */
+int sceKernelUnlockLwMutex(SceLwMutexWorkarea *workarea, int lockCount);
+
+/* Event flags. */
+
+/** Structure to hold the event flag information */
+typedef struct SceKernelEventFlagInfo {
+	SceSize 	size;
+	char 		name[32];
+	SceUInt 	attr;
+	SceUInt 	initPattern;
+	SceUInt 	currentPattern;
+	int 		numWaitThreads;
+} SceKernelEventFlagInfo;
+
+struct SceKernelEventFlagOptParam {
+	SceSize 	size;
+};
+
+typedef struct SceKernelEventFlagOptParam SceKernelEventFlagOptParam;
+
+/** Event flag creation attributes */
+enum PspEventFlagAttributes
+{
+	/** Allow the event flag to be waited upon by multiple threads */
+	PSP_EVENT_WAITMULTIPLE = 0x200
+};
+
+/** Event flag wait types */
+enum PspEventFlagWaitTypes
+{
+	/** Wait for all bits in the pattern to be set */
+	PSP_EVENT_WAITAND = 0,
+	/** Wait for one or more bits in the pattern to be set */
+	PSP_EVENT_WAITOR  = 1,
+	/** Clear the wait pattern when it matches */
+	PSP_EVENT_WAITCLEAR = 0x20
+};
+
+/** 
+  * Create an event flag.
+  *
+  * @param name - The name of the event flag.
+  * @param attr - Attributes from ::PspEventFlagAttributes
+  * @param bits - Initial bit pattern.
+  * @param opt  - Options, set to NULL
+  * @return < 0 on error. >= 0 event flag id.
+  *
+  * @par Example:
+  * @code
+  * int evid;
+  * evid = sceKernelCreateEventFlag("wait_event", 0, 0, 0);
+  * @endcode
+  */
+SceUID sceKernelCreateEventFlag(const char *name, int attr, int bits, SceKernelEventFlagOptParam *opt);
+
+/** 
+  * Set an event flag bit pattern.
+  *
+  * @param evid - The event id returned by sceKernelCreateEventFlag.
+  * @param bits - The bit pattern to set.
+  *
+  * @return < 0 On error
+  */
+int sceKernelSetEventFlag(SceUID evid, u32 bits);
+
+/**
+ * Clear a event flag bit pattern
+ *
+ * @param evid - The event id returned by ::sceKernelCreateEventFlag
+ * @param bits - The bits to clean
+ *
+ * @return < 0 on Error
+ */
+int sceKernelClearEventFlag(SceUID evid, u32 bits);
+
+/** 
+  * Poll an event flag for a given bit pattern.
+  *
+  * @param evid - The event id returned by sceKernelCreateEventFlag.
+  * @param bits - The bit pattern to poll for.
+  * @param wait - Wait type, one or more of ::PspEventFlagWaitTypes or'ed together
+  * @param outBits - The bit pattern that was matched.
+  * @return < 0 On error
+  */
+int sceKernelPollEventFlag(int evid, u32 bits, u32 wait, u32 *outBits);
+
+/** 
+  * Wait for an event flag for a given bit pattern.
+  *
+  * @param evid - The event id returned by sceKernelCreateEventFlag.
+  * @param bits - The bit pattern to poll for.
+  * @param wait - Wait type, one or more of ::PspEventFlagWaitTypes or'ed together
+  * @param outBits - The bit pattern that was matched.
+  * @param timeout  - Timeout in microseconds
+  * @return < 0 On error
+  */
+int sceKernelWaitEventFlag(int evid, u32 bits, u32 wait, u32 *outBits, SceUInt *timeout);
+
+/** 
+  * Wait for an event flag for a given bit pattern with callback.
+  *
+  * @param evid - The event id returned by sceKernelCreateEventFlag.
+  * @param bits - The bit pattern to poll for.
+  * @param wait - Wait type, one or more of ::PspEventFlagWaitTypes or'ed together
+  * @param outBits - The bit pattern that was matched.
+  * @param timeout  - Timeout in microseconds
+  * @return < 0 On error
+  */
+int sceKernelWaitEventFlagCB(int evid, u32 bits, u32 wait, u32 *outBits, SceUInt *timeout);
+
+/** 
+  * Delete an event flag
+  *
+  * @param evid - The event id returned by sceKernelCreateEventFlag.
+  *
+  * @return < 0 On error
+  */
+int sceKernelDeleteEventFlag(int evid);
+
+/** 
+  * Get the status of an event flag.
+  * 
+  * @param event - The UID of the event.
+  * @param status - A pointer to a ::SceKernelEventFlagInfo structure.
+  *
+  * @return < 0 on error.
+  */
+int sceKernelReferEventFlagStatus(SceUID event, SceKernelEventFlagInfo *status);
+
+
+/* Message boxes. */
+
+/** Additional options used when creating messageboxes. */
+typedef struct SceKernelMbxOptParam {
+	/** Size of the ::SceKernelMbxOptParam structure. */
+	SceSize 	size;
+} SceKernelMbxOptParam;
+
+/** Current state of a messagebox.
+ * @see sceKernelReferMbxStatus.
+ */
+typedef struct SceKernelMbxInfo {
+	/** Size of the ::SceKernelMbxInfo structure. */
+	SceSize 	size;
+	/** NUL-terminated name of the messagebox. */
+	char 		name[32];
+	/** Attributes. */
+	SceUInt 	attr;
+	/** The number of threads waiting on the messagebox. */
+	int 		numWaitThreads;
+	/** Number of messages currently in the messagebox. */
+	int 		numMessages;
+	/** The message currently at the head of the queue. */
+	void		*firstMessage;
+} SceKernelMbxInfo;
+
+/**
+ * Header for a message box packet
+ */
+typedef struct SceKernelMsgPacket {
+	/** Pointer to next msg (used by the kernel) */
+	struct SceKernelMsgPacket *next;
+	/** Priority ? */
+	SceUChar    msgPriority;
+	SceUChar    dummy[3];
+	/** After this can be any user defined data */
+} SceKernelMsgPacket;
+
+/**
+ * Creates a new messagebox
+ *
+ * @par Example:
+ * @code
+ * int mbxid;
+ * mbxid = sceKernelCreateMbx("MyMessagebox", 0, NULL);
+ * @endcode
+ *
+ * @param name - Specifies the name of the mbx
+ * @param attr - Mbx attribute flags (normally set to 0)
+ * @param option - Mbx options (normally set to NULL)
+ * @return A messagebox id
+ */
+SceUID sceKernelCreateMbx(const char *name, SceUInt attr, SceKernelMbxOptParam *option);
+
+/**
+ * Destroy a messagebox
+ *
+ * @param mbxid - The mbxid returned from a previous create call.
+ * @return Returns the value 0 if its succesful otherwise an error code
+ */
+int sceKernelDeleteMbx(SceUID mbxid);
+
+/**
+ * Send a message to a messagebox
+ *
+ * @par Example:
+ * @code
+ * struct MyMessage {
+ * 	SceKernelMsgPacket header;
+ * 	char text[8];
+ * };
+ *
+ * struct MyMessage msg = { {0}, "Hello" };
+ * // Send the message
+ * sceKernelSendMbx(mbxid, (void*) &msg);
+ * @endcode
+ *
+ * @param mbxid - The mbx id returned from sceKernelCreateMbx
+ * @param message - A message to be forwarded to the receiver.
+ * 					The start of the message should be the 
+ * 					::SceKernelMsgPacket structure, the rest
+ *
+ * @return < 0 On error.
+ */
+int sceKernelSendMbx(SceUID mbxid, void *message);
+
+/**
+ * Wait for a message to arrive in a messagebox
+ *
+ * @par Example:
+ * @code
+ * void *msg;
+ * sceKernelReceiveMbx(mbxid, &msg, NULL);
+ * @endcode
+ *
+ * @param mbxid - The mbx id returned from sceKernelCreateMbx
+ * @param pmessage - A pointer to where a pointer to the
+ *                   received message should be stored
+ * @param timeout - Timeout in microseconds
+ *
+ * @return < 0 on error.
+ */
+int sceKernelReceiveMbx(SceUID mbxid, void **pmessage, SceUInt *timeout);
+
+/**
+ * Wait for a message to arrive in a messagebox and handle callbacks if necessary.
+ *
+ * @par Example:
+ * @code
+ * void *msg;
+ * sceKernelReceiveMbxCB(mbxid, &msg, NULL);
+ * @endcode
+ *
+ * @param mbxid - The mbx id returned from sceKernelCreateMbx
+ * @param pmessage - A pointer to where a pointer to the
+ *                   received message should be stored
+ * @param timeout - Timeout in microseconds
+ *
+ * @return < 0 on error.
+ */
+int sceKernelReceiveMbxCB(SceUID mbxid, void **pmessage, SceUInt *timeout);
+
+/**
+ * Check if a message has arrived in a messagebox
+ *
+ * @par Example:
+ * @code
+ * void *msg;
+ * sceKernelPollMbx(mbxid, &msg);
+ * @endcode
+ *
+ * @param mbxid - The mbx id returned from sceKernelCreateMbx
+ * @param pmessage - A pointer to where a pointer to the
+ *                   received message should be stored
+ *
+ * @return < 0 on error (SCE_KERNEL_ERROR_MBOX_NOMSG if the mbx is empty).
+ */
+int sceKernelPollMbx(SceUID mbxid, void **pmessage);
+
+/**
+ * Abort all wait operations on a messagebox
+ *
+ * @par Example:
+ * @code
+ * sceKernelCancelReceiveMbx(mbxid, NULL);
+ * @endcode
+ *
+ * @param mbxid - The mbx id returned from sceKernelCreateMbx
+ * @param pnum  - A pointer to where the number of threads which
+ *                were waiting on the mbx should be stored (NULL
+ *                if you don't care)
+ *
+ * @return < 0 on error
+ */
+int sceKernelCancelReceiveMbx(SceUID mbxid, int *pnum);
+
+/**
+ * Retrieve information about a messagebox.
+ *
+ * @param mbxid - UID of the messagebox to retrieve info for.
+ * @param info - Pointer to a ::SceKernelMbxInfo struct to receive the info.
+ *
+ * @return < 0 on error.
+ */
+int sceKernelReferMbxStatus(SceUID mbxid, SceKernelMbxInfo *info);
+
+
+/* Alarms. */
+
+/** Prototype for alarm handlers. */
+typedef SceUInt (*SceKernelAlarmHandler)(void *common);
+
+/** Struct containing alarm info */
+typedef struct SceKernelAlarmInfo {
+	/** Size of the structure (should be set before calling
+	 * :: sceKernelReferAlarmStatus */
+	SceSize		size;
+	/* The current schedule */
+	SceKernelSysClock schedule;
+	/** Pointer to the alarm handler */
+	SceKernelAlarmHandler handler;
+	/** Common pointer argument */
+	void *		common;
+} SceKernelAlarmInfo;
+
+/** 
+ * Set an alarm.
+ * @param clock - The number of micro seconds till the alarm occurrs.
+ * @param handler - Pointer to a ::SceKernelAlarmHandler
+ * @param common - Common pointer for the alarm handler
+ *
+ * @return A UID representing the created alarm, < 0 on error.
+ */
+SceUID sceKernelSetAlarm(SceUInt clock, SceKernelAlarmHandler handler, void *common);
+
+/**
+ * Set an alarm using a ::SceKernelSysClock structure for the time
+ * 
+ * @param clock - Pointer to a ::SceKernelSysClock structure
+ * @param handler - Pointer to a ::SceKernelAlarmHandler
+ * @param common - Common pointer for the alarm handler.
+ * 
+ * @return A UID representing the created alarm, < 0 on error.
+ */
+SceUID sceKernelSetSysClockAlarm(SceKernelSysClock *clock, SceKernelAlarmHandler handler, void *common);
+
+/**
+ * Cancel a pending alarm.
+ *
+ * @param alarmid - UID of the alarm to cancel.
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelCancelAlarm(SceUID alarmid);
+
+/**
+ * Refer the status of a created alarm.
+ *
+ * @param alarmid - UID of the alarm to get the info of
+ * @param info - Pointer to a ::SceKernelAlarmInfo structure
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceKernelReferAlarmStatus(SceUID alarmid, SceKernelAlarmInfo *info);
+
+/* Callbacks. */
+
+/** Callback function prototype */
+typedef int (*SceKernelCallbackFunction)(int arg1, int arg2, void *arg);
+
+/** Structure to hold the status information for a callback */
+typedef struct SceKernelCallbackInfo {
+	/** Size of the structure (i.e. sizeof(SceKernelCallbackInfo)) */
+	SceSize 	size;
+	/** The name given to the callback */
+	char 	name[32];
+	/** The thread id associated with the callback */
+	SceUID 	threadId;
+	/** Pointer to the callback function */
+	SceKernelCallbackFunction 	callback;
+	/** User supplied argument for the callback */
+	void * 	common;
+	/** Unknown */
+	int 	notifyCount;
+	/** Unknown */
+	int 	notifyArg;
+} SceKernelCallbackInfo;
+
+/**
+ * Create callback
+ *
+ * @par Example:
+ * @code
+ * int cbid;
+ * cbid = sceKernelCreateCallback("Exit Callback", exit_cb, NULL);
+ * @endcode
+ *
+ * @param name - A textual name for the callback
+ * @param func - A pointer to a function that will be called as the callback
+ * @param arg  - Argument for the callback ?
+ *
+ * @return >= 0 A callback id which can be used in subsequent functions, < 0 an error.
+ */
+int sceKernelCreateCallback(const char *name, SceKernelCallbackFunction func, void *arg);
+
+/**
+  * Gets the status of a specified callback.
+  *
+  * @param cb - The UID of the callback to refer.
+  * @param status - Pointer to a status structure. The size parameter should be
+  * initialised before calling.
+  *
+  * @return < 0 on error.
+  */
+int sceKernelReferCallbackStatus(SceUID cb, SceKernelCallbackInfo *status);
+
+/**
+ * Delete a callback
+ *
+ * @param cb - The UID of the specified callback
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelDeleteCallback(SceUID cb);
+
+/**
+ * Notify a callback
+ *
+ * @param cb - The UID of the specified callback
+ * @param arg2 - Passed as arg2 into the callback function
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelNotifyCallback(SceUID cb, int arg2);
+
+/**
+ * Cancel a callback ?
+ *
+ * @param cb - The UID of the specified callback
+ *
+ * @return 0 on succes, < 0 on error
+ */
+int sceKernelCancelCallback(SceUID cb);
+
+/**
+ * Get the callback count
+ *
+ * @param cb - The UID of the specified callback
+ *
+ * @return The callback count, < 0 on error
+ */
+int sceKernelGetCallbackCount(SceUID cb);
+
+/**
+ * Check callback ?
+ *
+ * @return Something or another
+ */
+int sceKernelCheckCallback(void);
+
+/* Misc. */
+
+/** Threadman types for ::sceKernelGetThreadmanIdList */
+enum SceKernelIdListType
+{
+	SCE_KERNEL_TMID_Thread = 1,
+	SCE_KERNEL_TMID_Semaphore = 2,
+	SCE_KERNEL_TMID_EventFlag = 3,
+	SCE_KERNEL_TMID_Mbox = 4,
+	SCE_KERNEL_TMID_Vpl = 5,
+	SCE_KERNEL_TMID_Fpl = 6,
+	SCE_KERNEL_TMID_Mpipe = 7,
+	SCE_KERNEL_TMID_Callback = 8,
+	SCE_KERNEL_TMID_ThreadEventHandler = 9,
+	SCE_KERNEL_TMID_Alarm = 10,
+	SCE_KERNEL_TMID_VTimer = 11,
+	SCE_KERNEL_TMID_SleepThread = 64,
+	SCE_KERNEL_TMID_DelayThread = 65,
+	SCE_KERNEL_TMID_SuspendThread = 66,
+	SCE_KERNEL_TMID_DormantThread = 67,
+};
+
+/**
+  * Get a list of UIDs from threadman. Allows you to enumerate 
+  * resources such as threads or semaphores.
+  *
+  * @param type - The type of resource to list, one of ::SceKernelIdListType.
+  * @param readbuf - A pointer to a buffer to store the list.
+  * @param readbufsize - The size of the buffer in SceUID units.
+  * @param idcount - Pointer to an integer in which to return the number of ids in the list.
+  *
+  * @return < 0 on error. Either 0 or the same as idcount on success.
+  */
+int sceKernelGetThreadmanIdList(enum SceKernelIdListType type, SceUID *readbuf, int readbufsize, int *idcount);
+
+/** Structure to contain the system status returned by ::sceKernelReferSystemStatus */
+typedef struct SceKernelSystemStatus {
+	/** Size of the structure (should be set prior to the call) */
+	SceSize 	size;
+	/** The status ? */
+	SceUInt 	status;
+	/** The number of cpu clocks in the idle thread */
+	SceKernelSysClock 	idleClocks;
+	/** Number of times we resumed from idle */
+	SceUInt 	comesOutOfIdleCount;
+	/** Number of thread context switches */
+	SceUInt 	threadSwitchCount;
+	/** Number of vfpu switches ? */
+	SceUInt 	vfpuSwitchCount;
+} SceKernelSystemStatus;
+
+/**
+  * Get the current system status.
+  *
+  * @param status - Pointer to a ::SceKernelSystemStatus structure.
+  *
+  * @return < 0 on error.
+  */
+int sceKernelReferSystemStatus(SceKernelSystemStatus *status);
+
+
+/**
+ * Create a message pipe
+ *
+ * @param name - Name of the pipe
+ * @param part - ID of the memory partition
+ * @param attr - Set to 0?
+ * @param unk1 - Unknown
+ * @param opt  - Message pipe options (set to NULL)
+ *
+ * @return The UID of the created pipe, < 0 on error
+ */
+SceUID sceKernelCreateMsgPipe(const char *name, int part, int attr, void *unk1, void *opt);
+
+/**
+ * Delete a message pipe
+ *
+ * @param uid - The UID of the pipe
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelDeleteMsgPipe(SceUID uid);
+
+/**
+ * Send a message to a pipe
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ * @param timeout - Timeout for send
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSendMsgPipe(SceUID uid, void *message, unsigned int size, int unk1, void *unk2, unsigned int *timeout);
+
+/**
+ * Send a message to a pipe (with callback)
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ * @param timeout - Timeout for send
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSendMsgPipeCB(SceUID uid, void *message, unsigned int size, int unk1, void *unk2, unsigned int *timeout);
+
+/**
+ * Try to send a message to a pipe
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelTrySendMsgPipe(SceUID uid, void *message, unsigned int size, int unk1, void *unk2);
+
+/**
+ * Receive a message from a pipe
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ * @param timeout - Timeout for receive
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReceiveMsgPipe(SceUID uid, void *message, unsigned int size, int unk1, void *unk2, unsigned int *timeout);
+
+/**
+ * Receive a message from a pipe (with callback)
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ * @param timeout - Timeout for receive
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReceiveMsgPipeCB(SceUID uid, void *message, unsigned int size, int unk1, void *unk2, unsigned int *timeout);
+
+/**
+ * Receive a message from a pipe
+ *
+ * @param uid - The UID of the pipe
+ * @param message - Pointer to the message
+ * @param size - Size of the message
+ * @param unk1 - Unknown
+ * @param unk2 - Unknown
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelTryReceiveMsgPipe(SceUID uid, void *message, unsigned int size, int unk1, void *unk2);
+
+/**
+ * Cancel a message pipe
+ *
+ * @param uid - UID of the pipe to cancel
+ * @param psend - Receive number of sending threads?
+ * @param precv - Receive number of receiving threads?
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelCancelMsgPipe(SceUID uid, int *psend, int *precv);
+
+/** Message Pipe status info */
+typedef struct SceKernelMppInfo {
+	SceSize 	size;
+	char 	name[32];
+	SceUInt 	attr;
+	int 	bufSize;
+	int 	freeSize;
+	int 	numSendWaitThreads;
+	int 	numReceiveWaitThreads;
+} SceKernelMppInfo;
+ 
+/**
+ * Get the status of a Message Pipe
+ *
+ * @param uid - The uid of the Message Pipe
+ * @param info - Pointer to a ::SceKernelMppInfo structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReferMsgPipeStatus(SceUID uid, SceKernelMppInfo *info);
+
+/* VPL Functions */
+
+struct SceKernelVplOptParam {
+	SceSize 	size;
+};
+
+/**
+ * Create a variable pool
+ *
+ * @param name - Name of the pool
+ * @param part - The memory partition ID
+ * @param attr - Attributes
+ * @param size - Size of pool
+ * @param opt  - Options (set to NULL)
+ *
+ * @return The UID of the created pool, < 0 on error.
+ */
+SceUID sceKernelCreateVpl(const char *name, int part, int attr, unsigned int size, struct SceKernelVplOptParam *opt);
+
+/**
+ * Delete a variable pool
+ *
+ * @param uid - The UID of the pool
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelDeleteVpl(SceUID uid);
+
+/**
+ * Allocate from the pool
+ *
+ * @param uid - The UID of the pool
+ * @param size - The size to allocate
+ * @param data - Receives the address of the allocated data
+ * @param timeout - Amount of time to wait for allocation?
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelAllocateVpl(SceUID uid, unsigned int size, void **data, unsigned int *timeout);
+
+/**
+ * Allocate from the pool (with callback)
+ *
+ * @param uid - The UID of the pool
+ * @param size - The size to allocate
+ * @param data - Receives the address of the allocated data
+ * @param timeout - Amount of time to wait for allocation?
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelAllocateVplCB(SceUID uid, unsigned int size, void **data, unsigned int *timeout);
+
+/**
+ * Try to allocate from the pool 
+ *
+ * @param uid - The UID of the pool
+ * @param size - The size to allocate
+ * @param data - Receives the address of the allocated data
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelTryAllocateVpl(SceUID uid, unsigned int size, void **data);
+
+/**
+ * Free a block
+ *
+ * @param uid - The UID of the pool
+ * @param data - The data block to deallocate
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelFreeVpl(SceUID uid, void *data);
+
+/**
+ * Cancel a pool
+ *
+ * @param uid - The UID of the pool
+ * @param pnum - Receives the number of waiting threads
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelCancelVpl(SceUID uid, int *pnum);
+
+/** Variable pool status info */
+typedef struct SceKernelVplInfo {
+	SceSize 	size;
+	char 	name[32];
+	SceUInt 	attr;
+	int 	poolSize;
+	int 	freeSize;
+	int 	numWaitThreads;
+} SceKernelVplInfo;
+
+/**
+ * Get the status of an VPL
+ *
+ * @param uid - The uid of the VPL
+ * @param info - Pointer to a ::SceKernelVplInfo structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReferVplStatus(SceUID uid, SceKernelVplInfo *info);
+
+/* FPL Functions */
+
+struct SceKernelFplOptParam {
+	SceSize 	size;
+};
+
+/**
+ * Create a fixed pool
+ *
+ * @param name - Name of the pool
+ * @param part - The memory partition ID
+ * @param attr - Attributes
+ * @param size - Size of pool block
+ * @param blocks - Number of blocks to allocate
+ * @param opt  - Options (set to NULL)
+ *
+ * @return The UID of the created pool, < 0 on error.
+ */
+int sceKernelCreateFpl(const char *name, int part, int attr, unsigned int size, unsigned int blocks, struct SceKernelFplOptParam *opt);
+
+/**
+ * Delete a fixed pool
+ *
+ * @param uid - The UID of the pool
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelDeleteFpl(SceUID uid);
+
+/**
+ * Allocate from the pool
+ *
+ * @param uid - The UID of the pool
+ * @param data - Receives the address of the allocated data
+ * @param timeout - Amount of time to wait for allocation?
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelAllocateFpl(SceUID uid, void **data, unsigned int *timeout);
+
+/**
+ * Allocate from the pool (with callback)
+ *
+ * @param uid - The UID of the pool
+ * @param data - Receives the address of the allocated data
+ * @param timeout - Amount of time to wait for allocation?
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelAllocateFplCB(SceUID uid, void **data, unsigned int *timeout);
+
+/**
+ * Try to allocate from the pool 
+ *
+ * @param uid - The UID of the pool
+ * @param data - Receives the address of the allocated data
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelTryAllocateFpl(SceUID uid, void **data);
+
+/**
+ * Free a block
+ *
+ * @param uid - The UID of the pool
+ * @param data - The data block to deallocate
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelFreeFpl(SceUID uid, void *data);
+
+/**
+ * Cancel a pool
+ *
+ * @param uid - The UID of the pool
+ * @param pnum - Receives the number of waiting threads
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelCancelFpl(SceUID uid, int *pnum);
+
+/** Fixed pool status information */
+typedef struct SceKernelFplInfo {
+	SceSize 	size;
+	char 	name[32];
+	SceUInt 	attr;
+	int 	blockSize;
+	int 	numBlocks;
+	int 	freeBlocks;
+	int 	numWaitThreads;
+} SceKernelFplInfo;
+
+/**
+ * Get the status of an FPL
+ *
+ * @param uid - The uid of the FPL
+ * @param info - Pointer to a ::SceKernelFplInfo structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReferFplStatus(SceUID uid, SceKernelFplInfo *info);
+
+/**
+ * Return from a timer handler (doesn't seem to do alot)
+ */
+void _sceKernelReturnFromTimerHandler(void);
+
+/**
+ * Return from a callback (used as a syscall for the return 
+ * of the callback function)
+ */
+void _sceKernelReturnFromCallback(void);
+
+/**
+ * Convert a number of microseconds to a ::SceKernelSysClock structure
+ *
+ * @param usec - Number of microseconds
+ * @param clock - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelUSec2SysClock(unsigned int usec, SceKernelSysClock *clock);
+
+/**
+ * Convert a number of microseconds to a wide time
+ * 
+ * @param usec - Number of microseconds.
+ *
+ * @return The time
+ */
+SceInt64 sceKernelUSec2SysClockWide(unsigned int usec);
+
+/**
+ * Convert a ::SceKernelSysClock structure to microseconds
+ *
+ * @param clock - Pointer to a ::SceKernelSysClock structure
+ * @param low - Pointer to the low part of the time
+ * @param high - Pointer to the high part of the time
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSysClock2USec(SceKernelSysClock *clock, unsigned int *low, unsigned int *high);
+
+/**
+ * Convert a wide time to microseconds
+ *
+ * @param clock - Wide time
+ * @param low - Pointer to the low part of the time
+ * @param high - Pointer to the high part of the time
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSysClock2USecWide(SceInt64 clock, unsigned *low, unsigned int *high);
+
+/**
+ * Get the system time
+ *
+ * @param time - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelGetSystemTime(SceKernelSysClock *time);
+
+/**
+ * Get the system time (wide version)
+ *
+ * @return The system time
+ */
+SceInt64 sceKernelGetSystemTimeWide(void);
+
+/**
+ * Get the low 32bits of the current system time
+ *
+ * @return The low 32bits of the system time
+ */
+unsigned int sceKernelGetSystemTimeLow(void);
+
+struct SceKernelVTimerOptParam {
+	SceSize 	size;
+};
+
+/**
+ * Create a virtual timer
+ *
+ * @param name - Name for the timer.
+ * @param opt  - Pointer to an ::SceKernelVTimerOptParam (pass NULL)
+ *
+ * @return The VTimer's UID or < 0 on error.
+ */
+SceUID sceKernelCreateVTimer(const char *name, struct SceKernelVTimerOptParam *opt);
+
+/**
+ * Delete a virtual timer
+ *
+ * @param uid - The UID of the timer
+ *
+ * @return < 0 on error.
+ */
+int sceKernelDeleteVTimer(SceUID uid);
+
+/**
+ * Get the timer base
+ *
+ * @param uid - UID of the vtimer
+ * @param base - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelGetVTimerBase(SceUID uid, SceKernelSysClock *base);
+
+/**
+ * Get the timer base (wide format)
+ *
+ * @param uid - UID of the vtimer
+ *
+ * @return The 64bit timer base
+ */
+SceInt64 sceKernelGetVTimerBaseWide(SceUID uid);
+
+/**
+ * Get the timer time
+ *
+ * @param uid - UID of the vtimer
+ * @param time - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelGetVTimerTime(SceUID uid, SceKernelSysClock *time);
+
+/**
+ * Get the timer time (wide format)
+ *
+ * @param uid - UID of the vtimer
+ *
+ * @return The 64bit timer time
+ */
+SceInt64 sceKernelGetVTimerTimeWide(SceUID uid);
+
+/**
+ * Set the timer time
+ *
+ * @param uid - UID of the vtimer
+ * @param time - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSetVTimerTime(SceUID uid, SceKernelSysClock *time);
+
+/**
+ * Set the timer time (wide format)
+ *
+ * @param uid - UID of the vtimer
+ * @param time - Pointer to a ::SceKernelSysClock structure
+ *
+ * @return Possibly the last time
+ */
+SceInt64 sceKernelSetVTimerTimeWide(SceUID uid, SceInt64 time);
+
+/**
+ * Start a virtual timer
+ *
+ * @param uid - The UID of the timer
+ *
+ * @return < 0 on error
+ */
+int sceKernelStartVTimer(SceUID uid);
+
+/**
+ * Stop a virtual timer
+ *
+ * @param uid - The UID of the timer
+ *
+ * @return < 0 on error
+ */
+int sceKernelStopVTimer(SceUID uid);
+
+typedef SceUInt (*SceKernelVTimerHandler)(SceUID uid, SceKernelSysClock *, SceKernelSysClock *, void *);
+typedef SceUInt (*SceKernelVTimerHandlerWide)(SceUID uid, SceInt64, SceInt64, void *);
+
+/**
+ * Set the timer handler
+ *
+ * @param uid - UID of the vtimer
+ * @param time - Time to call the handler?
+ * @param handler - The timer handler
+ * @param common  - Common pointer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSetVTimerHandler(SceUID uid, SceKernelSysClock *time, SceKernelVTimerHandler handler, void *common);
+
+/**
+ * Set the timer handler (wide mode)
+ *
+ * @param uid - UID of the vtimer
+ * @param time - Time to call the handler?
+ * @param handler - The timer handler
+ * @param common  - Common pointer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSetVTimerHandlerWide(SceUID uid, SceInt64 time, SceKernelVTimerHandlerWide handler, void *common);
+
+/**
+ * Cancel the timer handler
+ *
+ * @param uid - The UID of the vtimer
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelCancelVTimerHandler(SceUID uid);
+
+typedef struct SceKernelVTimerInfo {
+	SceSize 	size;
+	char 	name[32];
+	int 	active;
+	SceKernelSysClock 	base;
+	SceKernelSysClock 	current;
+	SceKernelSysClock 	schedule;
+	SceKernelVTimerHandler 	handler;
+	void * 	common;
+} SceKernelVTimerInfo;
+
+/**
+ * Get the status of a VTimer
+ *
+ * @param uid - The uid of the VTimer
+ * @param info - Pointer to a ::SceKernelVTimerInfo structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReferVTimerStatus(SceUID uid, SceKernelVTimerInfo *info);
+
+/**
+ * Exit the thread (probably used as the syscall when the main thread
+ * returns
+ */
+void _sceKernelExitThread(void);
+
+/**
+ * Get the type of a threadman uid
+ *
+ * @param uid - The uid to get the type from
+ * 
+ * @return The type, < 0 on error
+ */
+enum SceKernelIdListType sceKernelGetThreadmanIdType(SceUID uid);
+
+typedef int (*SceKernelThreadEventHandler)(int mask, SceUID thid, void *common);
+
+/** Struct for event handler info */
+typedef struct SceKernelThreadEventHandlerInfo {
+	SceSize 	size;
+	char 	name[32];
+	SceUID 	threadId;
+	int 	mask;
+	SceKernelThreadEventHandler 	handler;
+	void * 	common;
+} SceKernelThreadEventHandlerInfo;
+
+enum ThreadEventIds
+{
+	THREADEVENT_ALL = 0xFFFFFFFF,
+	THREADEVENT_KERN = 0xFFFFFFF8,
+	THREADEVENT_USER = 0xFFFFFFF0,
+	THREADEVENT_CURRENT = 0
+};
+
+enum ThreadEvents
+{
+	THREAD_CREATE = 1,
+	THREAD_START  = 2,
+	THREAD_EXIT   = 4,
+	THREAD_DELETE = 8,
+};
+
+/**
+ * Register a thread event handler
+ *
+ * @param name - Name for the thread event handler
+ * @param threadID - Thread ID to monitor
+ * @param mask - Bit mask for what events to handle (only lowest 4 bits valid)
+ * @param handler - Pointer to a ::SceKernelThreadEventHandler function
+ * @param common - Common pointer
+ *
+ * @return The UID of the create event handler, < 0 on error
+ */
+SceUID sceKernelRegisterThreadEventHandler(const char *name, SceUID threadID, int mask, SceKernelThreadEventHandler handler, void *common);
+
+/**
+ * Release a thread event handler.
+ *
+ * @param uid - The UID of the event handler
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReleaseThreadEventHandler(SceUID uid);
+
+/**
+ * Refer the status of an thread event handler
+ *
+ * @param uid - The UID of the event handler
+ * @param info - Pointer to a ::SceKernelThreadEventHandlerInfo structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelReferThreadEventHandlerStatus(SceUID uid, struct SceKernelThreadEventHandlerInfo *info);
+
+/**
+ * Get the thread profiler registers.
+ * @return Pointer to the registers, NULL on error
+ */
+PspDebugProfilerRegs *sceKernelReferThreadProfiler(void);
+
+/**
+ * Get the globile profiler registers.
+ * @return Pointer to the registers, NULL on error
+ */
+PspDebugProfilerRegs *sceKernelReferGlobalProfiler(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspthreadman_kernel.h b/newlib/psp/include/pspthreadman_kernel.h
new file mode 100644
index 0000000..2047b12
--- /dev/null
+++ b/newlib/psp/include/pspthreadman_kernel.h
@@ -0,0 +1,233 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspthreadman_kernel.h - Interface to the kernel side of threadman
+ *
+ * Copyright (c) 2005 James F.
+ *
+ */
+
+#ifndef PSPTHREADMANKERNEL_H
+#define PSPTHREADMANKERNEL_H
+
+#include <pspkerneltypes.h>
+#include <pspthreadman.h>
+
+/** @defgroup ThreadmanKern Thread Manager kernel functions
+  * This module contains routines to threads in the kernel
+  */
+
+/** @addtogroup ThreadmanKern Thread Manager kernel functions */
+/**@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Suspend all user mode threads in the system
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceKernelSuspendAllUserThreads(void);
+
+/**
+ * Checks if the current thread is a usermode thread
+ *
+ * @return 0 if kernel, 1 if user, < 0 on error
+ */
+int sceKernelIsUserModeThread(void);
+
+/**
+ * Get the user level of the current thread
+ *
+ * @return The user level, < 0 on error
+ */
+int sceKernelGetUserLevel(void);
+
+/**
+ * Get the return address of the current thread's syscall
+ *
+ * @return The RA, 0 on error
+ */
+unsigned int sceKernelGetSyscallRA(void);
+
+/**
+ * Get the free stack space on the kernel thread
+ *
+ * @param thid - The UID of the thread
+ *
+ * @return The free stack space, < 0 on error
+ */
+int sceKernelGetThreadKernelStackFreeSize(SceUID thid);
+
+/**
+ * Check the thread kernel stack
+ *
+ * @return Unknown
+ */
+int sceKernelCheckThreadKernelStack(void);
+
+/**
+ * Extend the kernel thread stack
+ *
+ * @param type - The type of block allocation. One of ::PspSysMemBlockTypes
+ * @param cb - A pointer to a callback function
+ * @param arg - A pointer to a user specified argument
+ *
+ * @return < 0 on error
+ */
+int sceKernelExtendKernelStack(int type, void (*cb)(void*), void *arg);
+
+/**
+ * Get the system status flag
+ *
+ * @return The system status flag
+ */
+unsigned int sceKernelGetSystemStatusFlag(void);
+
+/**
+ * Setup the KTLS allocator
+ *
+ * @param id - The ID of the allocator
+ * @param cb - The allocator callback
+ * @param arg - User specified arg passed to the callback
+ *
+ * @return < 0 on error, allocation id on success
+ */
+int sceKernelAllocateKTLS(int id, int (*cb)(unsigned int *size, void *arg), void *arg);
+
+/**
+ * Free the KTLS allocator
+ *
+ * @param id - The allocation id returned from AllocateKTLS
+ *
+ * @return < 0 on error
+ */
+int sceKernelFreeKTLS(int id);
+
+/**
+ * Get the KTLS of the current thread
+ *
+ * @param id - The allocation id returned from AllocateKTLS
+ * 
+ * @return The current KTLS, NULL on error
+ */
+void *sceKernelGetKTLS(int id);
+
+/**
+ * Get the KTLS of a thread
+ *
+ * @param id - The allocation id returned from AllocateKTLS
+ * @param thid - The thread is, 0 for current thread
+ * @param mode - Perhaps? Sees to be set to 0 or 1
+ *
+ * @return The current KTLS, NULL on error
+ */
+void *sceKernelGetThreadKTLS(int id, SceUID thid, int mode);
+
+/** Thread context
+ * Structues for the thread context taken from florinsasu's post on the forums */
+struct SceThreadContext {
+	unsigned int   type;
+	unsigned int   gpr[31];
+	unsigned int   fpr[32];
+	unsigned int   fc31;
+	unsigned int   hi; 
+	unsigned int   lo;
+	unsigned int   SR;
+	unsigned int   EPC;
+	unsigned int   field_114;
+	unsigned int   field_118;
+}; 
+
+struct SceSCContext
+{
+	unsigned int status;
+	unsigned int epc;
+	unsigned int sp;
+	unsigned int ra;
+	unsigned int k1;
+	unsigned int unk[3];
+};
+
+/** Structure to hold the status information for a thread (kernel form)
+ * 1.5 form
+  */
+typedef struct SceKernelThreadKInfo {
+	/** Size of the structure */
+	SceSize     size;
+	/** Nul terminated name of the thread */
+	char    	name[32];
+	/** Thread attributes */
+	SceUInt     attr;
+	/** Thread status */
+	int     	status;
+	/** Thread entry point */
+	SceKernelThreadEntry    entry;
+	/** Thread stack pointer */
+	void *  	stack;
+	/** Thread stack size */
+	int     	stackSize;
+	/** Kernel stack pointer */
+	void *		kstack;
+	/** Kernel stack size */
+	void *		kstackSize;
+	/** Pointer to the gp */
+	void *  	gpReg;
+	/** Size of args */
+	SceSize     args;
+	/** Pointer to args */
+	void *      argp;
+	/** Initial priority */
+	int     	initPriority;
+	/** Current priority */
+	int     	currentPriority;
+	/** Wait type */
+	int     	waitType;
+	/** Wait id */
+	SceUID  	waitId;
+	/** Wakeup count */
+	int     	wakeupCount;
+	/** Number of clock cycles run */
+	SceKernelSysClock   runClocks;
+#if _PSP_FW_VERSION >= 200
+	SceUInt unk3; /* Unknown extra field on later firmwares */
+#endif
+	/** Interrupt preemption count */
+	SceUInt     intrPreemptCount;
+	/** Thread preemption count */
+	SceUInt     threadPreemptCount;
+	/** Release count */
+	SceUInt     releaseCount;
+	/** Thread Context */
+	struct SceThreadContext *thContext;
+	/** VFPU Context */
+	float *      vfpuContext;
+	/** Return address from syscall */
+	void  *      retAddr;
+	/** Unknown, possibly size of SC context */
+	SceUInt      unknown1;
+	/** Syscall Context */
+	struct SceSCContext *scContext;
+} SceKernelThreadKInfo;
+
+/**
+ * Refer kernel version of thread information
+ *
+ * @param uid - UID to find
+ * @param info - Pointer to info structure, ensure size is set before calling
+ *
+ * @return 0 on success
+ */
+int ThreadManForKernel_2D69D086(SceUID uid, SceKernelThreadKInfo *info);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**@}*/
+
+#endif /* PSPTHREADMANKERNEL_H */
diff --git a/newlib/psp/include/psptypes.h b/newlib/psp/include/psptypes.h
new file mode 100644
index 0000000..fb93b8e
--- /dev/null
+++ b/newlib/psp/include/psptypes.h
@@ -0,0 +1,433 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psptypes.h - Commonly used typedefs.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+/* Note: Some of the structures, types, and definitions in this file were
+   extrapolated from symbolic debugging information found in the Japanese
+   version of Puzzle Bobble. */
+
+#ifndef _PSPTYPES_H_
+#define _PSPTYPES_H_ 1
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL	0
+#else
+#define NULL	((void *) 0)
+#endif /* __cplusplus */
+#endif
+
+/* Legacy ps2dev types. */
+#ifndef PSP_LEGACY_TYPES_DEFINED
+#define PSP_LEGACY_TYPES_DEFINED
+typedef	uint8_t				u8;
+typedef uint16_t			u16;
+
+typedef uint32_t			u32;
+typedef uint64_t			u64;
+
+typedef int8_t				s8;
+typedef int16_t				s16;
+
+typedef int32_t				s32;
+typedef int64_t				s64;
+#endif
+
+#ifndef PSP_LEGACY_VOLATILE_TYPES_DEFINED
+#define PSP_LEGACY_VOLATILE_TYPES_DEFINED
+typedef	volatile uint8_t		vu8;
+typedef volatile uint16_t		vu16;
+
+typedef volatile uint32_t		vu32;
+typedef volatile uint64_t		vu64;
+
+typedef volatile int8_t			vs8;
+typedef volatile int16_t		vs16;
+
+typedef volatile int32_t		vs32;
+typedef volatile int64_t		vs64;
+#endif
+
+/* MIPS-like accessor macros. */
+static __inline__ u8  _lb(u32 addr) { return *(vu8 *)addr; }
+static __inline__ u16 _lh(u32 addr) { return *(vu16 *)addr; }
+static __inline__ u32 _lw(u32 addr) { return *(vu32 *)addr; }
+static __inline__ u64 _ld(u32 addr) { return *(vu64 *)addr; }
+
+static __inline__ void _sb(u8 val, u32 addr) { *(vu8 *)addr = val; }
+static __inline__ void _sh(u16 val, u32 addr) { *(vu16 *)addr = val; }
+static __inline__ void _sw(u32 val, u32 addr) { *(vu32 *)addr = val; }
+static __inline__ void _sd(u64 val, u32 addr) { *(vu64 *)addr = val; }
+
+/* SCE types. */
+typedef unsigned char SceUChar8;
+typedef uint16_t SceUShort16;
+typedef uint32_t SceUInt32;
+typedef uint64_t SceUInt64;
+typedef uint64_t SceULong64;
+/*typedef unsigned int SceULong128 __attribute__((mode(TI)));*/
+
+typedef char SceChar8;
+typedef int16_t SceShort16;
+typedef int32_t SceInt32;
+typedef int64_t SceInt64;
+typedef int64_t SceLong64;
+/*typedef int SceLong128 __attribute__((mode(TI)));*/
+
+typedef float SceFloat;
+typedef float SceFloat32;
+
+typedef short unsigned int SceWChar16;
+typedef unsigned int SceWChar32;
+
+typedef int SceBool;
+
+typedef void SceVoid;
+typedef void * ScePVoid;
+
+
+/* PSP types. */
+
+/* Rectangles. */
+typedef struct ScePspSRect {
+	short int 	x;
+	short int 	y;
+	short int 	w;
+	short int 	h;
+} ScePspSRect;
+
+typedef struct ScePspIRect {
+	int 	x;
+	int 	y;
+	int 	w;
+	int 	h;
+} ScePspIRect;
+
+typedef struct ScePspL64Rect {
+	SceLong64 	x;
+	SceLong64 	y;
+	SceLong64 	w;
+	SceLong64 	h;
+} ScePspL64Rect;
+
+typedef struct ScePspFRect {
+	float 	x;
+	float 	y;
+	float 	w;
+	float 	h;
+} ScePspFRect;
+
+/* 2D vectors. */
+typedef struct ScePspSVector2 {
+	short int 	x;
+	short int 	y;
+} ScePspSVector2;
+
+typedef struct ScePspIVector2 {
+	int 	x;
+	int 	y;
+} ScePspIVector2;
+
+typedef struct ScePspL64Vector2 {
+	SceLong64 	x;
+	SceLong64 	y;
+} ScePspL64Vector2;
+
+typedef struct ScePspFVector2 {
+	float 	x;
+	float 	y;
+} ScePspFVector2;
+
+typedef union ScePspVector2 {
+	ScePspFVector2 	fv;
+	ScePspIVector2 	iv;
+	float 			f[2];
+	int 			i[2];
+} ScePspVector2;
+
+/* 3D vectors. */
+typedef struct ScePspSVector3 {
+	short int 	x;
+	short int 	y;
+	short int 	z;
+} ScePspSVector3;
+
+typedef struct ScePspIVector3 {
+	int 	x;
+	int 	y;
+	int 	z;
+} ScePspIVector3;
+
+typedef struct ScePspL64Vector3 {
+	SceLong64 	x;
+	SceLong64 	y;
+	SceLong64 	z;
+} ScePspL64Vector3;
+
+typedef struct ScePspFVector3 {
+	float 	x;
+	float 	y;
+	float 	z;
+} ScePspFVector3;
+
+typedef union ScePspVector3 {
+	ScePspFVector3 	fv;
+	ScePspIVector3 	iv;
+	float 			f[3];
+	int 			i[3];
+} ScePspVector3;
+
+/* 4D vectors. */
+typedef struct ScePspSVector4 {
+	short int 	x;
+	short int 	y;
+	short int 	z;
+	short int 	w;
+} ScePspSVector4;
+
+typedef struct ScePspIVector4 {
+	int 	x;
+	int 	y;
+	int 	z;
+	int 	w;
+} ScePspIVector4;
+
+typedef struct ScePspL64Vector4 {
+	SceLong64 	x;
+	SceLong64 	y;
+	SceLong64 	z;
+	SceLong64 	w;
+} ScePspL64Vector4;
+
+typedef struct ScePspFVector4 {
+	float 	x;
+	float 	y;
+	float 	z;
+	float 	w;
+} ScePspFVector4 __attribute__((aligned(16)));
+
+typedef struct ScePspFVector4Unaligned {
+	float 	x;
+	float 	y;
+	float 	z;
+	float 	w;
+} ScePspFVector4Unaligned;
+
+typedef union ScePspVector4 {
+	ScePspFVector4 	fv;
+	ScePspIVector4 	iv;
+/*	SceULong128 	qw;*/	/* Missing compiler support. */
+	float 			f[4];
+	int 			i[4];
+} ScePspVector4 __attribute__((aligned(16)));
+
+/* 2D matrix types. */
+typedef struct ScePspIMatrix2 {
+	ScePspIVector2 	x;
+	ScePspIVector2 	y;
+} ScePspIMatrix2;
+
+typedef struct ScePspFMatrix2 {
+	ScePspFVector2 	x;
+	ScePspFVector2 	y;
+} ScePspFMatrix2;
+
+typedef union ScePspMatrix2 {
+	ScePspFMatrix2 	fm;
+	ScePspIMatrix2 	im;
+	ScePspFVector2 	fv[2];
+	ScePspIVector2 	iv[2];
+	ScePspVector2 	v[2];
+/*	SceULong128 	qw[2];*/	/* Missing compiler support. */
+	float 			f[2][2];
+	int 			i[2][2];
+} ScePspMatrix2;
+
+/* 3D matrix types. */
+typedef struct ScePspIMatrix3 {
+	ScePspIVector3 	x;
+	ScePspIVector3 	y;
+	ScePspIVector3 	z;
+} ScePspIMatrix3;
+
+typedef struct ScePspFMatrix3 {
+	ScePspFVector3 	x;
+	ScePspFVector3 	y;
+	ScePspFVector3 	z;
+} ScePspFMatrix3;
+
+typedef union ScePspMatrix3 {
+	ScePspFMatrix3 	fm;
+	ScePspIMatrix3 	im;
+	ScePspFVector3 	fv[3];
+	ScePspIVector3 	iv[3];
+	ScePspVector3 	v[3];
+/*	SceULong128 	qw[3];*/	/* Missing compiler support. */
+	float 			f[3][3];
+	int 			i[3][3];
+} ScePspMatrix3;
+
+/* 4D matrix types. */
+typedef struct ScePspIMatrix4 {
+	ScePspIVector4 	x;
+	ScePspIVector4 	y;
+	ScePspIVector4 	z;
+	ScePspIVector4 	w;
+} ScePspIMatrix4 __attribute__((aligned(16)));
+
+typedef struct ScePspIMatrix4Unaligned {
+	ScePspIVector4 	x;
+	ScePspIVector4 	y;
+	ScePspIVector4 	z;
+	ScePspIVector4 	w;
+} ScePspIMatrix4Unaligned;
+
+typedef struct ScePspFMatrix4 {
+	ScePspFVector4 	x;
+	ScePspFVector4 	y;
+	ScePspFVector4 	z;
+	ScePspFVector4 	w;
+} ScePspFMatrix4 __attribute__((aligned(16)));
+
+typedef struct ScePspFMatrix4Unaligned {
+	ScePspFVector4 	x;
+	ScePspFVector4 	y;
+	ScePspFVector4 	z;
+	ScePspFVector4 	w;
+} ScePspFMatrix4Unaligned;
+
+typedef union ScePspMatrix4 {
+	ScePspFMatrix4 	fm;
+	ScePspIMatrix4 	im;
+	ScePspFVector4 	fv[4];
+	ScePspIVector4 	iv[4];
+	ScePspVector4 	v[4];
+/*	SceULong128 	qw[4];*/	/* Missing compiler support. */
+	float 			f[4][4];
+	int 			i[4][4];
+} ScePspMatrix4;
+
+/* Quaternions. */
+typedef struct ScePspFQuaternion {
+	float 	x;
+	float 	y;
+	float 	z;
+	float 	w;
+} ScePspFQuaternion __attribute__((aligned(16)));
+
+typedef struct ScePspFQuaternionUnaligned {
+	float 	x;
+	float 	y;
+	float 	z;
+	float 	w;
+} ScePspFQuaternionUnaligned;
+
+/* Colors and pixel formats. */
+typedef struct ScePspFColor {
+	float 	r;
+	float 	g;
+	float 	b;
+	float 	a;
+} ScePspFColor __attribute__((aligned(16)));
+
+typedef struct ScePspFColorUnaligned {
+	float 	r;
+	float 	g;
+	float 	b;
+	float 	a;
+} ScePspFColorUnaligned;
+
+typedef unsigned int ScePspRGBA8888;
+typedef unsigned short ScePspRGBA4444;
+typedef unsigned short ScePspRGBA5551;
+typedef unsigned short ScePspRGB565;
+
+/* Unions for converting between types. */
+typedef union ScePspUnion32 {
+	unsigned int 	ui;
+	int 			i;
+	unsigned short 	us[2];
+	short int 		s[2];
+	unsigned char 	uc[4];
+	char 			c[4];
+	float 			f;
+	ScePspRGBA8888 	rgba8888;
+	ScePspRGBA4444 	rgba4444[2];
+	ScePspRGBA5551 	rgba5551[2];
+	ScePspRGB565 	rgb565[2];
+} ScePspUnion32;
+
+typedef union ScePspUnion64 {
+	SceULong64 		ul;
+	SceLong64 		l;
+	unsigned int 	ui[2];
+	int 			i[2];
+	unsigned short 	us[4];
+	short int 		s[4];
+	unsigned char 	uc[8];
+	char 			c[8];
+	float 			f[2];
+	ScePspSRect 	sr;
+	ScePspSVector4 	sv;
+	ScePspRGBA8888 	rgba8888[2];
+	ScePspRGBA4444 	rgba4444[4];
+	ScePspRGBA5551 	rgba5551[4];
+	ScePspRGB565 	rgb565[4];
+} ScePspUnion64;
+
+typedef union ScePspUnion128 {
+/*	SceULong128 	qw;*/	/* Missing compiler support. */
+/*	SceULong128 	uq;*/
+/*	SceLong128 	q;*/
+	SceULong64		ul[2];
+	SceLong64		l[2];
+	unsigned int 	ui[4];
+	int 			i[4];
+	unsigned short 	us[8];
+	short int 		s[8];
+	unsigned char 	uc[16];
+	char 			c[16];
+	float 			f[4];
+	ScePspFRect 	fr;
+	ScePspIRect 	ir;
+	ScePspFVector4 	fv;
+	ScePspIVector4 	iv;
+	ScePspFQuaternion fq;
+	ScePspFColor 	fc;
+	ScePspRGBA8888 	rgba8888[4];
+	ScePspRGBA4444 	rgba4444[8];
+	ScePspRGBA5551 	rgba5551[8];
+	ScePspRGB565 	rgb565[8];
+} ScePspUnion128 __attribute__((aligned(16)));
+
+/* Date and time. */
+typedef struct ScePspDateTime {
+	unsigned short	year;
+	unsigned short 	month;
+	unsigned short 	day;
+	unsigned short 	hour;
+	unsigned short 	minute;
+	unsigned short 	second;
+	unsigned int 	microsecond;
+} ScePspDateTime;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PSPTYPES_H_ */
diff --git a/newlib/psp/include/pspumd.h b/newlib/psp/include/pspumd.h
new file mode 100644
index 0000000..e64e32c
--- /dev/null
+++ b/newlib/psp/include/pspumd.h
@@ -0,0 +1,215 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspumd.h - Prototypes for the sceUmd library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __UMD_H__
+#define __UMD_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup UMD UMD Kernel Library */
+/**@{*/
+
+/** UMD Info struct */
+typedef struct pspUmdInfo
+{
+	/** Set to sizeof(pspUmdInfo) */
+	unsigned int size;
+	/** One or more of ::pspUmdTypes */
+	unsigned int type;
+	
+} pspUmdInfo;
+
+/** Enumeration for UMD types */
+enum pspUmdTypes
+{
+	PSP_UMD_TYPE_GAME =		0x10,
+	PSP_UMD_TYPE_VIDEO =	0x20,
+	PSP_UMD_TYPE_AUDIO =	0x40
+};
+
+/** Enumeration for UMD drive state */
+enum pspUmdState
+{
+	PSP_UMD_NOT_PRESENT =	0x01,
+	PSP_UMD_PRESENT =		0x02,
+	PSP_UMD_CHANGED =		0x04,
+	PSP_UMD_INITING =		0x08,
+	PSP_UMD_INITED =		0x10,
+	PSP_UMD_READY =			0x20
+};
+
+/** Enumeration for UMD stats (legacy) */
+enum UmdDriveStat
+{
+	/** Wait for disc to be inserted */
+	UMD_WAITFORDISC = PSP_UMD_PRESENT,
+	/** Wait for the UMD to be initialised so it can be accessed from the mapped drive */
+	UMD_WAITFORINIT	= PSP_UMD_READY
+};
+
+/** UMD Callback function */
+typedef int (*UmdCallback)(int unknown, int event);
+
+/** 
+  * Check whether there is a disc in the UMD drive
+  *
+  * @return 0 if no disc present, anything else indicates a disc is inserted.
+  */
+int sceUmdCheckMedium(void);
+
+/** 
+  * Get the disc info
+  *
+  * @param info - A pointer to a ::pspUmdInfo struct
+  *
+  * @return < 0 on error
+  */
+int sceUmdGetDiscInfo(pspUmdInfo *info);
+
+/** 
+  * Activates the UMD drive
+  * 
+  * @param unit - The unit to initialise (probably). Should be set to 1.
+  *
+  * @param drive - A prefix string for the fs device to mount the UMD on (e.g. "disc0:")
+  *
+  * @return < 0 on error
+  *
+  * @par Example:
+  * @code
+  * // Wait for disc and mount to filesystem
+  * int i;
+  * i = sceUmdCheckMedium();
+  * if(i == 0)
+  * {
+  *    sceUmdWaitDriveStat(PSP_UMD_PRESENT);
+  * }
+  * sceUmdActivate(1, "disc0:"); // Mount UMD to disc0: file system
+  * sceUmdWaitDriveStat(PSP_UMD_READY);
+  * // Now you can access the UMD using standard sceIo functions
+  * @endcode
+  */
+int sceUmdActivate(int unit, const char *drive);
+
+/** 
+  * Deativates the UMD drive
+  * 
+  * @param unit - The unit to initialise (probably). Should be set to 1.
+  *
+  * @param drive - A prefix string for the fs device to mount the UMD on (e.g. "disc0:")
+  *
+  * @return < 0 on error
+  */
+int sceUmdDeactivate(int unit, const char *drive);
+
+/** 
+  * Wait for the UMD drive to reach a certain state
+  *
+  * @param stat - One or more of ::pspUmdState
+  *
+  * @return < 0 on error
+  */
+int sceUmdWaitDriveStat(int stat);
+
+/** 
+  * Wait for the UMD drive to reach a certain state
+  *
+  * @param stat - One or more of ::pspUmdState
+  *
+  * @param timeout - Timeout value in microseconds
+  *
+  * @return < 0 on error
+  */
+int sceUmdWaitDriveStatWithTimer(int stat, unsigned int timeout);
+
+/** 
+  * Wait for the UMD drive to reach a certain state (plus callback)
+  *
+  * @param stat - One or more of ::pspUmdState
+  *
+  * @param timeout - Timeout value in microseconds
+  *
+  * @return < 0 on error
+  */
+int sceUmdWaitDriveStatCB(int stat, unsigned int timeout);
+
+/** 
+  * Cancel a sceUmdWait* call
+  *
+  * @return < 0 on error
+  */
+int sceUmdCancelWaitDriveStat(void);
+
+/** 
+  * Get (poll) the current state of the UMD drive
+  *
+  * @return < 0 on error, one or more of ::pspUmdState on success
+  */
+int sceUmdGetDriveStat(void);
+
+/** 
+  * Get the error code associated with a failed event
+  *
+  * @return < 0 on error, the error code on success
+  */
+int sceUmdGetErrorStat(void);
+
+/** 
+  * Register a callback for the UMD drive
+  * @note Callback is of type UmdCallback
+  *
+  * @param cbid - A callback ID created from sceKernelCreateCallback
+  * @return < 0 on error
+  * @par Example:
+  * @code
+  * int umd_callback(int unknown, int event)
+  * {
+  *      //do something
+  * }     
+  * int cbid = sceKernelCreateCallback("UMD Callback", umd_callback, NULL);
+  * sceUmdRegisterUMDCallBack(cbid);
+  * @endcode
+  */
+int sceUmdRegisterUMDCallBack(int cbid);
+
+/** 
+  * Un-register a callback for the UMD drive
+  *
+  * @param cbid - A callback ID created from sceKernelCreateCallback
+  *
+  * @return < 0 on error
+  */
+int sceUmdUnRegisterUMDCallBack(int cbid);
+
+/** 
+  * Permit UMD disc being replaced
+  *
+  * @return < 0 on error
+  */
+int sceUmdReplacePermit(void);
+
+/** 
+  * Prohibit UMD disc being replaced
+  *
+  * @return < 0 on error
+  */
+int sceUmdReplaceProhibit(void);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspusb.h b/newlib/psp/include/pspusb.h
new file mode 100644
index 0000000..45cbfa6
--- /dev/null
+++ b/newlib/psp/include/pspusb.h
@@ -0,0 +1,91 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspusb.h - Prototypes for the sceUsb library
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUSB_H__
+#define __PSPUSB_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_USBBUS_DRIVERNAME "USBBusDriver"
+
+//Defines for use with status function return values
+#define PSP_USB_ACTIVATED              0x200
+#define PSP_USB_CABLE_CONNECTED        0x020 
+#define PSP_USB_CONNECTION_ESTABLISHED 0x002
+
+/**
+  * Start a USB driver.
+  * 
+  * @param driverName - name of the USB driver to start
+  * @param size - Size of arguments to pass to USB driver start
+  * @param args - Arguments to pass to USB driver start
+  *
+  * @return 0 on success
+  */
+int sceUsbStart(const char* driverName, int size, void *args);
+
+/**
+  * Stop a USB driver.
+  * 
+  * @param driverName - name of the USB driver to stop
+  * @param size - Size of arguments to pass to USB driver stop
+  * @param args - Arguments to pass to USB driver stop
+  *
+  * @return 0 on success
+  */
+int sceUsbStop(const char* driverName, int size, void *args);
+
+/**
+  * Activate a USB driver.
+  * 
+  * @param pid - Product ID for the default USB Driver
+  *
+  * @return 0 on success
+  */
+int sceUsbActivate(u32 pid);
+
+/**
+  * Deactivate USB driver.
+  *
+  * @param pid - Product ID for the default USB driver
+  * 
+  * @return 0 on success
+  */
+int sceUsbDeactivate(u32 pid);
+
+/**
+  * Get USB state
+  * 
+  * @return OR'd PSP_USB_* constants
+  */
+int sceUsbGetState(void);
+
+/**
+  * Get state of a specific USB driver
+  * 
+  * @param driverName - name of USB driver to get status from
+  *
+  * @return 1 if the driver has been started, 2 if it is stopped
+  */
+int sceUsbGetDrvState(const char* driverName);
+
+#if 0
+int sceUsbGetDrvList(u32 r4one, u32* r5ret, u32 r6one);
+int sceUsbWaitState(u32 state, s32 waitmode, u32 *timeout);
+int sceUsbWaitCancel(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspusbacc.h b/newlib/psp/include/pspusbacc.h
new file mode 100644
index 0000000..29a7a5b
--- /dev/null
+++ b/newlib/psp/include/pspusbacc.h
@@ -0,0 +1,25 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspusbacc.h - Prototypes for the sceUsbAcc library
+ *
+ * Copyright (c) 2007 dot_blank
+ *
+ */
+#ifndef __PSPUSBACC_H__
+#define __PSPUSBACC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_USBACC_DRIVERNAME	"USBAccBaseDriver"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
+
diff --git a/newlib/psp/include/pspusbbus.h b/newlib/psp/include/pspusbbus.h
new file mode 100644
index 0000000..533ac92
--- /dev/null
+++ b/newlib/psp/include/pspusbbus.h
@@ -0,0 +1,307 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspusbbus.h - Prototypes for the sceUsbBus_driver library
+ *
+ * Copyright (c) 2006 James F 
+ *
+ */
+#ifndef __PSPUSBBUS_H__
+#define __PSPUSBBUS_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** USB driver interface */
+struct UsbInterface
+{
+	/** Expectant interface (0 or -1) */
+	int expect_interface;
+	/** Unknown */
+	int unk8;
+	/** Number of interfaces */
+	int num_interface;
+};
+
+/** USB driver endpoint */
+struct UsbEndpoint
+{
+	/** Endpoint number (must be filled in sequentially) */
+	int endpnum; 
+	/** Filled in by the bus driver */
+	int unk2; 
+	/** Filled in by the bus driver */
+	int unk3;
+};
+
+/** USB string descriptor */
+struct StringDescriptor
+{
+	unsigned char bLength;
+	unsigned char bDescriptorType;
+	short bString[32];
+} __attribute__((packed));
+
+/** USB device descriptor */
+struct DeviceDescriptor
+{
+	unsigned char bLength;
+	unsigned char bDescriptorType;
+	unsigned short bcdUSB;
+	unsigned char bDeviceClass;
+	unsigned char bDeviceSubClass;
+	unsigned char bDeviceProtocol;
+	unsigned char bMaxPacketSize;
+	unsigned short idVendor;
+	unsigned short idProduct;
+	unsigned short bcdDevice;
+	unsigned char iManufacturer;
+	unsigned char iProduct;
+	unsigned char iSerialNumber;
+	unsigned char bNumConfigurations;
+} __attribute__((packed));
+
+/** USB configuration descriptor */
+struct ConfigDescriptor
+{
+	unsigned char bLength;
+	unsigned char bDescriptorType;
+	unsigned short wTotalLength;
+	unsigned char bNumInterfaces;
+	unsigned char bConfigurationValue;
+	unsigned char iConfiguration;
+	unsigned char bmAttributes; 
+	unsigned char bMaxPower; 
+} __attribute__((packed));
+
+/** USB Interface descriptor */
+struct InterfaceDescriptor
+{
+	unsigned char bLength;
+	unsigned char bDescriptorType;
+	unsigned char bInterfaceNumber;
+	unsigned char bAlternateSetting;
+	unsigned char bNumEndpoints;
+	unsigned char bInterfaceClass;
+	unsigned char bInterfaceSubClass;
+	unsigned char bInterfaceProtocol;
+	unsigned char iInterface;
+} __attribute__((packed));
+
+/** USB endpoint descriptor */
+struct EndpointDescriptor
+{
+	unsigned char bLength;
+	unsigned char bDescriptorType;
+	unsigned char bEndpointAddress;
+	unsigned char bmAttributes;
+	unsigned short wMaxPacketSize; 
+	unsigned char bInterval;
+} __attribute__((packed));
+
+/** USB driver interfaces structure */
+struct UsbInterfaces
+{
+	/** Pointers to the individual interface descriptors */
+	struct InterfaceDescriptor *infp[2];
+	/** Number of interface descriptors */
+	unsigned int num;
+};
+
+/** USB driver configuration */
+struct UsbConfiguration
+{
+	/** Pointer to the configuration descriptors */
+	struct ConfigDescriptor *confp;
+	/** USB driver interfaces pointer */
+	struct UsbInterfaces *infs;
+	/** Pointer to the first interface descriptor */
+	struct InterfaceDescriptor *infp;
+	/** Pointer to the first endpoint descriptor (each should be 16byte aligned) */
+	struct EndpointDescriptor *endp;
+};
+
+/** Padded data structure, padding is required otherwise the USB hardware crashes */
+struct UsbData
+{
+	unsigned char devdesc[20];
+
+	struct Config
+	{
+		void *pconfdesc;
+		void *pinterfaces;
+		void *pinterdesc;
+		void *pendp;
+	} config;
+	
+	struct ConfDesc
+	{
+		unsigned char desc[12];
+		void *pinterfaces;
+	} confdesc;
+
+	unsigned char pad1[8];
+	struct Interfaces
+	{
+		void *pinterdesc[2];
+		unsigned int intcount;
+	} interfaces;
+
+	struct InterDesc
+	{
+		unsigned char desc[12];
+		void *pendp;
+		unsigned char pad[32];
+	} interdesc;
+
+	struct Endp
+	{
+		unsigned char desc[16];
+	} endp[4];
+} __attribute__((packed));
+
+/** USB EP0 Device Request */
+struct DeviceRequest
+{
+	unsigned char bmRequestType;
+	unsigned char bRequest;
+	unsigned short wValue;
+	unsigned short wIndex;
+	unsigned short wLength;
+} __attribute__((packed));
+
+/** USB driver structure used by ::sceUsbbdRegister and ::sceUsbbdUnregister */
+struct UsbDriver
+{
+	/** Name of the USB driver */
+	const char *name; 
+	/** Number of endpoints in this driver (including default control) */
+	int endpoints;
+	/** List of endpoint structures (used when calling other functions) */
+	struct UsbEndpoint *endp; 
+	/** Interface list */
+	struct UsbInterface *intp;	  
+	/** Pointer to hi-speed device descriptor */
+	void *devp_hi;  
+	/** Pointer to hi-speed device configuration */
+	void *confp_hi;	
+	/** Pointer to full-speed device descriptor */
+	void *devp;     
+	/** Pointer to full-speed device configuration */
+	void *confp;    
+	/** Default String descriptor */
+	struct StringDescriptor *str; 
+	/** Received a control request arg0 is endpoint, arg1 is possibly data arg2 is data buffer */
+	int (*recvctl)(int arg1, int arg2, struct DeviceRequest *req);
+	/** Unknown */
+	int (*func28)(int arg1, int arg2, int arg3);  
+	/** Configuration set (attach) function */
+	int (*attach)(int speed, void *arg2, void *arg3); 
+	/** Configuration unset (detach) function */
+	int (*detach)(int arg1, int arg2, int arg3);
+	/** Unknown set to 0 */
+	int unk34;
+	/** Function called when the driver is started */
+	int (*start_func)(int size, void *args);
+	/** Function called when the driver is stopped */
+	int (*stop_func)(int size, void *args);  
+	/** Link to next USB driver in the chain, set to NULL */
+	struct UsbDriver *link; 
+};
+
+/** USB device request, used by ::sceUsbbdReqSend and ::sceUsbbdReqRecv. */
+struct UsbdDeviceReq
+{
+	/** Pointer to the endpoint to queue request on */
+	struct UsbEndpoint *endp; 
+	/** Pointer to the data buffer to use in the request */
+	void *data;
+	/** Size of the data buffer (send == size of data, recv == size of max receive) */
+	int  size; 
+	/** Unknown */
+	int  unkc; 
+	/** Pointer to the function to call on completion */
+	void *func;
+	/** Resultant size (send == size of data sent, recv == size of data received) */
+	int  recvsize;
+	/** Return code of the request, 0 == success, -3 == cancelled */
+	int  retcode; 
+	/** Unknown */
+	int  unk1c;
+	/** A user specified pointer for the device request */
+	void *arg;
+	/** Link pointer to next request used by the driver, set it to NULL */
+	void *link;
+};
+
+/**
+ * Register a USB driver.
+ *
+ * @param drv - Pointer to a filled out USB driver
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdRegister(struct UsbDriver *drv);
+
+/**
+ * Unregister a USB driver
+ *
+ * @param drv - Pointer to a filled out USB driver
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdUnregister(struct UsbDriver *drv);
+
+/**
+ * Clear the FIFO on an endpoint
+ *
+ * @param endp - The endpoint to clear
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdClearFIFO(struct UsbEndpoint *endp);
+
+/**
+ * Cancel any pending requests on an endpoint.
+ *
+ * @param endp - The endpoint to cancel
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdReqCancelAll(struct UsbEndpoint *endp);
+
+/**
+ * Stall an endpoint
+ *
+ * @param endp - The endpoint to stall
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdStall(struct UsbEndpoint *endp);
+
+/**
+ * Queue a send request (IN from host pov)
+ *
+ * @param req - Pointer to a filled out UsbdDeviceReq structure.
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdReqSend(struct UsbdDeviceReq *req);
+
+/**
+ * Queue a receive request (OUT from host pov)
+ *
+ * @param req - Pointer to a filled out UsbdDeviceReq structure
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUsbbdReqRecv(struct UsbdDeviceReq *req);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspusbcam.h b/newlib/psp/include/pspusbcam.h
new file mode 100644
index 0000000..c834ce8
--- /dev/null
+++ b/newlib/psp/include/pspusbcam.h
@@ -0,0 +1,575 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspusbcam.h - Prototypes for the sceUsbCam library
+ *
+ * Copyright (c) 2007 dot_blank
+ *
+ */
+#ifndef __PSPUSBCAM_H__
+#define __PSPUSBCAM_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_USBCAM_PID				    (0x282)
+#define PSP_USBCAM_DRIVERNAME		  "USBCamDriver"
+#define PSP_USBCAMMIC_DRIVERNAME	"USBCamMicDriver"
+
+/** Resolutions for sceUsbCamSetupStill & 
+                    sceUsbCamSetupVideo
+ ** DO NOT use on sceUsbCamSetupStillEx & sceUsbCamSetupVideoEx */
+enum PspUsbCamResolution
+{
+	PSP_USBCAM_RESOLUTION_160_120  = 0,
+	PSP_USBCAM_RESOLUTION_176_144  = 1,
+	PSP_USBCAM_RESOLUTION_320_240  = 2,
+	PSP_USBCAM_RESOLUTION_352_288  = 3,
+	PSP_USBCAM_RESOLUTION_640_480  = 4,
+	PSP_USBCAM_RESOLUTION_1024_768 = 5,
+	PSP_USBCAM_RESOLUTION_1280_960 = 6,
+	PSP_USBCAM_RESOLUTION_480_272  = 7,
+	PSP_USBCAM_RESOLUTION_360_272  = 8,
+};
+
+/** Resolutions for sceUsbCamSetupStillEx & 
+                    sceUsbCamSetupVideoEx
+ ** DO NOT use on sceUsbCamSetupStill & sceUsbCamSetupVideo */
+enum PspUsbCamResolutionEx
+{
+	PSP_USBCAM_RESOLUTION_EX_160_120  = 0,
+	PSP_USBCAM_RESOLUTION_EX_176_144  = 1,
+	PSP_USBCAM_RESOLUTION_EX_320_240  = 2,
+	PSP_USBCAM_RESOLUTION_EX_352_288  = 3,
+	PSP_USBCAM_RESOLUTION_EX_360_272  = 4,
+	PSP_USBCAM_RESOLUTION_EX_480_272  = 5,
+	PSP_USBCAM_RESOLUTION_EX_640_480  = 6,
+	PSP_USBCAM_RESOLUTION_EX_1024_768 = 7,
+	PSP_USBCAM_RESOLUTION_EX_1280_960 = 8,
+};
+
+/** Flags for reverse effects. */
+enum PspUsbCamReverseFlags
+{
+	PSP_USBCAM_FLIP = 1,
+	PSP_USBCAM_MIRROR = 0x100,
+};
+
+/** Delay to take pictures */
+enum PspUsbCamDelay
+{
+	PSP_USBCAM_NODELAY = 0,
+	PSP_USBCAM_DELAY_10SEC = 1,
+	PSP_USBCAM_DELAY_20SEC = 2,
+	PSP_USBCAM_DELAY_30SEC = 3,
+};
+
+/** Usbcam framerates */
+enum PspUsbCamFrameRate
+{
+	PSP_USBCAM_FRAMERATE_3_75_FPS = 0, /* 3.75 fps */
+	PSP_USBCAM_FRAMERATE_5_FPS = 1, 
+	PSP_USBCAM_FRAMERATE_7_5_FPS = 2, /* 7.5 fps */
+	PSP_USBCAM_FRAMERATE_10_FPS = 3, 
+	PSP_USBCAM_FRAMERATE_15_FPS = 4, 
+	PSP_USBCAM_FRAMERATE_20_FPS = 5, 
+	PSP_USBCAM_FRAMERATE_30_FPS = 6,
+	PSP_USBCAM_FRAMERATE_60_FPS = 7,
+};
+
+/** White balance values */
+enum PspUsbCamWB
+{
+	PSP_USBCAM_WB_AUTO = 0,
+	PSP_USBCAM_WB_DAYLIGHT = 1,
+	PSP_USBCAM_WB_FLUORESCENT = 2,
+	PSP_USBCAM_WB_INCADESCENT = 3,
+};
+
+/** Effect modes */
+enum PspUsbCamEffectMode
+{
+	PSP_USBCAM_EFFECTMODE_NORMAL = 0,
+	PSP_USBCAM_EFFECTMODE_NEGATIVE = 1,
+	PSP_USBCAM_EFFECTMODE_BLACKWHITE = 2,
+	PSP_USBCAM_EFFECTMODE_SEPIA = 3,
+	PSP_USBCAM_EFFECTMODE_BLUE = 4,
+	PSP_USBCAM_EFFECTMODE_RED = 5,
+	PSP_USBCAM_EFFECTMODE_GREEN = 6,
+};
+
+/** Exposure levels */
+enum PspUsbCamEVLevel
+{
+	PSP_USBCAM_EVLEVEL_2_0_POSITIVE = 0, // +2.0
+	PSP_USBCAM_EVLEVEL_1_7_POSITIVE = 1, // +1.7
+	PSP_USBCAM_EVLEVEL_1_5_POSITIVE = 2, // +1.5
+	PSP_USBCAM_EVLEVEL_1_3_POSITIVE = 3, // +1.3
+	PSP_USBCAM_EVLEVEL_1_0_POSITIVE = 4, // +1.0
+	PSP_USBCAM_EVLEVEL_0_7_POSITIVE = 5, // +0.7
+	PSP_USBCAM_EVLEVEL_0_5_POSITIVE = 6, // +0.5
+	PSP_USBCAM_EVLEVEL_0_3_POSITIVE = 7, // +0.3
+	PSP_USBCAM_EVLEVEL_0_0 = 8, // 0.0
+	PSP_USBCAM_EVLEVEL_0_3_NEGATIVE = 9, // -0.3
+	PSP_USBCAM_EVLEVEL_0_5_NEGATIVE = 10, // -0.5
+	PSP_USBCAM_EVLEVEL_0_7_NEGATIVE = 11, // -0.7
+	PSP_USBCAM_EVLEVEL_1_0_NEGATIVE = 12, // -1.0
+	PSP_USBCAM_EVLEVEL_1_3_NEGATIVE = 13, // -1.3
+	PSP_USBCAM_EVLEVEL_1_5_NEGATIVE = 14, // -1.5
+	PSP_USBCAM_EVLEVEL_1_7_NEGATIVE = 15, // -1.7
+	PSP_USBCAM_EVLEVEL_2_0_NEGATIVE = 16, // -2.0
+};
+
+
+
+/** Structure for sceUsbCamSetupStill */
+typedef struct PspUsbCamSetupStillParam {
+/** Size of the ::PspUsbCamSetupStillParam structure */
+	int size;
+/** Resolution. One of ::PspUsbCamResolution */
+	int resolution;
+/** Size of the jpeg image */
+	int	jpegsize;
+/** Reverse effect to apply. Zero or more of ::PspUsbCamReverseFlags */
+	int reverseflags;
+/** Delay to apply to take the picture. One of ::PspUsbCamDelay */
+	int delay;
+/** JPEG compression level, a value from 1-63. 
+    1 -> less compression, better quality; 63 -> max compression, worse quality */
+	int complevel;
+} PspUsbCamSetupStillParam;
+
+/** Structure for sceUsbCamSetupStillEx */
+typedef struct PspUsbCamSetupStillExParam {
+/** Size of the ::PspUsbCamSetupStillExParam structure */
+	int size;
+/** Unknown, set it to 9 at the moment. */
+	u32 unk;
+/** Resolution. One of ::PspUsbCamResolutionEx */
+	int resolution;
+/** Size of the jpeg image */
+	int jpegsize;
+/** JPEG compression level, a value from 1-63. 
+    1 -> less compression, better quality; 63 -> max compression, worse quality */
+	int complevel;
+/** Unknown, set it to 0 at the moment */
+	u32 unk2;
+/** Unknown, set it to 1 at the moment */
+	u32 unk3;
+/** Flag that indicates whether to flip the image */
+	int flip;
+/** Flag that indicates whether to mirror the image */
+	int mirror;
+/** Delay to apply to take the picture. One of ::PspUsbCamDelay */
+	int delay;
+/** Unknown, set it to 0 at the moment */
+	u32 unk4[5];
+} PspUsbCamSetupStillExParam;
+
+typedef struct PspUsbCamSetupVideoParam {
+/** Size of the ::PspUsbCamSetupVideoParam structure */
+	int size;
+/** Resolution. One of ::PspUsbCamResolution */
+	int resolution;
+/** Framerate. One of ::PspUsbCamFrameRate */
+	int framerate;
+/** White balance. One of ::PspUsbCamWB */
+	int wb;
+/** Saturarion (0-255) */
+	int saturation;
+/** Brightness (0-255) */
+	int brightness;
+/** Contrast (0-255) */
+	int contrast;
+/** Sharpness (0-255) */
+	int sharpness;
+/** Effect mode. One of ::PspUsbCamEffectMode */
+	int effectmode;
+/** Size of jpeg video frame */
+	int framesize;
+/** Unknown. Set it to 0 at the moment. */
+	u32 unk;
+/** Exposure value. One of ::PspUsbCamEVLevel */
+	int evlevel;
+} PspUsbCamSetupVideoParam;
+
+typedef struct PspUsbCamSetupVideoExParam {
+/** Size of the ::PspUsbCamSetupVideoParam structure */
+	int size;
+/* Unknown. Set it to 9 at the moment. */
+	u32 unk;
+/** Resolution. One of ::PspUsbCamResolutionEx */
+	int resolution;
+/** Framerate. One of ::PspUsbCamFrameRate */
+	int framerate;
+/** Unknown. Set it to 2 at the moment */
+	u32 unk2;
+/** Unknown. Set it to 3 at the moment */
+	u32 unk3;
+/** White balance. One of ::PspUsbCamWB */
+	int wb;
+/** Saturarion (0-255) */
+	int saturation;
+/** Brightness (0-255) */
+	int brightness;
+/** Contrast (0-255) */
+	int contrast;
+/** Sharpness (0-255) */
+	int sharpness;
+/** Unknown. Set it to 0 at the moment */
+	u32 unk4;
+/** Unknown. Set it to 1 at the moment */
+	u32 unk5;
+/** Unknown. Set it to 0 at the moment */
+	u32 unk6[3];
+/** Effect mode. One of ::PspUsbCamEffectMode */
+	int effectmode;
+/** Unknown. Set it to 1 at the moment */
+	u32 unk7;
+/** Unknown. Set it to 10 at the moment */
+	u32 unk8;
+/** Unknown. Set it to 2 at the moment */
+	u32 unk9;
+/** Unknown. Set it to 500 at the moment */
+	u32 unk10;
+/** Unknown. Set it to 1000 at the moment */
+	u32 unk11;
+/** Size of jpeg video frame */
+	int framesize;
+/** Unknown. Set it to 0 at the moment */
+	u32 unk12;
+/** Exposure value. One of ::PspUsbCamEVLevel */
+	int evlevel;
+} PspUsbCamSetupVideoExParam;
+
+/**
+ * Setups the parameters to take a still image.
+ *
+ * @param param - pointer to a ::PspUsbCamSetupStillParam 
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetupStill(PspUsbCamSetupStillParam *param);
+
+/**
+ * Setups the parameters to take a still image (with more options)
+ *
+ * @param param - pointer to a ::PspUsbCamSetupStillExParam 
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetupStillEx(PspUsbCamSetupStillExParam *param);
+
+/**
+ * Gets a still image. The function doesn't return until the image 
+ * has been acquired.
+ *
+ * @param buf - The buffer that receives the image jpeg data
+ * @param size - The size of the buffer.
+ *
+ * @return size of acquired image on success, < 0 on error
+*/
+int sceUsbCamStillInputBlocking(u8 *buf, SceSize size);
+
+/**
+ * Gets a still image. The function returns inmediately, and
+ * the completion has to be handled by calling ::sceUsbCamStillWaitInputEnd
+ * or ::sceUsbCamStillPollInputEnd.
+ *
+ * @param buf - The buffer that receives the image jpeg data
+ * @param size - The size of the buffer.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamStillInput(u8 *buf, SceSize size);
+
+/** 
+ * Waits untils still input has been finished.
+ *
+ * @return the size of the acquired image on sucess, < 0 on error
+*/
+int sceUsbCamStillWaitInputEnd(void);
+
+/**
+ * Polls the status of still input completion.
+ *
+ * @return the size of the acquired image if still input has ended, 
+ * 0 if the input has not ended, < 0 on error.
+*/
+int sceUsbCamStillPollInputEnd(void);
+
+/** 
+ * Cancels the still input.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamStillCancelInput(void);
+
+/**
+ * Gets the size of the acquired still image.
+ *
+ * @return the size of the acquired image on success, < 0 on error
+*/
+int sceUsbCamStillGetInputLength(void);
+
+/**
+ * Set ups the parameters for video capture.
+ *
+ * @param param - Pointer to a ::PspUsbCamSetupVideoParam structure.
+ * @param workarea - Pointer to a buffer used as work area by the driver.
+ * @param wasize - Size of the work area.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetupVideo(PspUsbCamSetupVideoParam *param, void *workarea, int wasize);
+
+/**
+ * Set ups the parameters for video capture (with more options)
+ *
+ * @param param - Pointer to a ::PspUsbCamSetupVideoExParam structure.
+ * @param workarea - Pointer to a buffer used as work area by the driver.
+ * @param wasize - Size of the work area.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetupVideoEx(PspUsbCamSetupVideoExParam *param, void *workarea, int wasize);
+
+/**
+ * Starts video input from the camera.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamStartVideo(void);
+
+/**
+ * Stops video input from the camera.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamStopVideo(void);
+
+/**
+ * Reads a video frame. The function doesn't return until the frame 
+ * has been acquired.
+ *
+ * @param buf - The buffer that receives the frame jpeg data
+ * @param size - The size of the buffer.
+ *
+ * @return size of acquired frame on success, < 0 on error
+*/
+int sceUsbCamReadVideoFrameBlocking(u8 *buf, SceSize size);
+
+/**
+ * Reads a video frame. The function returns inmediately, and
+ * the completion has to be handled by calling ::sceUsbCamWaitReadVideoFrameEnd
+ * or ::sceUsbCamPollReadVideoFrameEnd.
+ *
+ * @param buf - The buffer that receives the frame jpeg data
+ * @param size - The size of the buffer.
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamReadVideoFrame(u8 *buf, SceSize size);
+
+/** 
+ * Waits untils the current frame has been read.
+ *
+ * @return the size of the acquired frame on sucess, < 0 on error
+*/
+int sceUsbCamWaitReadVideoFrameEnd(void);
+
+/**
+ * Polls the status of video frame read completion.
+ *
+ * @return the size of the acquired frame if it has been read, 
+ * 0 if the frame has not yet been read, < 0 on error.
+*/
+int sceUsbCamPollReadVideoFrameEnd(void);
+
+/**
+ * Gets the size of the acquired frame.
+ *
+ * @return the size of the acquired frame on success, < 0 on error
+*/
+int sceUsbCamGetReadVideoFrameSize(void);
+
+/**
+ * Sets the saturation 
+ *
+ * @param saturation - The saturation (0-255)
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetSaturation(int saturation);
+
+/**
+ * Sets the brightness
+ *
+ * @param brightness - The brightness (0-255)
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetBrightness(int brightness);
+
+/**
+ * Sets the contrast
+ *
+ * @param contrast - The contrast (0-255)
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetContrast(int contrast);
+
+/**
+ * Sets the sharpness
+ *
+ * @param sharpness - The sharpness (0-255)
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetSharpness(int sharpness);
+
+/**
+ * Sets the image effect mode
+ *
+ * @param effectmode - The effect mode, one of ::PspUsbCamEffectMode
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetImageEffectMode(int effectmode);
+
+/**
+ * Sets the exposure level
+ *
+ * @param ev - The exposure level, one of ::PspUsbCamEVLevel
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetEvLevel(int ev);
+
+/**
+ * Sets the reverse mode
+ *
+ * @param reverseflags - The reverse flags, zero or more of ::PspUsbCamReverseFlags
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamSetReverseMode(int reverseflags);
+
+/**
+ * Sets the zoom.
+ *
+ * @param zoom - The zoom level starting by 10. (10 = 1X, 11 = 1.1X, etc)
+ *
+ * @returns 0 on success, < 0 on error
+*/
+int sceUsbCamSetZoom(int zoom);
+
+/**
+ * Gets the current saturation
+ *
+ * @param saturation - pointer to a variable that receives the current saturation
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetSaturation(int *saturation);
+
+/**
+ * Gets the current brightness
+ *
+ * @param brightness - pointer to a variable that receives the current brightness
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetBrightness(int *brightness);
+
+/**
+ * Gets the current contrast
+ *
+ * @param contrast - pointer to a variable that receives the current contrast
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetContrast(int *contrast);
+
+/**
+ * Gets the current sharpness
+ *
+ * @param sharpness - pointer to a variable that receives the current sharpness
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetSharpness(int *sharpness);
+
+/**
+ * Gets the current image efect mode
+ *
+ * @param effectmode - pointer to a variable that receives the current effect mode
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetImageEffectMode(int *effectmode);
+
+/**
+ * Gets the current exposure level.
+ *
+ * @param ev - pointer to a variable that receives the current exposure level
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetEvLevel(int *ev);
+
+/**
+ * Gets the current reverse mode.
+ *
+ * @param reverseflags - pointer to a variable that receives the current reverse mode flags
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetReverseMode(int *reverseflags);
+
+/**
+ * Gets the current zoom.
+ *
+ * @param zoom - pointer to a variable that receives the current zoom
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamGetZoom(int *zoom);
+
+/**
+ * Sets if the image should be automatically reversed, depending of the position
+ * of the camera.
+ *
+ * @param on - 1 to set the automatical reversal of the image, 0 to set it off
+ *
+ * @return 0 on success, < 0 on error
+*/
+int sceUsbCamAutoImageReverseSW(int on);
+
+/**
+ * Gets the state of the autoreversal of the image.
+ *
+ * @return 1 if it is set to automatic, 0 otherwise
+*/
+int sceUsbCamGetAutoImageReverseState(void);
+
+/**
+ * Gets the direction of the camera lens
+ *
+ * @return 1 if the camera is "looking to you", 0 if the camera
+ * is "looking to the other side".
+*/
+int sceUsbCamGetLensDirection(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
+
+
+
diff --git a/newlib/psp/include/pspusbstor.h b/newlib/psp/include/pspusbstor.h
new file mode 100644
index 0000000..d5d97eb
--- /dev/null
+++ b/newlib/psp/include/pspusbstor.h
@@ -0,0 +1,63 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspusbstor.h - Prototypes for the sceUsbStor and sceUsbStorBoot libraries
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUSBSTOR_H__
+#define __PSPUSBSTOR_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PSP_USBSTOR_DRIVERNAME "USBStor_Driver"
+
+/**
+  * Register an eventFlag to send notifications to.
+  * 
+  * @param eventFlag - eventFlag created with sceKernelCreateEventFlag
+  *
+  * @return 0 on success
+  */
+int sceUsbstorBootRegisterNotify(u32 eventFlag);
+
+/**
+  * Unregister a previously registered eventFlag.
+  * 
+  * @param eventFlag - eventFlag created with sceKernelCreateEventFlag
+  *
+  * @return 0 on success
+  */
+int sceUsbstorBootUnregisterNotify(u32 eventFlag);
+
+/**
+  * Tell the USBstorBoot driver the size of MS
+  *
+  * @note I'm not sure if this is the actual size of the media or not
+  * as it seems to have no bearing on what size windows detects.
+  * PSPPET passes 0x800000
+  * 
+  * @param size - capacity of memory stick
+  *
+  * @return 0 on success
+  */
+int sceUsbstorBootSetCapacity(u32 size);
+
+// the following are disabled until more testing is done
+#if 0
+int sceUsbstorBootGetDataSize(void); // what for ?
+int sceUsbstorBootSetLoadAddr(u32 addr); // ?
+int sceUsbstorBootSetStatus(u32 status); // 1=?
+int sceUsbstorGetStatus(?)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspuser.h b/newlib/psp/include/pspuser.h
new file mode 100644
index 0000000..3c9651b
--- /dev/null
+++ b/newlib/psp/include/pspuser.h
@@ -0,0 +1,30 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspuser.h - Main include file for the user interface to the PSP kernel.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+
+#ifndef PSPUSER_H
+#define PSPUSER_H
+
+#include <psptypes.h>
+#include <pspkerneltypes.h>
+#include <pspiofilemgr.h>
+#include <psploadexec.h>
+#include <pspmoduleinfo.h>
+#include <pspmodulemgr.h>
+#include <pspsysmem.h>
+#include <pspthreadman.h>
+#include <psputils.h>
+#include <pspkerror.h>
+#include <pspstdio.h>
+#include <pspintrman.h>
+
+#endif /* PSPUSER_H */
diff --git a/newlib/psp/include/psputility.h b/newlib/psp/include/psputility.h
new file mode 100644
index 0000000..3d60e25
--- /dev/null
+++ b/newlib/psp/include/psputility.h
@@ -0,0 +1,57 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility.h - Master include for the pspUtility library
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUTILITY_H__
+#define __PSPUTILITY_H__
+
+typedef struct
+{
+	unsigned int size;	/** Size of the structure */
+	int language;		/** Language */
+	int buttonSwap;		/** Set to 1 for X/O button swap */
+	int graphicsThread;	/** Graphics thread priority */
+	int accessThread;	/** Access/fileio thread priority (SceJobThread) */
+	int fontThread;		/** Font thread priority (ScePafThread) */
+	int soundThread;	/** Sound thread priority */
+	int result;			/** Result */
+	int reserved[4];	/** Set to 0 */
+
+} pspUtilityDialogCommon;
+
+#include <psputility_msgdialog.h>
+#include <psputility_netconf.h>
+#include <psputility_netparam.h>
+#include <psputility_savedata.h>
+#include <psputility_gamesharing.h>
+#include <psputility_htmlviewer.h>
+#include <psputility_sysparam.h>
+#include <psputility_osk.h>
+#include <psputility_netmodules.h>
+#include <psputility_avmodules.h>
+#include <psputility_usbmodules.h>
+#include <psputility_modules.h>
+
+#define PSP_UTILITY_ACCEPT_CIRCLE 0
+#define PSP_UTILITY_ACCEPT_CROSS  1
+
+/**
+ * Return-values for the various sceUtility***GetStatus() functions
+**/
+typedef enum
+{
+	PSP_UTILITY_DIALOG_NONE = 0,	/**< No dialog is currently active */
+	PSP_UTILITY_DIALOG_INIT,		/**< The dialog is currently being initialized */
+	PSP_UTILITY_DIALOG_VISIBLE,		/**< The dialog is visible and ready for use */
+	PSP_UTILITY_DIALOG_QUIT,		/**< The dialog has been canceled and should be shut down */
+	PSP_UTILITY_DIALOG_FINISHED		/**< The dialog has successfully shut down */
+	
+} pspUtilityDialogState;
+
+#endif
diff --git a/newlib/psp/include/psputility_avmodules.h b/newlib/psp/include/psputility_avmodules.h
new file mode 100644
index 0000000..01fb928
--- /dev/null
+++ b/newlib/psp/include/psputility_avmodules.h
@@ -0,0 +1,52 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputility_avmodules.h - Load audio/video modules from user mode on 2.xx+
+ *
+ * Copyright (c) 2007 David Perry <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __PSPUTILITY_AVMODULES_H__
+#define __PSPUTILITY_AVMODULES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+#define PSP_AV_MODULE_AVCODEC		0
+#define PSP_AV_MODULE_SASCORE		1
+#define PSP_AV_MODULE_ATRAC3PLUS	2 // Requires PSP_AV_MODULE_AVCODEC loading first
+#define PSP_AV_MODULE_MPEGBASE		3 // Requires PSP_AV_MODULE_AVCODEC loading first
+#define PSP_AV_MODULE_MP3			4
+#define PSP_AV_MODULE_VAUDIO		5
+#define PSP_AV_MODULE_AAC			6
+#define PSP_AV_MODULE_G729			7
+
+/**
+ * Load an audio/video module (PRX) from user mode.
+ *
+ * Available on firmware 2.00 and higher only.
+ *
+ * @param module - module number to load (PSP_AV_MODULE_xxx)
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityLoadAvModule(int module);
+
+/**
+ * Unload an audio/video module (PRX) from user mode.
+ * Available on firmware 2.00 and higher only.
+ *
+ * @param module - module number to be unloaded
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityUnloadAvModule(int module);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_gamesharing.h b/newlib/psp/include/psputility_gamesharing.h
new file mode 100644
index 0000000..28b91fe
--- /dev/null
+++ b/newlib/psp/include/psputility_gamesharing.h
@@ -0,0 +1,86 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_gamesharing.h - Game Sharing utility library
+ *
+ * Copyright (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __PSPUTILITY_GAMESHARING_H__
+#define __PSPUTILITY_GAMESHARING_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum
+{
+	PSP_UTILITY_GAMESHARING_MODE_SINGLE		= 1,	/* Single send */
+	PSP_UTILITY_GAMESHARING_MODE_MULTIPLE	= 2		/* Up to 4 simultaneous sends */
+	
+} pspUtilityGameSharingMode;
+
+typedef enum
+{
+	PSP_UTILITY_GAMESHARING_DATA_TYPE_FILE		= 1, /* EBOOT is a file */
+	PSP_UTILITY_GAMESHARING_DATA_TYPE_MEMORY	= 2, /* EBOOT is in memory */
+	
+} pspUtilityGameSharingDataType;
+
+/**
+ * Structure to hold the parameters for Game Sharing
+**/
+typedef struct _pspUtilityGameSharingParams
+{
+    pspUtilityDialogCommon base;
+    int unknown1;							/* Set to 0 */
+	int unknown2;							/* Set to 0 */
+	char name[8];
+	int unknown3;							/* Set to 0 */
+	int unknown4;							/* Set to 0 */
+	int unknown5;							/* Set to 0 */
+	int result;								/* Return value */
+	char *filepath;							/* File path if PSP_UTILITY_GAMESHARING_DATA_TYPE_FILE specified */
+	pspUtilityGameSharingMode mode;			/* Send mode. One of ::pspUtilityGameSharingMode */
+	pspUtilityGameSharingDataType datatype; /* Data type. One of ::pspUtilityGameSharingDataType */
+	void *data;								/* Pointer to the EBOOT data in memory */
+	unsigned int datasize;					/* Size of the EBOOT data in memory */
+
+} pspUtilityGameSharingParams;
+
+/**
+ * Init the game sharing
+ *
+ * @param params - game sharing parameters
+ * @return 0 on success, < 0 on error.
+ */
+int sceUtilityGameSharingInitStart(pspUtilityGameSharingParams *params);
+
+/**
+ * Shutdown game sharing. 
+ */
+void sceUtilityGameSharingShutdownStart(void);
+
+/**
+ * Get the current status of game sharing.
+ *
+ * @return 2 if the GUI is visible (you need to call sceUtilityGameSharingGetStatus).
+ * 3 if the user cancelled the dialog, and you need to call sceUtilityGameSharingShutdownStart.
+ * 4 if the dialog has been successfully shut down.
+ */
+int sceUtilityGameSharingGetStatus(void);
+
+/**
+ * Refresh the GUI for game sharing
+ *
+ * @param n - unknown, pass 1
+ */
+void sceUtilityGameSharingUpdate(int n);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_htmlviewer.h b/newlib/psp/include/psputility_htmlviewer.h
new file mode 100644
index 0000000..5e36def
--- /dev/null
+++ b/newlib/psp/include/psputility_htmlviewer.h
@@ -0,0 +1,192 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputility_htmlviewer.h - html viewer utility library.
+ *
+ * Copyright (c) 2008 David Perry (InsertWittyName)
+ * Copyright (c) 2008 moonlight
+ *
+ */
+
+#ifndef __PSPUTILITY_HTMLVIEWER_H__
+#define __PSPUTILITY_HTMLVIEWER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum pspUtilityHtmlViewerDisconnectModes
+{
+	/** Enable automatic disconnect */
+	PSP_UTILITY_HTMLVIEWER_DISCONNECTMODE_ENABLE = 0,
+	/** Disable automatic disconnect */
+	PSP_UTILITY_HTMLVIEWER_DISCONNECTMODE_DISABLE,
+	/** Confirm disconnection */	
+	PSP_UTILITY_HTMLVIEWER_DISCONNECTMODE_CONFIRM
+};
+
+enum pspUtilityHtmlViewerInterfaceModes
+{
+	/** Full user interface */
+	PSP_UTILITY_HTMLVIEWER_INTERFACEMODE_FULL = 0,
+	/** Limited user interface */
+	PSP_UTILITY_HTMLVIEWER_INTERFACEMODE_LIMITED,
+	/** No user interface */
+	PSP_UTILITY_HTMLVIEWER_INTERFACEMODE_NONE
+};
+
+enum pspUtilityHtmlViewerCookieModes
+{
+	/** Disable accepting cookies */
+	PSP_UTILITY_HTMLVIEWER_COOKIEMODE_DISABLED = 0,
+	/** Enable accepting cookies */
+	PSP_UTILITY_HTMLVIEWER_COOKIEMODE_ENABLED,
+	/** Confirm accepting a cookie every time */
+	PSP_UTILITY_HTMLVIEWER_COOKIEMODE_CONFIRM,
+	/** Use the system default for accepting cookies */
+	PSP_UTILITY_HTMLVIEWER_COOKIEMODE_DEFAULT
+};
+
+enum pspUtilityHtmlViewerTextSizes
+{
+	/** Large text size */
+	PSP_UTILITY_HTMLVIEWER_TEXTSIZE_LARGE = 0,
+	/** Normal text size */
+	PSP_UTILITY_HTMLVIEWER_TEXTSIZE_NORMAL,
+	/** Small text size */
+	PSP_UTILITY_HTMLVIEWER_TEXTSIZE_SMALL
+};
+
+enum pspUtilityHtmlViewerDisplayModes
+{
+	/** Normal display */
+	PSP_UTILITY_HTMLVIEWER_DISPLAYMODE_NORMAL = 0,
+	/** Fit display */
+	PSP_UTILITY_HTMLVIEWER_DISPLAYMODE_FIT,
+	/** Smart fit display */
+	PSP_UTILITY_HTMLVIEWER_DISPLAYMODE_SMART_FIT
+};
+
+enum pspUtilityHtmlViewerConnectModes
+{
+	/** Auto connect to last used connection */
+	PSP_UTILITY_HTMLVIEWER_CONNECTMODE_LAST = 0,
+	/** Manually select the connection (once) */
+	PSP_UTILITY_HTMLVIEWER_CONNECTMODE_MANUAL_ONCE,
+	/** Manually select the connection (every time) */
+	PSP_UTILITY_HTMLVIEWER_CONNECTMODE_MANUAL_ALL
+};
+
+enum pspUtilityHtmlViewerOptions
+{
+	/** Open SCE net start page */
+	PSP_UTILITY_HTMLVIEWER_OPEN_SCE_START_PAGE					= 0x000001,
+	/** Disable startup limitations */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_STARTUP_LIMITS				= 0x000002,
+	/** Disable exit confirmation dialog */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_EXIT_DIALOG					= 0x000004,
+	/** Disable cursor */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_CURSOR						= 0x000008,
+	/** Disable download completion confirmation dialog */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_COMPLETE_DIALOG		= 0x000010,
+	/** Disable download confirmation dialog */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_START_DIALOG		= 0x000020,
+	/** Disable save destination confirmation dialog */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_DOWNLOAD_DESTINATION_DIALOG	= 0x000040,
+	/** Disable modification of the download destination */
+	PSP_UTILITY_HTMLVIEWER_LOCK_DOWNLOAD_DESTINATION_DIALOG		= 0x000080,
+	/** Disable tab display */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_TAB_DISPLAY					= 0x000100,
+	/** Hold analog controller when HOLD button is down */
+	PSP_UTILITY_HTMLVIEWER_ENABLE_ANALOG_HOLD					= 0x000200,
+	/** Enable Flash Player */
+	PSP_UTILITY_HTMLVIEWER_ENABLE_FLASH							= 0x000400,
+	/** Disable L/R triggers for back/forward */
+	PSP_UTILITY_HTMLVIEWER_DISABLE_LRTRIGGER					= 0x000800	
+};
+
+typedef struct pspUtilityHtmlViewerParam
+{
+	pspUtilityDialogCommon base;
+	/** Pointer to the memory pool to be used */
+	void* memaddr;
+	/** Size of the memory pool */
+	unsigned int memsize;
+	/** Unknown. Pass 0 */
+	int	unknown1;
+	/** Unknown. Pass 0 */
+	int	unknown2;
+	/** URL to be opened initially */
+	char* initialurl;
+	/** Number of tabs (maximum of 3) */
+	unsigned int numtabs;
+	/** One of ::pspUtilityHtmlViewerInterfaceModes */
+	unsigned int interfacemode;
+	/** Values from ::pspUtilityHtmlViewerOptions. Bitwise OR together */
+	unsigned int options;
+	/** Directory to be used for downloading */
+	char* dldirname;
+	/** Filename to be used for downloading */
+	char* dlfilename;
+	/** Directory to be used for uploading */
+	char* uldirname;
+	/** Filename to be used for uploading */
+	char* ulfilename;
+	/** One of ::pspUtilityHtmlViewerCookieModes */
+	unsigned int cookiemode;
+	/** Unknown. Pass 0 */
+	unsigned int unknown3;
+	/** URL to set the home page to */
+	char* homeurl;
+	/** One of ::pspUtilityHtmlViewerTextSizes */
+	unsigned int textsize;
+	/** One of ::pspUtilityHtmlViewerDisplayModes */
+	unsigned int displaymode;
+	/** One of ::pspUtilityHtmlViewerConnectModes */
+	unsigned int connectmode;
+	/** One of ::pspUtilityHtmlViewerDisconnectModes */
+	unsigned int disconnectmode;
+	/** The maximum amount of memory the browser used */
+	unsigned int memused;
+	/** Unknown. Pass 0 */
+	int unknown4[10];
+	
+} pspUtilityHtmlViewerParam;
+
+/**
+ * Init the html viewer
+ *
+ * @param params - html viewer parameters
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceUtilityHtmlViewerInitStart(pspUtilityHtmlViewerParam *params);
+
+/**
+ * Shutdown html viewer. 
+ */
+int sceUtilityHtmlViewerShutdownStart(void);
+
+/**
+ * Refresh the GUI for html viewer
+ *
+ * @param n - unknown, pass 1
+ */
+int sceUtilityHtmlViewerUpdate(int n);
+
+/**
+ * Get the current status of the html viewer.
+ *
+ * @return 2 if the GUI is visible (you need to call sceUtilityHtmlViewerGetStatus).
+ * 3 if the user cancelled the dialog, and you need to call sceUtilityHtmlViewerShutdownStart.
+ * 4 if the dialog has been successfully shut down.
+ */
+int sceUtilityHtmlViewerGetStatus(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_modules.h b/newlib/psp/include/psputility_modules.h
new file mode 100644
index 0000000..e9824cb
--- /dev/null
+++ b/newlib/psp/include/psputility_modules.h
@@ -0,0 +1,80 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputility_modules.h - Load modules from user mode
+ *
+ * Copyright (c) 2008 David Perry <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __PSPUTILITY_MODULES_H__
+#define __PSPUTILITY_MODULES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/* Net Modules */
+#define PSP_MODULE_NET_COMMON		0x0100
+#define PSP_MODULE_NET_ADHOC		0x0101
+#define PSP_MODULE_NET_INET			0x0102
+#define PSP_MODULE_NET_PARSEURI		0x0103
+#define PSP_MODULE_NET_PARSEHTTP	0x0104
+#define PSP_MODULE_NET_HTTP			0x0105
+#define PSP_MODULE_NET_SSL			0x0106
+
+/* USB Modules */
+#define PSP_MODULE_USB_PSPCM		0x0200
+#define PSP_MODULE_USB_MIC			0x0201
+#define PSP_MODULE_USB_CAM			0x0202
+#define PSP_MODULE_USB_GPS			0x0203
+
+/* Audio/video Modules */
+#define PSP_MODULE_AV_AVCODEC		0x0300
+#define PSP_MODULE_AV_SASCORE		0x0301
+#define PSP_MODULE_AV_ATRAC3PLUS	0x0302
+#define PSP_MODULE_AV_MPEGBASE		0x0303
+#define PSP_MODULE_AV_MP3			0x0304
+#define PSP_MODULE_AV_VAUDIO		0x0305
+#define PSP_MODULE_AV_AAC			0x0306
+#define PSP_MODULE_AV_G729			0x0307
+
+/* NP */
+#define PSP_MODULE_NP_COMMON		0x0400
+#define PSP_MODULE_NP_SERVICE		0x0401
+#define PSP_MODULE_NP_MATCHING2		0x0402
+
+#define PSP_MODULE_NP_DRM			0x0500
+
+/* IrDA */
+#define PSP_MODULE_IRDA				0x0600
+
+/** An error code used as a return value */
+#define SCE_ERROR_MODULE_ALREADY_LOADED (0x80111102)
+
+/**
+ * Load a module (PRX) from user mode.
+ *
+ * @param module - module to load (PSP_MODULE_xxx)
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityLoadModule(int module);
+
+/**
+ * Unload a module (PRX) from user mode.
+ *
+ * @param module - module to unload (PSP_MODULE_xxx)
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityUnloadModule(int module);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_msgdialog.h b/newlib/psp/include/psputility_msgdialog.h
new file mode 100644
index 0000000..6279572
--- /dev/null
+++ b/newlib/psp/include/psputility_msgdialog.h
@@ -0,0 +1,101 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_msdialog.h - Definitions and Functions for Dialogs
+ *                         section of the pspUtility library
+ *
+ * Copyright (c) 2005 Marcus Comstedt <marcus@mc.pp.se>
+ *			 (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __PSPUTILITY_DIALOGS_H__
+#define __PSPUTILITY_DIALOGS_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum
+{
+	PSP_UTILITY_MSGDIALOG_MODE_ERROR = 0, /* Error message */
+	PSP_UTILITY_MSGDIALOG_MODE_TEXT /* String message */
+	
+} pspUtilityMsgDialogMode;
+
+typedef enum
+{
+	PSP_UTILITY_MSGDIALOG_OPTION_ERROR = 0, /* Error message (why two flags?) */
+	PSP_UTILITY_MSGDIALOG_OPTION_TEXT = 0x00000001, /* Text message (why two flags?) */
+	PSP_UTILITY_MSGDIALOG_OPTION_YESNO_BUTTONS = 0x00000010,	/* Yes/No buttons instead of 'Cancel' */
+	PSP_UTILITY_MSGDIALOG_OPTION_DEFAULT_NO  = 0x00000100	/* Default position 'No', if not set will default to 'Yes' */
+	
+} pspUtilityMsgDialogOption;
+
+typedef enum
+{
+	PSP_UTILITY_MSGDIALOG_RESULT_UNKNOWN1 = 0,
+	PSP_UTILITY_MSGDIALOG_RESULT_YES,
+	PSP_UTILITY_MSGDIALOG_RESULT_NO,
+	PSP_UTILITY_MSGDIALOG_RESULT_BACK
+	
+} pspUtilityMsgDialogPressed;
+
+/**
+ * Structure to hold the parameters for a message dialog
+**/
+typedef struct _pspUtilityMsgDialogParams
+{
+    pspUtilityDialogCommon base;
+    int unknown;
+	pspUtilityMsgDialogMode mode;
+	unsigned int errorValue;
+    /** The message to display (may contain embedded linefeeds) */
+    char message[512];
+	int options; /* OR ::pspUtilityMsgDialogOption together for multiple options */
+	pspUtilityMsgDialogPressed buttonPressed;
+
+} pspUtilityMsgDialogParams;
+
+/**
+ * Create a message dialog
+ *
+ * @param params - dialog parameters
+ * @return 0 on success
+ */
+int sceUtilityMsgDialogInitStart(pspUtilityMsgDialogParams *params);
+
+/**
+ * Remove a message dialog currently active.  After calling this
+ * function you need to keep calling GetStatus and Update until
+ * you get a status of 4.
+ */
+void sceUtilityMsgDialogShutdownStart(void);
+
+/**
+ * Get the current status of a message dialog currently active.
+ *
+ * @return 2 if the GUI is visible (you need to call sceUtilityMsgDialogGetStatus).
+ * 3 if the user cancelled the dialog, and you need to call sceUtilityMsgDialogShutdownStart.
+ * 4 if the dialog has been successfully shut down.
+ */
+int sceUtilityMsgDialogGetStatus(void);
+
+/**
+ * Refresh the GUI for a message dialog currently active
+ *
+ * @param n - unknown, pass 1
+ */
+void sceUtilityMsgDialogUpdate(int n);
+
+/**
+ * Abort a message dialog currently active
+ */
+int sceUtilityMsgDialogAbort(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_netconf.h b/newlib/psp/include/psputility_netconf.h
new file mode 100644
index 0000000..460f851
--- /dev/null
+++ b/newlib/psp/include/psputility_netconf.h
@@ -0,0 +1,79 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_netconf.h - Definitions and Functions for Network Configuration 
+ *                         section of the pspUtility library
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUTILITY_NETCONF_H__
+#define __PSPUTILITY_NETCONF_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+enum pspUtilityNetconfActions
+{
+	PSP_NETCONF_ACTION_CONNECTAP,
+	PSP_NETCONF_ACTION_DISPLAYSTATUS,
+	PSP_NETCONF_ACTION_CONNECT_ADHOC
+};
+
+struct pspUtilityNetconfAdhoc
+{
+	unsigned char name[8];
+	unsigned int timeout;
+};
+
+typedef struct _pspUtilityNetconfData
+{
+	pspUtilityDialogCommon base;
+	int action; /** One of pspUtilityNetconfActions */
+	struct pspUtilityNetconfAdhoc *adhocparam; //* Adhoc connection params */
+	int hotspot; /** Set to 1 to allow connections with the 'Internet Browser' option set to 'Start' (ie. hotspot connection) */
+	int hotspot_connected; /** Will be set to 1 when connected to a hotspot style connection */
+	int wifisp; /** Set to 1 to allow connections to Wifi service providers (WISP) */
+	
+} pspUtilityNetconfData;
+
+/**
+ * Init the Network Configuration Dialog Utility
+ *
+ * @param data - pointer to pspUtilityNetconfData to be initialized
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityNetconfInitStart (pspUtilityNetconfData *data);
+
+/**
+ * Shutdown the Network Configuration Dialog Utility
+ *
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityNetconfShutdownStart (void);
+
+/**
+ * Update the Network Configuration Dialog GUI
+ * 
+ * @param unknown - unknown; set to 1
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityNetconfUpdate (int unknown);
+
+/**
+ * Get the status of a running Network Configuration Dialog
+ *
+ * @return one of pspUtilityDialogState on success, < 0 on error
+ */
+int sceUtilityNetconfGetStatus (void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_netmodules.h b/newlib/psp/include/psputility_netmodules.h
new file mode 100644
index 0000000..4135699
--- /dev/null
+++ b/newlib/psp/include/psputility_netmodules.h
@@ -0,0 +1,55 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_netmodules.h - Load network modules from user mode on 2.xx+
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUTILITY_NETMODULES_H__
+#define __PSPUTILITY_NETMODULES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+#define PSP_NET_MODULE_COMMON 1
+#define PSP_NET_MODULE_ADHOC 2
+#define PSP_NET_MODULE_INET 3
+#define PSP_NET_MODULE_PARSEURI 4
+#define PSP_NET_MODULE_PARSEHTTP 5
+#define PSP_NET_MODULE_HTTP 6
+#define PSP_NET_MODULE_SSL 7
+    
+/** An error code used as a return value */
+#define SCE_ERROR_NET_MODULE_NOT_LOADED (0x80110803)
+
+/**
+ * Load a network module (PRX) from user mode.
+ * Load PSP_NET_MODULE_COMMON and PSP_NET_MODULE_INET
+ * to use infrastructure WifI (via an access point).
+ * Available on firmware 2.00 and higher only.
+ *
+ * @param module - module number to load (PSP_NET_MODULE_xxx)
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityLoadNetModule(int module);
+
+/**
+ * Unload a network module (PRX) from user mode.
+ * Available on firmware 2.00 and higher only.
+ *
+ * @param module - module number be unloaded
+ * @return 0 on success, < 0 on error
+ */
+int sceUtilityUnloadNetModule(int module);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_netparam.h b/newlib/psp/include/psputility_netparam.h
new file mode 100644
index 0000000..d45405b
--- /dev/null
+++ b/newlib/psp/include/psputility_netparam.h
@@ -0,0 +1,116 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_netparam.h - Definitions and Functions to manage Network  
+ *                          parameters.
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUTILITY_NETPARAM_H__
+#define __PSPUTILITY_NETPARAM_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/**
+ * Datatype for sceUtilityGetNetParam
+ * since it can return a u32 or a string
+ * we use a union to avoid ugly casting
+ */
+typedef union {
+	u32 asUint;
+	char asString[128];
+} netData;
+
+#define PSP_NETPARAM_NAME          0 // string
+#define PSP_NETPARAM_SSID          1 // string
+#define PSP_NETPARAM_SECURE        2 // int
+#define PSP_NETPARAM_WEPKEY        3 // string
+#define PSP_NETPARAM_IS_STATIC_IP  4 // int
+#define PSP_NETPARAM_IP            5 // string
+#define PSP_NETPARAM_NETMASK       6 // string
+#define PSP_NETPARAM_ROUTE         7 // string
+#define PSP_NETPARAM_MANUAL_DNS    8 // int
+#define PSP_NETPARAM_PRIMARYDNS    9 // string
+#define PSP_NETPARAM_SECONDARYDNS 10 // string
+#define PSP_NETPARAM_PROXY_USER   11 // string
+#define PSP_NETPARAM_PROXY_PASS   12 // string
+#define PSP_NETPARAM_USE_PROXY    13 // int
+#define PSP_NETPARAM_PROXY_SERVER 14 // string
+#define PSP_NETPARAM_PROXY_PORT   15 // int
+#define PSP_NETPARAM_UNKNOWN1     16 // int
+#define PSP_NETPARAM_UNKNOWN2     17 // int
+
+#define PSP_NETPARAM_ERROR_BAD_NETCONF	0x80110601
+#define PSP_NETPARAM_ERROR_BAD_PARAM	0x80110604
+
+/**
+ * Check existance of a Net Configuration
+ *
+ * @param id - id of net Configuration (1 to n)
+ * @return 0 on success, 
+ */
+int sceUtilityCheckNetParam(int id);
+
+/**
+ * Get Net Configuration Parameter
+ *
+ * @param conf - Net Configuration number (1 to n)
+ * (0 returns valid but seems to be a copy of the last config requested)
+ * @param param - which parameter to get
+ * @param data - parameter data
+ * @return 0 on success, 
+ */
+int sceUtilityGetNetParam(int conf, int param, netData *data);
+
+/**
+ * Create a new Network Configuration
+ * @note This creates a new configuration at conf and clears 0
+ *
+ * @param conf - Net Configuration number (1 to n)
+ *
+ * @return 0 on success
+ */
+int sceUtilityCreateNetParam(int conf);
+
+/**
+ * Sets a network parameter
+ * @note This sets only to configuration 0
+ *
+ * @param param - Which parameter to set
+ * @param val - Pointer to the the data to set
+ *
+ * @return 0 on success
+ */
+int sceUtilitySetNetParam(int param, const void *val);
+
+/**
+ * Copies a Network Configuration to another
+ *
+ * @param src - Source Net Configuration number (0 to n)
+ * @param dest - Destination Net Configuration number (0 to n)
+ *
+ * @return 0 on success
+ */
+int sceUtilityCopyNetParam(int src, int dest);
+
+/**
+ * Deletes a Network Configuration
+ *
+ * @param conf - Net Configuration number (1 to n)
+ *
+ * @return 0 on success
+ */
+int sceUtilityDeleteNetParam(int conf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_osk.h b/newlib/psp/include/psputility_osk.h
new file mode 100644
index 0000000..7a6e6e3
--- /dev/null
+++ b/newlib/psp/include/psputility_osk.h
@@ -0,0 +1,180 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_osk.h - Definitions and Functions for OSK section of
+ *                     the pspUtility library
+ *
+ * Copyright (c) 2006 McZonk
+ * Copyright (c) 2008 InsertWittyName <tias_dp@hotmail.com>
+ *
+ */
+#ifndef PSPOSK_H
+#define PSPOSK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/**
+ * Enumeration for input language
+ */
+enum SceUtilityOskInputLanguage
+{
+	PSP_UTILITY_OSK_LANGUAGE_DEFAULT =		0x00,
+	PSP_UTILITY_OSK_LANGUAGE_JAPANESE =		0x01,
+	PSP_UTILITY_OSK_LANGUAGE_ENGLISH =		0x02,
+	PSP_UTILITY_OSK_LANGUAGE_FRENCH =		0x03,
+	PSP_UTILITY_OSK_LANGUAGE_SPANISH =		0x04,
+	PSP_UTILITY_OSK_LANGUAGE_GERMAN =		0x05,
+	PSP_UTILITY_OSK_LANGUAGE_ITALIAN =		0x06,
+	PSP_UTILITY_OSK_LANGUAGE_DUTCH =		0x07,
+	PSP_UTILITY_OSK_LANGUAGE_PORTUGESE =	0x08,
+	PSP_UTILITY_OSK_LANGUAGE_RUSSIAN =		0x09,
+	PSP_UTILITY_OSK_LANGUAGE_KOREAN =		0x0a
+};
+
+/**
+ * Enumeration for OSK internal state
+ */
+enum SceUtilityOskState
+{
+	PSP_UTILITY_OSK_DIALOG_NONE = 0,	/**< No OSK is currently active */
+	PSP_UTILITY_OSK_DIALOG_INITING,		/**< The OSK is currently being initialized */
+	PSP_UTILITY_OSK_DIALOG_INITED,		/**< The OSK is initialised */
+	PSP_UTILITY_OSK_DIALOG_VISIBLE,		/**< The OSK is visible and ready for use */
+	PSP_UTILITY_OSK_DIALOG_QUIT,		/**< The OSK has been cancelled and should be shut down */
+	PSP_UTILITY_OSK_DIALOG_FINISHED		/**< The OSK has successfully shut down */	
+};
+
+/**
+ * Enumeration for OSK field results
+ */
+enum SceUtilityOskResult
+{
+	PSP_UTILITY_OSK_RESULT_UNCHANGED =	0,
+	PSP_UTILITY_OSK_RESULT_CANCELLED,
+	PSP_UTILITY_OSK_RESULT_CHANGED
+};
+
+/**
+ * Enumeration for input types (these are limited by initial choice of language)
+ */
+enum SceUtilityOskInputType
+{
+	PSP_UTILITY_OSK_INPUTTYPE_ALL =						0x00000000,
+	PSP_UTILITY_OSK_INPUTTYPE_LATIN_DIGIT =				0x00000001,
+	PSP_UTILITY_OSK_INPUTTYPE_LATIN_SYMBOL =			0x00000002,
+	PSP_UTILITY_OSK_INPUTTYPE_LATIN_LOWERCASE =			0x00000004,
+	PSP_UTILITY_OSK_INPUTTYPE_LATIN_UPPERCASE =			0x00000008,
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_DIGIT =			0x00000100,
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_SYMBOL =			0x00000200,
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_LOWERCASE =		0x00000400,
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_UPPERCASE =		0x00000800,
+	// http://en.wikipedia.org/wiki/Hiragana
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_HIRAGANA =		0x00001000,
+	// http://en.wikipedia.org/wiki/Katakana
+	// Half-width Katakana
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_HALF_KATAKANA =	0x00002000,
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_KATAKANA =		0x00004000,
+	// http://en.wikipedia.org/wiki/Kanji
+	PSP_UTILITY_OSK_INPUTTYPE_JAPANESE_KANJI =			0x00008000,
+	PSP_UTILITY_OSK_INPUTTYPE_RUSSIAN_LOWERCASE =		0x00010000,
+	PSP_UTILITY_OSK_INPUTTYPE_RUSSIAN_UPPERCASE =		0x00020000,
+	PSP_UTILITY_OSK_INPUTTYPE_KOREAN =					0x00040000,
+	PSP_UTILITY_OSK_INPUTTYPE_URL =						0x00080000
+};
+
+/**
+ * OSK Field data
+ */
+typedef struct _SceUtilityOskData
+{
+    /** Unknown. Pass 0. */
+	int unk_00;
+	/** Unknown. Pass 0. */
+    int unk_04;
+	/** One of ::SceUtilityOskInputLanguage */
+    int language;
+	/** Unknown. Pass 0. */
+    int unk_12;
+	/** One or more of ::SceUtilityOskInputType (types that are selectable by pressing SELECT) */
+    int inputtype;
+	/** Number of lines */
+    int lines;
+	/** Unknown. Pass 0. */
+    int unk_24;
+	/** Description text */
+    unsigned short* desc;
+	/** Initial text */
+    unsigned short* intext;
+	/** Length of output text */
+    int outtextlength;
+	/** Pointer to the output text */
+    unsigned short* outtext;
+	/** Result. One of ::SceUtilityOskResult */
+    int result;
+	/** The max text that can be input */
+    int outtextlimit;
+	
+} SceUtilityOskData;
+
+/**
+ * OSK parameters
+ */
+typedef struct _SceUtilityOskParams
+{
+	pspUtilityDialogCommon base;
+	/** Number of input fields */
+	int datacount;
+	/** Pointer to the start of the data for the input fields */
+	SceUtilityOskData* data;
+	/** The local OSK state, one of ::SceUtilityOskState */
+	int state;
+	/** Unknown. Pass 0 */
+	int unk_60;
+	
+} SceUtilityOskParams;
+
+/**
+ * Create an on-screen keyboard
+ *
+ * @param params - OSK parameters.
+ *
+ * @return < 0 on error.
+ */
+int sceUtilityOskInitStart(SceUtilityOskParams* params);
+
+/**
+ * Remove a currently active keyboard. After calling this function you must
+ *
+ * poll sceUtilityOskGetStatus() until it returns PSP_UTILITY_DIALOG_NONE.
+ *
+ * @return < 0 on error.
+ */
+int sceUtilityOskShutdownStart(void);
+
+/**
+ * Refresh the GUI for a keyboard currently active
+ *
+ * @param n - Unknown, pass 1.
+ *
+ * @return < 0 on error.
+ */
+int sceUtilityOskUpdate(int n);
+
+/**
+ * Get the status of a on-screen keyboard currently active.
+ *
+ * @return the current status of the keyboard. See ::pspUtilityDialogState for details.
+ */
+int sceUtilityOskGetStatus(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_savedata.h b/newlib/psp/include/psputility_savedata.h
new file mode 100644
index 0000000..3d4ff03
--- /dev/null
+++ b/newlib/psp/include/psputility_savedata.h
@@ -0,0 +1,182 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_savedata.h - Definitions and Functions for savedata part of
+ *                     pspUtility library
+ *
+ * Copyright (c) 2005    Shine
+ *                       weltall <weltall@consoleworld.org>
+ *                       Marcus R. Brown <mrbrown@ocgnet.org>
+ *						 InsertWittyName <tias_dp@hotmail.com>
+ *
+ */
+
+#ifndef __PSPUTILITY_SAVEDATA_H__
+#define __PSPUTILITY_SAVEDATA_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Save data utility modes */
+typedef enum
+{
+	PSP_UTILITY_SAVEDATA_AUTOLOAD = 0,
+	PSP_UTILITY_SAVEDATA_AUTOSAVE,
+	PSP_UTILITY_SAVEDATA_LOAD,
+	PSP_UTILITY_SAVEDATA_SAVE,
+	PSP_UTILITY_SAVEDATA_LISTLOAD,
+	PSP_UTILITY_SAVEDATA_LISTSAVE,
+	PSP_UTILITY_SAVEDATA_LISTDELETE,
+	PSP_UTILITY_SAVEDATADELETE,
+
+} PspUtilitySavedataMode;
+
+/** Initial focus position for list selection types */
+typedef enum
+{
+	PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN = 0,
+	PSP_UTILITY_SAVEDATA_FOCUS_FIRSTLIST,	/* First in list */
+	PSP_UTILITY_SAVEDATA_FOCUS_LASTLIST,	/* Last in list */
+	PSP_UTILITY_SAVEDATA_FOCUS_LATEST,	/* Most recent date */
+	PSP_UTILITY_SAVEDATA_FOCUS_OLDEST,	/* Oldest date */
+	PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN2,
+	PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN3,
+	PSP_UTILITY_SAVEDATA_FOCUS_FIRSTEMPTY, /* First empty slot */
+	PSP_UTILITY_SAVEDATA_FOCUS_LASTEMPTY,	/*Last empty slot */
+	
+} PspUtilitySavedataFocus;
+
+
+/** title, savedataTitle, detail: parts of the unencrypted SFO
+    data, it contains what the VSH and standard load screen shows */
+typedef struct PspUtilitySavedataSFOParam
+{
+	char title[0x80];
+	char savedataTitle[0x80];
+	char detail[0x400];
+	unsigned char parentalLevel;
+	unsigned char unknown[3];
+	
+} PspUtilitySavedataSFOParam;
+
+typedef struct PspUtilitySavedataFileData {
+	void *buf;
+	SceSize bufSize;
+	SceSize size;	/* ??? - why are there two sizes? */
+	int unknown;
+	
+} PspUtilitySavedataFileData;
+
+typedef struct PspUtilitySavedataListSaveNewData
+{
+	PspUtilitySavedataFileData icon0;
+	char *title;
+	
+} PspUtilitySavedataListSaveNewData;
+
+/** Structure to hold the parameters for the ::sceUtilitySavedataInitStart function. */
+typedef struct SceUtilitySavedataParam
+{
+	pspUtilityDialogCommon base;
+
+	PspUtilitySavedataMode mode;
+	
+	int unknown1;
+	
+	int overwrite;
+
+	/** gameName: name used from the game for saves, equal for all saves */
+	char gameName[13];
+	char reserved[3];
+	/** saveName: name of the particular save, normally a number */
+	char saveName[20];
+
+	/** saveNameList: used by multiple modes */
+	char (*saveNameList)[20];
+
+	/** fileName: name of the data file of the game for example DATA.BIN */
+	char fileName[13];
+	char reserved1[3];
+
+	/** pointer to a buffer that will contain data file unencrypted data */
+	void *dataBuf;
+	/** size of allocated space to dataBuf */
+	SceSize dataBufSize;
+	SceSize dataSize;
+
+	PspUtilitySavedataSFOParam sfoParam;
+
+	PspUtilitySavedataFileData icon0FileData;
+	PspUtilitySavedataFileData icon1FileData;
+	PspUtilitySavedataFileData pic1FileData;
+	PspUtilitySavedataFileData snd0FileData;
+
+	/** Pointer to an PspUtilitySavedataListSaveNewData structure */
+	PspUtilitySavedataListSaveNewData *newData;
+
+	/** Initial focus for lists */
+	PspUtilitySavedataFocus focus;
+
+	/** unknown2: ? */
+	int unknown2[4];
+
+#if _PSP_FW_VERSION >= 200
+
+	/** key: encrypt/decrypt key for save with firmware >= 2.00 */
+	char key[16];
+
+	/** unknown3: ? */
+	char unknown3[20];
+
+#endif
+
+} SceUtilitySavedataParam;
+
+
+/**
+ * Saves or Load savedata to/from the passed structure
+ * After having called this continue calling sceUtilitySavedataGetStatus to
+ * check if the operation is completed
+ *
+ * @param params - savedata parameters
+ * @return 0 on success
+ */
+int sceUtilitySavedataInitStart(SceUtilitySavedataParam * params);
+
+/**
+ * Check the current status of the saving/loading/shutdown process
+ * Continue calling this to check current status of the process
+ * before calling this call also sceUtilitySavedataUpdate
+ * @return 2 if the process is still being processed.
+ * 3 on save/load success, then you can call sceUtilitySavedataShutdownStart.
+ * 4 on complete shutdown.
+ */
+int sceUtilitySavedataGetStatus(void);
+
+
+/**
+ * Shutdown the savedata utility. after calling this continue calling
+ * ::sceUtilitySavedataGetStatus to check when it has shutdown
+ *
+ * @return 0 on success
+ *
+ */
+int sceUtilitySavedataShutdownStart(void);
+
+/**
+ * Refresh status of the savedata function
+ *
+ * @param unknown - unknown, pass 1
+ */
+void sceUtilitySavedataUpdate(int unknown);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_sysparam.h b/newlib/psp/include/psputility_sysparam.h
new file mode 100644
index 0000000..84f2465
--- /dev/null
+++ b/newlib/psp/include/psputility_sysparam.h
@@ -0,0 +1,140 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ *  psputility_sysparam.h - Definitions and Functions for System Paramters 
+ *                          section of the pspUtility library
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPUTILITY_SYSPARAM_H__
+#define __PSPUTILITY_SYSPARAM_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+/**
+ * IDs for use inSystemParam functions
+ * PSP_SYSTEMPARAM_ID_INT are for use with SystemParamInt funcs
+ * PSP_SYSTEMPARAM_ID_STRING are for use with SystemParamString funcs
+ */
+#define PSP_SYSTEMPARAM_ID_STRING_NICKNAME	1
+#define PSP_SYSTEMPARAM_ID_INT_ADHOC_CHANNEL	2
+#define PSP_SYSTEMPARAM_ID_INT_WLAN_POWERSAVE	3
+#define PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT	4
+#define PSP_SYSTEMPARAM_ID_INT_TIME_FORMAT	5
+//Timezone offset from UTC in minutes, (EST = -300 = -5 * 60)
+#define PSP_SYSTEMPARAM_ID_INT_TIMEZONE		6
+#define PSP_SYSTEMPARAM_ID_INT_DAYLIGHTSAVINGS	7
+#define PSP_SYSTEMPARAM_ID_INT_LANGUAGE		8
+/**
+ * #9 seems to be Region or maybe X/O button swap.
+ * It doesn't exist on JAP v1.0
+ * is 1 on NA v1.5s
+ * is 0 on JAP v1.5s
+ * is read-only
+ */
+#define PSP_SYSTEMPARAM_ID_INT_UNKNOWN		9
+
+/**
+ * Return values for the SystemParam functions
+ */
+#define PSP_SYSTEMPARAM_RETVAL_OK	0
+#define PSP_SYSTEMPARAM_RETVAL_FAIL	0x80110103
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_ADHOC_CHANNEL
+ */
+#define PSP_SYSTEMPARAM_ADHOC_CHANNEL_AUTOMATIC 0
+#define PSP_SYSTEMPARAM_ADHOC_CHANNEL_1		1
+#define PSP_SYSTEMPARAM_ADHOC_CHANNEL_6		6
+#define PSP_SYSTEMPARAM_ADHOC_CHANNEL_11	11
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_WLAN_POWERSAVE
+ */
+#define PSP_SYSTEMPARAM_WLAN_POWERSAVE_OFF	0
+#define PSP_SYSTEMPARAM_WLAN_POWERSAVE_ON	1
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_DATE_FORMAT
+ */
+#define PSP_SYSTEMPARAM_DATE_FORMAT_YYYYMMDD	0
+#define PSP_SYSTEMPARAM_DATE_FORMAT_MMDDYYYY	1
+#define PSP_SYSTEMPARAM_DATE_FORMAT_DDMMYYYY	2
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_TIME_FORMAT
+ */
+#define PSP_SYSTEMPARAM_TIME_FORMAT_24HR	0
+#define PSP_SYSTEMPARAM_TIME_FORMAT_12HR	1
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_DAYLIGHTSAVINGS
+ */
+#define PSP_SYSTEMPARAM_DAYLIGHTSAVINGS_STD	0
+#define PSP_SYSTEMPARAM_DAYLIGHTSAVINGS_SAVING	1
+
+/**
+ * Valid values for PSP_SYSTEMPARAM_ID_INT_LANGUAGE
+ */
+#define PSP_SYSTEMPARAM_LANGUAGE_JAPANESE		0
+#define PSP_SYSTEMPARAM_LANGUAGE_ENGLISH		1
+#define PSP_SYSTEMPARAM_LANGUAGE_FRENCH			2
+#define PSP_SYSTEMPARAM_LANGUAGE_SPANISH		3
+#define PSP_SYSTEMPARAM_LANGUAGE_GERMAN			4
+#define PSP_SYSTEMPARAM_LANGUAGE_ITALIAN		5
+#define PSP_SYSTEMPARAM_LANGUAGE_DUTCH			6
+#define PSP_SYSTEMPARAM_LANGUAGE_PORTUGUESE		7
+#define PSP_SYSTEMPARAM_LANGUAGE_RUSSIAN		8
+#define PSP_SYSTEMPARAM_LANGUAGE_KOREAN			9
+#define PSP_SYSTEMPARAM_LANGUAGE_CHINESE_TRADITIONAL	10
+#define PSP_SYSTEMPARAM_LANGUAGE_CHINESE_SIMPLIFIED	11
+
+/**
+ * Set Integer System Parameter
+ *
+ * @param id - which parameter to set
+ * @param value - integer value to set
+ * @return 0 on success, PSP_SYSTEMPARAM_RETVAL_FAIL on failure
+ */
+int sceUtilitySetSystemParamInt(int id, int value);
+
+/**
+ * Set String System Parameter
+ *
+ * @param id - which parameter to set
+ * @param str - char * value to set
+ * @return 0 on success, PSP_SYSTEMPARAM_RETVAL_FAIL on failure
+ */
+int sceUtilitySetSystemParamString(int id, const char *str);
+
+/**
+ * Get Integer System Parameter
+ *
+ * @param id - which parameter to get
+ * @param value - pointer to integer value to place result in
+ * @return 0 on success, PSP_SYSTEMPARAM_RETVAL_FAIL on failure
+ */
+int sceUtilityGetSystemParamInt( int id, int *value );
+
+/**
+ * Get String System Parameter
+ *
+ * @param id - which parameter to get
+ * @param str - char * buffer to place result in
+ * @param len - length of str buffer
+ * @return 0 on success, PSP_SYSTEMPARAM_RETVAL_FAIL on failure
+ */
+int sceUtilityGetSystemParamString(int id, char *str, int len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputility_usbmodules.h b/newlib/psp/include/psputility_usbmodules.h
new file mode 100644
index 0000000..cae5aaf
--- /dev/null
+++ b/newlib/psp/include/psputility_usbmodules.h
@@ -0,0 +1,48 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputility_usbmodules.h - Load usb modules from user mode on 2.70 and higher
+ *
+ * Copyright (c) 2007 David Perry <tias_dp@hotmail.com>
+ *
+ */
+#ifndef __PSPUTILITY_USBMODULES_H__
+#define __PSPUTILITY_USBMODULES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <psptypes.h>
+
+#define PSP_USB_MODULE_PSPCM	1
+#define PSP_USB_MODULE_ACC	2
+#define PSP_USB_MODULE_MIC	3 // Requires PSP_USB_MODULE_ACC loading first
+#define PSP_USB_MODULE_CAM	4 // Requires PSP_USB_MODULE_ACC loading first
+#define PSP_USB_MODULE_GPS	5 // Requires PSP_USB_MODULE_ACC loading first
+
+/**
+ * Load a usb module (PRX) from user mode.
+ * Available on firmware 2.70 and higher only.
+ *
+ * @param module - module number to load (PSP_USB_MODULE_xxx)
+ * @return 0 on success, < 0 on error
+*/
+int sceUtilityLoadUsbModule(int module);
+
+/**
+ * Unload a usb module (PRX) from user mode.
+ * Available on firmware 2.70 and higher only.
+ *
+ * @param module - module number to be unloaded
+ * @return 0 on success, < 0 on error
+*/
+int sceUtilityUnloadUsbModule(int module);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputils.h b/newlib/psp/include/psputils.h
new file mode 100644
index 0000000..3f77f33
--- /dev/null
+++ b/newlib/psp/include/psputils.h
@@ -0,0 +1,248 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputils.h - Prototypes for the sceUtils library.
+ *
+ * Copyright (c) 2005 Marcus R. Brown <mrbrown@ocgnet.org>
+ * Copyright (c) 2005 James Forshaw <tyranid@gmail.com>
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __UTILS_H__
+#define __UTILS_H__
+
+#include <psptypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Some of the structures and definitions in this file were extracted from the japanese
+   puzzle bobble main executable */
+
+/** @defgroup Utils Utils Library */
+
+/** @addtogroup Utils */
+
+/**@{*/
+
+#include <sys/time.h>
+
+/** 
+ *  This struct is needed because tv_sec size is different from what newlib expect
+ * Newlib expects 64bits for seconds and PSP expects 32bits
+ */
+typedef struct SceKernelTimeval {
+	uint32_t tv_sec;
+	uint32_t tv_usec;
+} SceKernelTimeval;
+
+/**
+  * Get the time in seconds since the epoc (1st Jan 1970)
+  *
+  */
+time_t sceKernelLibcTime(time_t *t);
+
+/**
+  * Get the processor clock used since the start of the process
+  */
+clock_t sceKernelLibcClock(void);
+
+/**
+  * Get the current time of time and time zone information
+  */
+int sceKernelLibcGettimeofday(struct SceKernelTimeval *tp, struct timezone *tzp);
+
+/**
+  * Write back the data cache to memory
+  */
+void sceKernelDcacheWritebackAll(void);
+
+/**
+  * Write back and invalidate the data cache
+  */
+void sceKernelDcacheWritebackInvalidateAll(void);
+
+/**
+  * Write back a range of addresses from the data cache to memory
+  */
+void sceKernelDcacheWritebackRange(const void *p, unsigned int size);
+
+/**
+  * Write back and invalidate a range of addresses in the data cache
+  */
+void sceKernelDcacheWritebackInvalidateRange(const void *p, unsigned int size);
+
+/**
+  * Invalidate a range of addresses in data cache
+  */
+void sceKernelDcacheInvalidateRange(const void *p, unsigned int size);
+
+/**
+  * Invalidate the instruction cache
+  */
+void sceKernelIcacheInvalidateAll(void);
+
+/**
+  * Invalidate a range of addresses in the instruction cache
+  */
+void sceKernelIcacheInvalidateRange(const void *p, unsigned int size);
+
+/** Structure for holding a mersenne twister context */
+typedef struct _SceKernelUtilsMt19937Context {
+	unsigned int 	count;
+	unsigned int 	state[624];
+} SceKernelUtilsMt19937Context;
+
+/**
+  * Function to initialise a mersenne twister context.
+  *
+  * @param ctx - Pointer to a context
+  * @param seed - A seed for the random function.
+  *
+  * @par Example:
+  * @code
+  * SceKernelUtilsMt19937Context ctx;
+  * sceKernelUtilsMt19937Init(&ctx, time(NULL));
+  * u23 rand_val = sceKernelUtilsMt19937UInt(&ctx);
+  * @endcode
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsMt19937Init(SceKernelUtilsMt19937Context *ctx, u32 seed);
+
+/**
+  * Function to return a new psuedo random number.
+  *
+  * @param ctx - Pointer to a pre-initialised context.
+  * @return A pseudo random number (between 0 and MAX_INT).
+  */
+u32 sceKernelUtilsMt19937UInt(SceKernelUtilsMt19937Context *ctx);
+
+/** Structure to hold the MD5 context */
+typedef struct _SceKernelUtilsMd5Context {
+	unsigned int 	h[4];
+	unsigned int 	pad;
+	SceUShort16 	usRemains;
+	SceUShort16 	usComputed;
+	SceULong64 	ullTotalLen;
+	unsigned char 	buf[64];
+} SceKernelUtilsMd5Context;
+
+/**
+  * Function to perform an MD5 digest of a data block.
+  *
+  * @param data - Pointer to a data block to make a digest of.
+  * @param size - Size of the data block.
+  * @param digest - Pointer to a 16byte buffer to store the resulting digest
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsMd5Digest(u8 *data, u32 size, u8 *digest);
+
+/**
+  * Function to initialise a MD5 digest context
+  *
+  * @param ctx - A context block to initialise
+  *
+  * @return < 0 on error.
+  * @par Example:
+  * @code
+  * SceKernelUtilsMd5Context ctx;
+  * u8 digest[16];
+  * sceKernelUtilsMd5BlockInit(&ctx);
+  * sceKernelUtilsMd5BlockUpdate(&ctx, (u8*) "Hello", 5);
+  * sceKernelUtilsMd5BlockResult(&ctx, digest);
+  * @endcode
+  */
+int sceKernelUtilsMd5BlockInit(SceKernelUtilsMd5Context *ctx);
+
+/**
+  * Function to update the MD5 digest with a block of data.
+  *
+  * @param ctx - A filled in context block.
+  * @param data - The data block to hash.
+  * @param size - The size of the data to hash
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsMd5BlockUpdate(SceKernelUtilsMd5Context *ctx, u8 *data, u32 size);
+
+/**
+  * Function to get the digest result of the MD5 hash.
+  *
+  * @param ctx - A filled in context block.
+  * @param digest - A 16 byte array to hold the digest.
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsMd5BlockResult(SceKernelUtilsMd5Context *ctx, u8 *digest);
+
+/** Type to hold a sha1 context */
+typedef struct _SceKernelUtilsSha1Context {
+	unsigned int 	h[5];
+	SceUShort16 	usRemains;
+	SceUShort16 	usComputed;
+	SceULong64 	ullTotalLen;
+	unsigned char 	buf[64];
+} SceKernelUtilsSha1Context;
+
+/**
+  * Function to SHA1 hash a data block.
+  *
+  * @param data - The data to hash.
+  * @param size - The size of the data.
+  * @param digest - Pointer to a 20 byte array for storing the digest
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsSha1Digest(u8 *data, u32 size, u8 *digest);
+
+/**
+  * Function to initialise a context for SHA1 hashing.
+  *
+  * @param ctx - Pointer to a context.
+  *
+  * @return < 0 on error.
+  *
+  * @par Example:
+  * @code
+  * SceKernelUtilsSha1Context ctx;
+  * u8 digest[20];
+  * sceKernelUtilsSha1BlockInit(&ctx);
+  * sceKernelUtilsSha1BlockUpdate(&ctx, (u8*) "Hello", 5);
+  * sceKernelUtilsSha1BlockResult(&ctx, digest);
+  * @endcode
+  */
+int sceKernelUtilsSha1BlockInit(SceKernelUtilsSha1Context *ctx);
+
+/**
+  * Function to update the current hash.
+  *
+  * @param ctx - Pointer to a prefilled context.
+  * @param data - The data block to hash.
+  * @param size - The size of the data block
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsSha1BlockUpdate(SceKernelUtilsSha1Context *ctx, u8 *data, u32 size);
+
+/**
+  * Function to get the result of the SHA1 hash.
+  *
+  * @param ctx - Pointer to a prefilled context.
+  * @param digest - A pointer to a 20 byte array to contain the digest.
+  *
+  * @return < 0 on error.
+  */
+int sceKernelUtilsSha1BlockResult(SceKernelUtilsSha1Context *ctx, u8 *digest);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/psputilsforkernel.h b/newlib/psp/include/psputilsforkernel.h
new file mode 100644
index 0000000..4063c02
--- /dev/null
+++ b/newlib/psp/include/psputilsforkernel.h
@@ -0,0 +1,79 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * psputilsforkernel.h - Include file for UtilsForKernel
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ * Copyright (c) 2005 adresd
+ *
+ */
+
+#ifndef __PSPUTILSFORKERNEL_H__
+#define __PSPUTILSFORKERNEL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Decompress gzip'd data (requires kernel mode)
+ *
+ * @param dest - pointer to destination buffer
+ * @param destSize - size of destination buffer
+ * @param src - pointer to source (compressed) data
+ * @param unknown - unknown, pass NULL
+ * @return size decompressed on success, < 0 on error
+ */
+int sceKernelGzipDecompress(u8 *dest, u32 destSize, const u8 *src, u32 unknown);
+
+/**
+ * Decompress deflate'd data (requires kernel mode)
+ *
+ * @param dest - pointer to destination buffer
+ * @param destSize - size of destination buffer
+ * @param src - pointer to source (compressed) data
+ * @param unknown - unknown, pass NULL
+ * @return size decompressed on success, < 0 on error
+ */
+int sceKernelDeflateDecompress(u8 *dest, u32 destSize, const u8 *src, u32 unknown);
+
+/**
+ * Invalidate the entire data cache
+ */ 
+void sceKernelDcacheInvalidateAll(void);
+
+/**
+ * Check whether the specified address is in the data cache
+ * @param addr - The address to check
+ *
+ * @return 0 = not cached, 1 = cache
+ */
+int  sceKernelDcacheProbe(void *addr);
+
+/**
+ * Invalidate the entire instruction cache
+ */
+void sceKernelIcacheInvalidateAll(void);
+
+/**
+ * Invalidate a instruction cache range.
+ * @param addr - The start address of the range.
+ * @param size - The size in bytes
+ */
+void sceKernelIcacheInvalidateRange(const void *addr, unsigned int size);
+
+/**
+ * Check whether the specified address is in the instruction cache
+ * @param addr - The address to check
+ *
+ * @return 0 = not cached, 1 = cache
+ */
+int  sceKernelIcacheProbe(const void *addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/pspvfpu.h b/newlib/psp/include/pspvfpu.h
new file mode 100644
index 0000000..6b81393
--- /dev/null
+++ b/newlib/psp/include/pspvfpu.h
@@ -0,0 +1,75 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspvfpu.h - Prototypes for the VFPU library
+ *
+ * Copyright (c) 2005 Jeremy Fitzhardinge <jeremy@goop.org>
+ *
+ */
+#ifndef __PSPVFPU_H__
+#define __PSPVFPU_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pspvfpu_context;
+typedef unsigned char vfpumatrixset_t;
+
+#define VMAT0	(1<<0)
+#define VMAT1	(1<<1)
+#define VMAT2	(1<<2)
+#define VMAT3	(1<<3)
+#define VMAT4	(1<<4)
+#define VMAT5	(1<<5)
+#define VMAT6	(1<<6)
+#define VMAT7	(1<<7)
+
+#define VFPU_ALIGNMENT	(sizeof(float) * 4)	/* alignment required for VFPU matrix loads and stores */
+
+/**
+   Prepare to use the VFPU.  This set's the calling thread's VFPU
+   attribute, and returns a pointer to some VFPU state storage.
+   The initial value all all VFPU matrix registers is undefined.
+
+   @return A VFPU context
+ */
+struct pspvfpu_context *pspvfpu_initcontext(void);
+
+/**
+   Delete a VFPU context.  This frees the resources used by the VFPU
+   context.
+
+   @param context The VFPU context to be deleted.
+ */
+void pspvfpu_deletecontext(struct pspvfpu_context *context);
+
+/**
+   Use a set of VFPU matrices.  This restores the parts of the VFPU
+   state the caller wants restored (if necessary).  If the caller was
+   the previous user of the the matrix set, then this call is
+   effectively a no-op.  If a matrix has never been used by this
+   context before, then it will initially have an undefined value.
+
+   @param context The VFPU context the caller wants to restore
+   from. It is valid to pass NULL as a context.  This means the caller
+   wants to reserve a temporary matrix without affecting other VFPU
+   users, but doesn't want any long-term matrices itself.
+
+   @param keepset The set of matrices the caller wants to use, and
+   keep the values persistently.  
+
+   @param tempset A set of matrices the callers wants to use
+   temporarily, but doesn't care about the values in the long-term.
+ */
+void pspvfpu_use_matrices(struct pspvfpu_context *context, 
+			  vfpumatrixset_t keepset, vfpumatrixset_t tempset);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __PSPVFPU_H__ */
diff --git a/newlib/psp/include/pspvideocodec.h b/newlib/psp/include/pspvideocodec.h
new file mode 100644
index 0000000..eb1f180
--- /dev/null
+++ b/newlib/psp/include/pspvideocodec.h
@@ -0,0 +1,35 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspvideocodec.h - Prototypes for the sceVideocodec library.
+ *
+ * Copyright (c) 2007 cooleyes
+ *
+ */
+ 
+#ifndef __SCELIBVIDEOCODEC_H__
+#define __SCELIBVIDEOCODEC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int sceVideocodecOpen(unsigned long *Buffer, int Type);
+int sceVideocodecGetEDRAM(unsigned long *Buffer, int Type);
+int sceVideocodecInit(unsigned long *Buffer, int Type);
+int sceVideocodecDecode(unsigned long *Buffer, int Type);
+int sceVideocodecReleaseEDRAM(unsigned long *Buffer);
+
+// sceVideocodecGetVersion
+// sceVideocodecScanHeader
+// sceVideocodecDelete
+// sceVideocodecSetMemory
+// sceVideocodecStop
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/newlib/psp/include/pspwlan.h b/newlib/psp/include/pspwlan.h
new file mode 100644
index 0000000..6ba984f
--- /dev/null
+++ b/newlib/psp/include/pspwlan.h
@@ -0,0 +1,63 @@
+/*
+ * PSP Software Development Kit - https://github.com/pspdev
+ * -----------------------------------------------------------------------
+ * Licensed under the BSD license, see LICENSE in PSPSDK root for details.
+ *
+ * pspwlan.h - Prototypes for the sceWlan library
+ *
+ * Copyright (c) 2005 John Kelley <ps2dev@kelley.ca>
+ *
+ */
+#ifndef __PSPWLAN_H__
+#define __PSPWLAN_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Determine if the wlan device is currently powered on
+ *
+ * @return 0 if off, 1 if on
+ */
+int sceWlanDevIsPowerOn(void);
+
+/**
+ * Determine the state of the Wlan power switch
+ *
+ * @return 0 if off, 1 if on
+ */
+int sceWlanGetSwitchState(void);
+
+/**
+ * Get the Ethernet Address of the wlan controller
+ *
+ * @param etherAddr - pointer to a buffer of u8 (NOTE: it only writes to 6 bytes, but 
+ * requests 8 so pass it 8 bytes just in case)
+ * @return 0 on success, < 0 on error
+ */
+int sceWlanGetEtherAddr(u8 *etherAddr);
+
+/**
+ * Attach to the wlan device
+ *
+ * @return 0 on success, < 0 on error.
+ */
+int sceWlanDevAttach(void);
+
+/**
+ * Detach from the wlan device
+ *
+ * @return 0 on success, < 0 on error/
+ */
+int sceWlanDevDetach(void);
+
+/*
+int sceWlanGPBindRegError();
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/newlib/psp/include/sys/ioctl.h b/newlib/psp/include/sys/ioctl.h
new file mode 100644
index 0000000..0465938
--- /dev/null
+++ b/newlib/psp/include/sys/ioctl.h
@@ -0,0 +1 @@
+/* Empty file, here for compatibility */
\ No newline at end of file
diff --git a/newlib/psp/include/sys/socket.h b/newlib/psp/include/sys/socket.h
new file mode 100644
index 0000000..aa1036c
--- /dev/null
+++ b/newlib/psp/include/sys/socket.h
@@ -0,0 +1,279 @@
+/*	$NetBSD: socket.h,v 1.77 2005/11/29 03:12:16 christos Exp $	*/
+
+/*
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)socket.h	8.6 (Berkeley) 5/3/95
+ */
+
+#ifndef _SYS_SOCKET_H_
+#define	_SYS_SOCKET_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+#include <sys/types.h>
+
+typedef uint8_t sa_family_t;
+typedef uint32_t socklen_t;
+
+/*
+ * Socket types.
+ */
+#define	SOCK_STREAM	1		/* stream socket */
+#define	SOCK_DGRAM	2		/* datagram socket */
+#define	SOCK_RAW	3		/* raw-protocol interface */
+#define	SOCK_RDM	4		/* reliably-delivered message */
+#define	SOCK_SEQPACKET	5		/* sequenced packet stream */
+
+/*
+ * Option flags per-socket.
+ */
+#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
+#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
+#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
+#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
+#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
+#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
+#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
+#define	SO_LINGER	0x0080		/* linger on close if data present */
+#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
+#define	SO_REUSEPORT	0x0200		/* allow local address & port reuse */
+#define	SO_TIMESTAMP	0x0400		/* timestamp received dgram traffic */
+
+/*
+ * Additional options, not kept in so_options.
+ */
+#define SO_SNDBUF	0x1001		/* send buffer size */
+#define SO_RCVBUF	0x1002		/* receive buffer size */
+#define SO_SNDLOWAT	0x1003		/* send low-water mark */
+#define SO_RCVLOWAT	0x1004		/* receive low-water mark */
+#define SO_SNDTIMEO	0x1005		/* send timeout */
+#define SO_RCVTIMEO	0x1006		/* receive timeout */
+#define	SO_ERROR	0x1007		/* get error status and clear */
+#define	SO_TYPE		0x1008		/* get socket type */
+#define	SO_OVERFLOWED	0x1009		/* datagrams: return packets dropped */
+#define	SO_NONBLOCK     0x1009		/* non-blocking I/O */
+
+/*
+ * Structure used for manipulating linger option.
+ */
+struct	linger {
+	int	l_onoff;		/* option on/off */
+	int	l_linger;		/* linger time in seconds */
+};
+
+/*
+ * Level number for (get/set)sockopt() to apply to socket itself.
+ */
+#define	SOL_SOCKET	0xffff		/* options for socket level */
+
+/*
+ * Address families.
+ */
+#define	AF_UNSPEC	0		/* unspecified */
+#define	AF_LOCAL	1		/* local to host (pipes, portals) */
+#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
+#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
+#define	AF_IMPLINK	3		/* arpanet imp addresses */
+#define	AF_PUP		4		/* pup protocols: e.g. BSP */
+#define	AF_CHAOS	5		/* mit CHAOS protocols */
+#define	AF_NS		6		/* XEROX NS protocols */
+#define	AF_ISO		7		/* ISO protocols */
+#define	AF_OSI		AF_ISO
+#define	AF_ECMA		8		/* european computer manufacturers */
+#define	AF_DATAKIT	9		/* datakit protocols */
+#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
+#define	AF_SNA		11		/* IBM SNA */
+#define AF_DECnet	12		/* DECnet */
+#define AF_DLI		13		/* DEC Direct data link interface */
+#define AF_LAT		14		/* LAT */
+#define	AF_HYLINK	15		/* NSC Hyperchannel */
+#define	AF_APPLETALK	16		/* Apple Talk */
+#define	AF_ROUTE	17		/* Internal Routing Protocol */
+#define	AF_LINK		18		/* Link layer interface */
+#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
+#define	AF_CNT		21		/* Computer Network Technology */
+#define	AF_IPX		23		/* Novell Internet Protocol */
+#define	AF_INET6	24		/* IP version 6 */
+#define AF_ISDN		26		/* Integrated Services Digital Network*/
+#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
+#define AF_NATM		27		/* native ATM access */
+#define AF_ARP		28		/* (rev.) addr. res. prot. (RFC 826) */
+#define	AF_MAX		31
+
+/*
+ * Structure used by kernel to store most
+ * addresses.
+ */
+struct sockaddr {
+	uint8_t	sa_len;		/* total length */
+	sa_family_t	sa_family;	/* address family */
+	char		sa_data[14];	/* actually longer; address value */
+};
+
+/*
+ * Protocol families, same as address families for now.
+ */
+#define	PF_UNSPEC	AF_UNSPEC
+#define	PF_LOCAL	AF_LOCAL
+#define	PF_UNIX		PF_LOCAL	/* backward compatibility */
+#define	PF_INET		AF_INET
+#define	PF_IMPLINK	AF_IMPLINK
+#define	PF_PUP		AF_PUP
+#define	PF_CHAOS	AF_CHAOS
+#define	PF_NS		AF_NS
+#define	PF_ISO		AF_ISO
+#define	PF_OSI		AF_ISO
+#define	PF_ECMA		AF_ECMA
+#define	PF_DATAKIT	AF_DATAKIT
+#define	PF_CCITT	AF_CCITT
+#define	PF_SNA		AF_SNA
+#define PF_DECnet	AF_DECnet
+#define PF_DLI		AF_DLI
+#define PF_LAT		AF_LAT
+#define	PF_HYLINK	AF_HYLINK
+#define	PF_APPLETALK	AF_APPLETALK
+#define	PF_ROUTE	AF_ROUTE
+#define	PF_LINK		AF_LINK
+#if defined(_NETBSD_SOURCE)
+#define	PF_XTP		pseudo_AF_XTP	/* really just proto family, no AF */
+#endif
+#define	PF_COIP		AF_COIP
+#define	PF_CNT		AF_CNT
+#define	PF_INET6	AF_INET6
+#define	PF_IPX		AF_IPX		/* same format as AF_NS */
+#if defined(_NETBSD_SOURCE)
+#define PF_RTIP		pseudo_AF_RTIP	/* same format as AF_INET */
+#define PF_PIP		pseudo_AF_PIP
+#endif
+#define PF_ISDN		AF_ISDN		/* same as E164 */
+#define PF_E164		AF_E164
+#define PF_NATM		AF_NATM
+#define PF_ARP		AF_ARP
+#if defined(_NETBSD_SOURCE)
+#define PF_KEY 		pseudo_AF_KEY	/* like PF_ROUTE, only for key mgmt */
+#endif
+
+#define	PF_MAX		AF_MAX
+
+#define	MSG_OOB		0x1		/* process out-of-band data */
+#define	MSG_PEEK	0x2		/* peek at incoming message */
+#define	MSG_DONTROUTE	0x4		/* send without using routing tables */
+#define	MSG_EOR		0x8		/* data completes record */
+#define	MSG_TRUNC	0x10		/* data discarded before delivery */
+#define	MSG_CTRUNC	0x20		/* control data lost before delivery */
+#define	MSG_WAITALL	0x40		/* wait for full request or error */
+#define	MSG_DONTWAIT	0x80		/* this message should be nonblocking */
+#define	MSG_BCAST	0x100		/* this message was rcvd using link-level brdcst */
+#define	MSG_MCAST	0x200		/* this message was rcvd using link-level mcast */
+
+/*
+ * Types of socket shutdown(2).
+ */
+#define	SHUT_RD		0		/* Disallow further receives. */
+#define	SHUT_WR		1		/* Disallow further sends. */
+#define	SHUT_RDWR	2		/* Disallow further sends/receives. */
+
+struct iovec {
+	void	*iov_base;	/* Base address. */
+	size_t	 iov_len;	/* Length. */
+};
+
+/*
+ * Maximum queue length specifiable by listen.
+ */
+#define SOMAXCONN       128
+
+struct msghdr {
+	void		*msg_name;	/* optional address */
+	socklen_t	msg_namelen;	/* size of address */
+	struct iovec	*msg_iov;	/* scatter/gather array */
+	int		msg_iovlen;	/* # elements in msg_iov */
+	void		*msg_control;	/* ancillary data, see below */
+	socklen_t	msg_controllen;	/* ancillary data buffer len */
+	int		msg_flags;	/* flags on received message */
+};
+
+/* BSD-compatible socket API. */
+int	accept(int, struct sockaddr * __restrict, socklen_t * __restrict);
+int	bind(int, const struct sockaddr *, socklen_t);
+int	connect(int, const struct sockaddr *, socklen_t);
+int	getpeername(int, struct sockaddr * __restrict, socklen_t * __restrict);
+int	getsockname(int, struct sockaddr * __restrict, socklen_t * __restrict);
+int	getsockopt(int, int, int, void * __restrict, socklen_t * __restrict);
+int	listen(int, int);
+ssize_t	recv(int, void *, size_t, int);
+ssize_t	recvfrom(int, void * __restrict, size_t, int,
+	    struct sockaddr * __restrict, socklen_t * __restrict);
+ssize_t recvmsg(int s, struct msghdr *msg, int flags);
+ssize_t	send(int, const void *, size_t, int);
+ssize_t	sendto(int, const void *,
+	    size_t, int, const struct sockaddr *, socklen_t);
+ssize_t sendmsg(int s, const struct msghdr *msg, int flags);
+int	setsockopt(int, int, int, const void *, socklen_t);
+int	shutdown(int, int);
+int	socket(int, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SYS_SOCKET_H_ */
-- 
2.31.1

